
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kulaginds/rdp-html5/cmd/server/main.go (64.9%)</option>
				
				<option value="file1">github.com/kulaginds/rdp-html5/internal/pkg/config/config.go (88.4%)</option>
				
				<option value="file2">github.com/kulaginds/rdp-html5/internal/pkg/handler/connect.go (44.8%)</option>
				
				<option value="file3">github.com/kulaginds/rdp-html5/internal/pkg/rdp/ber/read.go (0.0%)</option>
				
				<option value="file4">github.com/kulaginds/rdp-html5/internal/pkg/rdp/ber/write.go (0.0%)</option>
				
				<option value="file5">github.com/kulaginds/rdp-html5/internal/pkg/rdp/capabilities_exchange.go (0.0%)</option>
				
				<option value="file6">github.com/kulaginds/rdp-html5/internal/pkg/rdp/client.go (29.4%)</option>
				
				<option value="file7">github.com/kulaginds/rdp-html5/internal/pkg/rdp/client_test_extended.go (0.0%)</option>
				
				<option value="file8">github.com/kulaginds/rdp-html5/internal/pkg/rdp/close.go (0.0%)</option>
				
				<option value="file9">github.com/kulaginds/rdp-html5/internal/pkg/rdp/connect.go (0.0%)</option>
				
				<option value="file10">github.com/kulaginds/rdp-html5/internal/pkg/rdp/connection_finalization.go (0.0%)</option>
				
				<option value="file11">github.com/kulaginds/rdp-html5/internal/pkg/rdp/fastpath/protocol.go (0.0%)</option>
				
				<option value="file12">github.com/kulaginds/rdp-html5/internal/pkg/rdp/fastpath/receive.go (0.0%)</option>
				
				<option value="file13">github.com/kulaginds/rdp-html5/internal/pkg/rdp/fastpath/send.go (60.0%)</option>
				
				<option value="file14">github.com/kulaginds/rdp-html5/internal/pkg/rdp/fastpath/update_events.go (0.0%)</option>
				
				<option value="file15">github.com/kulaginds/rdp-html5/internal/pkg/rdp/gcc/conference_create_request.go (0.0%)</option>
				
				<option value="file16">github.com/kulaginds/rdp-html5/internal/pkg/rdp/gcc/conference_create_response.go (0.0%)</option>
				
				<option value="file17">github.com/kulaginds/rdp-html5/internal/pkg/rdp/get_update.go (0.0%)</option>
				
				<option value="file18">github.com/kulaginds/rdp-html5/internal/pkg/rdp/headers/mcs.go (0.0%)</option>
				
				<option value="file19">github.com/kulaginds/rdp-html5/internal/pkg/rdp/headers/security.go (0.0%)</option>
				
				<option value="file20">github.com/kulaginds/rdp-html5/internal/pkg/rdp/headers/tpkt.go (0.0%)</option>
				
				<option value="file21">github.com/kulaginds/rdp-html5/internal/pkg/rdp/headers/x224.go (0.0%)</option>
				
				<option value="file22">github.com/kulaginds/rdp-html5/internal/pkg/rdp/mcs/attach_user.go (30.4%)</option>
				
				<option value="file23">github.com/kulaginds/rdp-html5/internal/pkg/rdp/mcs/connect.go (63.4%)</option>
				
				<option value="file24">github.com/kulaginds/rdp-html5/internal/pkg/rdp/mcs/disconnect.go (20.0%)</option>
				
				<option value="file25">github.com/kulaginds/rdp-html5/internal/pkg/rdp/mcs/domain.go (69.2%)</option>
				
				<option value="file26">github.com/kulaginds/rdp-html5/internal/pkg/rdp/mcs/erect_domain.go (44.4%)</option>
				
				<option value="file27">github.com/kulaginds/rdp-html5/internal/pkg/rdp/mcs/join_channels.go (40.0%)</option>
				
				<option value="file28">github.com/kulaginds/rdp-html5/internal/pkg/rdp/mcs/protocol.go (0.0%)</option>
				
				<option value="file29">github.com/kulaginds/rdp-html5/internal/pkg/rdp/mcs/receive.go (0.0%)</option>
				
				<option value="file30">github.com/kulaginds/rdp-html5/internal/pkg/rdp/mcs/send.go (0.0%)</option>
				
				<option value="file31">github.com/kulaginds/rdp-html5/internal/pkg/rdp/mcs/types.go (77.8%)</option>
				
				<option value="file32">github.com/kulaginds/rdp-html5/internal/pkg/rdp/nla.go (0.0%)</option>
				
				<option value="file33">github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu/basic_settings_exchange.go (38.9%)</option>
				
				<option value="file34">github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu/capabilities.go (28.6%)</option>
				
				<option value="file35">github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu/capabilities_exchange.go (44.0%)</option>
				
				<option value="file36">github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu/connection_finalization.go (34.6%)</option>
				
				<option value="file37">github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu/connection_initiation.go (33.8%)</option>
				
				<option value="file38">github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu/data.go (40.7%)</option>
				
				<option value="file39">github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu/error_info.go (0.0%)</option>
				
				<option value="file40">github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu/input_events.go (0.0%)</option>
				
				<option value="file41">github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu/licensing.go (0.0%)</option>
				
				<option value="file42">github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu/secure_settings_exchange.go (67.6%)</option>
				
				<option value="file43">github.com/kulaginds/rdp-html5/internal/pkg/rdp/per/read.go (0.0%)</option>
				
				<option value="file44">github.com/kulaginds/rdp-html5/internal/pkg/rdp/per/write.go (0.0%)</option>
				
				<option value="file45">github.com/kulaginds/rdp-html5/internal/pkg/rdp/rail.go (0.0%)</option>
				
				<option value="file46">github.com/kulaginds/rdp-html5/internal/pkg/rdp/read.go (0.0%)</option>
				
				<option value="file47">github.com/kulaginds/rdp-html5/internal/pkg/rdp/remote_app.go (0.0%)</option>
				
				<option value="file48">github.com/kulaginds/rdp-html5/internal/pkg/rdp/rle/decompressor16.go (0.0%)</option>
				
				<option value="file49">github.com/kulaginds/rdp-html5/internal/pkg/rdp/rle/rle.go (0.0%)</option>
				
				<option value="file50">github.com/kulaginds/rdp-html5/internal/pkg/rdp/send_input_event.go (0.0%)</option>
				
				<option value="file51">github.com/kulaginds/rdp-html5/internal/pkg/rdp/tls.go (17.5%)</option>
				
				<option value="file52">github.com/kulaginds/rdp-html5/internal/pkg/rdp/tpkt/protocol.go (0.0%)</option>
				
				<option value="file53">github.com/kulaginds/rdp-html5/internal/pkg/rdp/tpkt/receive.go (0.0%)</option>
				
				<option value="file54">github.com/kulaginds/rdp-html5/internal/pkg/rdp/tpkt/send.go (0.0%)</option>
				
				<option value="file55">github.com/kulaginds/rdp-html5/internal/pkg/rdp/types.go (0.0%)</option>
				
				<option value="file56">github.com/kulaginds/rdp-html5/internal/pkg/rdp/utf16/encode.go (0.0%)</option>
				
				<option value="file57">github.com/kulaginds/rdp-html5/internal/pkg/rdp/virtual_channels.go (0.0%)</option>
				
				<option value="file58">github.com/kulaginds/rdp-html5/internal/pkg/rdp/write.go (0.0%)</option>
				
				<option value="file59">github.com/kulaginds/rdp-html5/internal/pkg/rdp/x224/connect.go (54.5%)</option>
				
				<option value="file60">github.com/kulaginds/rdp-html5/internal/pkg/rdp/x224/protocol.go (0.0%)</option>
				
				<option value="file61">github.com/kulaginds/rdp-html5/internal/pkg/rdp/x224/receive.go (0.0%)</option>
				
				<option value="file62">github.com/kulaginds/rdp-html5/internal/pkg/rdp/x224/send.go (0.0%)</option>
				
				<option value="file63">github.com/kulaginds/rdp-html5/test-config.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "errors"
        "flag"
        "fmt"
        "log"
        "net/http"
        _ "net/http/pprof"
        "strings"
        "time"

        "github.com/kulaginds/rdp-html5/internal/pkg/config"
        "github.com/kulaginds/rdp-html5/internal/pkg/handler"
)

const (
        appName    = "RDP HTML5 Client"
        appVersion = "v2.0.0"
)

func main() <span class="cov0" title="0">{
        hostFlag := flag.String("host", "", "RDP HTML5 server host")
        portFlag := flag.String("port", "", "RDP HTML5 server port")
        logLevelFlag := flag.String("log-level", "", "log level (debug, info, warn, error)")
        skipTLS := flag.Bool("skip-tls-verify", false, "skip TLS certificate validation")
        skipSSL := flag.Bool("skip-ssl-verify", false, "skip TLS certificate validation (deprecated alias)")
        tlsServerName := flag.String("tls-server-name", "", "override TLS server name")
        useNLA := flag.Bool("nla", false, "enable Network Level Authentication (NLA/CredSSP)")
        helpFlag := flag.Bool("help", false, "show help")
        versionFlag := flag.Bool("version", false, "show version")

        flag.Parse()

        if *helpFlag </span><span class="cov0" title="0">{
                showHelp()
                return
        }</span>

        <span class="cov0" title="0">if *versionFlag </span><span class="cov0" title="0">{
                showVersion()
                return
        }</span>

        <span class="cov0" title="0">opts := config.LoadOptions{
                Host:              strings.TrimSpace(*hostFlag),
                Port:              strings.TrimSpace(*portFlag),
                LogLevel:          strings.TrimSpace(*logLevelFlag),
                SkipTLSValidation: *skipTLS || *skipSSL,
                TLSServerName:     strings.TrimSpace(*tlsServerName),
                UseNLA:            *useNLA,
        }

        cfg, err := config.LoadWithOverrides(opts)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to load config: %v", err)
        }</span>

        <span class="cov0" title="0">setupLogging(cfg.Logging)

        server := createServer(cfg)
        log.Printf("starting server on %s:%s (TLS=%t)", cfg.Server.Host, cfg.Server.Port, cfg.Security.EnableTLS)

        if err := startServer(server, cfg); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
}

func createServer(cfg *config.Config) *http.Server <span class="cov4" title="2">{
        addr := fmt.Sprintf("%s:%s", cfg.Server.Host, cfg.Server.Port)

        mux := http.NewServeMux()
        mux.Handle("/", http.FileServer(http.Dir("./web")))
        mux.HandleFunc("/connect", handler.Connect)

        h := applySecurityMiddleware(mux, cfg)
        h = requestLoggingMiddleware(h)

        return &amp;http.Server{
                Addr:         addr,
                Handler:      h,
                ReadTimeout:  cfg.Server.ReadTimeout,
                WriteTimeout: cfg.Server.WriteTimeout,
                IdleTimeout:  cfg.Server.IdleTimeout,
        }
}</span>

func applySecurityMiddleware(next http.Handler, cfg *config.Config) http.Handler <span class="cov5" title="3">{
        if cfg == nil </span><span class="cov0" title="0">{
                return securityHeadersMiddleware(corsMiddleware(next, nil))
        }</span>

        <span class="cov5" title="3">h := next
        if cfg.Security.EnableRateLimit </span><span class="cov4" title="2">{
                h = rateLimitMiddleware(h, cfg.Security.RateLimitPerMinute)
        }</span>
        <span class="cov5" title="3">h = corsMiddleware(h, cfg.Security.AllowedOrigins)
        h = securityHeadersMiddleware(h)

        return h</span>
}

func securityHeadersMiddleware(next http.Handler) http.Handler <span class="cov7" title="4">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="2">{
                w.Header().Set("X-Content-Type-Options", "nosniff")
                w.Header().Set("X-Frame-Options", "DENY")
                w.Header().Set("X-XSS-Protection", "1; mode=block")
                w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
                w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")
                // Allow inline scripts/styles and WASM for the single-page UI
                w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self' 'unsafe-inline' 'wasm-unsafe-eval'; style-src 'self' 'unsafe-inline'; connect-src 'self' ws: wss:")

                next.ServeHTTP(w, r)
        }</span>)
}

func corsMiddleware(next http.Handler, allowedOrigins []string) http.Handler <span class="cov10" title="8">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="6">{
                origin := r.Header.Get("Origin")
                if isOriginAllowed(origin, allowedOrigins, r.Host) </span><span class="cov7" title="4">{
                        w.Header().Set("Access-Control-Allow-Origin", origin)
                        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
                        w.Header().Set("Access-Control-Allow-Credentials", "true")
                }</span>

                <span class="cov8" title="6">if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov8" title="6">next.ServeHTTP(w, r)</span>
        })
}

func isOriginAllowed(origin string, allowedOrigins []string, host string) bool <span class="cov8" title="6">{
        if origin == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="6">for _, allowed := range allowedOrigins </span><span class="cov7" title="4">{
                if strings.TrimSpace(allowed) == origin </span><span class="cov5" title="3">{
                        return true
                }</span>
        }

        <span class="cov5" title="3">if len(allowedOrigins) == 0 </span><span class="cov4" title="2">{
                return strings.Contains(origin, host)
        }</span>

        <span class="cov1" title="1">return false</span>
}

func rateLimitMiddleware(next http.Handler, _ int) http.Handler <span class="cov5" title="3">{
        // Simplified placeholder: production implementation should enforce rate limits
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="2">{
                next.ServeHTTP(w, r)
        }</span>)
}

func setupLogging(_ config.LoggingConfig) <span class="cov7" title="4">{
        log.SetFlags(log.LstdFlags | log.LUTC)
        log.SetOutput(log.Writer())
}</span>

func requestLoggingMiddleware(next http.Handler) http.Handler <span class="cov4" title="2">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                next.ServeHTTP(w, r)
                log.Printf("%s %s %s %s", r.RemoteAddr, r.Method, r.URL.Path, time.Since(start))
        }</span>)
}

func startServer(server *http.Server, _ *config.Config) error <span class="cov1" title="1">{
        if server == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server is nil")
        }</span>

        <span class="cov1" title="1">err := server.ListenAndServe()
        if errors.Is(err, http.ErrServerClosed) </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">return err</span>
}

func showHelp() <span class="cov1" title="1">{
        fmt.Println(appName)
        fmt.Println("USAGE: rdp-html5 [options]")
        fmt.Println("OPTIONS:")
        fmt.Println("  -host               Set server listen host (default 0.0.0.0)")
        fmt.Println("  -port               Set server listen port (default 8080)")
        fmt.Println("  -log-level          Set log level (debug, info, warn, error)")
        fmt.Println("  -skip-tls-verify    Skip TLS certificate validation")
        fmt.Println("  -skip-ssl-verify    Skip TLS certificate validation (alias)")
        fmt.Println("  -tls-server-name    Override TLS server name")
        fmt.Println("  -version            Show version information")
        fmt.Println("  -help               Show this help message")
        fmt.Println("ENVIRONMENT VARIABLES: SERVER_HOST, SERVER_PORT, LOG_LEVEL, SKIP_TLS_VALIDATION, TLS_SERVER_NAME")
        fmt.Println("EXAMPLES: rdp-html5 -host 0.0.0.0 -port 8080")
}</span>

func showVersion() <span class="cov1" title="1">{
        fmt.Printf("%s %s\n", appName, appVersion)
        fmt.Println("Built with Go", time.Now().Year())
        fmt.Println("Protocol: RDP 10.x")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"
)

// globalConfig stores the configuration loaded with command-line overrides
// This allows other packages to access the same configuration that was loaded by the server
var (
        globalConfig *Config
        configMutex  sync.Mutex
)

// Config holds the application configuration
type Config struct {
        Server   ServerConfig   `json:"server"`
        RDP      RDPConfig      `json:"rdp"`
        Security SecurityConfig `json:"security"`
        Logging  LoggingConfig  `json:"logging"`
}

// LoadOptions holds command-line override options
type LoadOptions struct {
        Host              string
        Port              string
        LogLevel          string
        ConfigFile        string
        SkipTLSValidation bool
        TLSServerName     string
        UseNLA            bool
}

// ServerConfig holds server-specific configuration
type ServerConfig struct {
        Host         string        `json:"host" env:"SERVER_HOST" default:"0.0.0.0"`
        Port         string        `json:"port" env:"SERVER_PORT" default:"8080"`
        ReadTimeout  time.Duration `json:"readTimeout" env:"SERVER_READ_TIMEOUT" default:"30s"`
        WriteTimeout time.Duration `json:"writeTimeout" env:"SERVER_WRITE_TIMEOUT" default:"30s"`
        IdleTimeout  time.Duration `json:"idleTimeout" env:"SERVER_IDLE_TIMEOUT" default:"120s"`
}

// RDPConfig holds RDP-specific configuration
type RDPConfig struct {
        DefaultWidth  int           `json:"defaultWidth" env:"RDP_DEFAULT_WIDTH" default:"1024"`
        DefaultHeight int           `json:"defaultHeight" env:"RDP_DEFAULT_HEIGHT" default:"768"`
        MaxWidth      int           `json:"maxWidth" env:"RDP_MAX_WIDTH" default:"3840"`
        MaxHeight     int           `json:"maxHeight" env:"RDP_MAX_HEIGHT" default:"2160"`
        BufferSize    int           `json:"bufferSize" env:"RDP_BUFFER_SIZE" default:"65536"`
        Timeout       time.Duration `json:"timeout" env:"RDP_TIMEOUT" default:"10s"`
}

// SecurityConfig holds security-related configuration
type SecurityConfig struct {
        AllowedOrigins     []string `json:"allowedOrigins" env:"ALLOWED_ORIGINS" default:""`
        MaxConnections     int      `json:"maxConnections" env:"MAX_CONNECTIONS" default:"100"`
        EnableRateLimit    bool     `json:"enableRateLimit" env:"ENABLE_RATE_LIMIT" default:"true"`
        RateLimitPerMinute int      `json:"rateLimitPerMinute" env:"RATE_LIMIT_PER_MINUTE" default:"60"`
        EnableTLS          bool     `json:"enableTLS" env:"ENABLE_TLS" default:"false"`
        TLSCertFile        string   `json:"tlsCertFile" env:"TLS_CERT_FILE" default:""`
        TLSKeyFile         string   `json:"tlsKeyFile" env:"TLS_KEY_FILE" default:""`
        MinTLSVersion      string   `json:"minTLSVersion" env:"MIN_TLS_VERSION" default:"1.2"`
        SkipTLSValidation  bool     `json:"skipTLSValidation" env:"SKIP_TLS_VALIDATION" default:"false"`
        TLSServerName      string   `json:"tlsServerName" env:"TLS_SERVER_NAME" default:""`
        UseNLA             bool     `json:"useNLA" env:"USE_NLA" default:"true"`
}

// LoggingConfig holds logging configuration
type LoggingConfig struct {
        Level        string `json:"level" env:"LOG_LEVEL" default:"info"`
        Format       string `json:"format" env:"LOG_FORMAT" default:"text"`
        EnableCaller bool   `json:"enableCaller" env:"LOG_ENABLE_CALLER" default:"false"`
        File         string `json:"file" env:"LOG_FILE" default:""`
}

// Load loads configuration from environment variables with defaults
func Load() (*Config, error) <span class="cov2" title="2">{
        return LoadWithOverrides(LoadOptions{})
}</span>

// LoadWithOverrides loads configuration with command-line overrides
func LoadWithOverrides(opts LoadOptions) (*Config, error) <span class="cov3" title="3">{
        config := &amp;Config{}

        // Server config
        config.Server.Host = getOverrideOrEnv(opts.Host, "SERVER_HOST", "0.0.0.0")
        config.Server.Port = getOverrideOrEnv(opts.Port, "SERVER_PORT", "8080")
        config.Server.ReadTimeout = getDurationWithDefault("SERVER_READ_TIMEOUT", 30*time.Second)
        config.Server.WriteTimeout = getDurationWithDefault("SERVER_WRITE_TIMEOUT", 30*time.Second)
        config.Server.IdleTimeout = getDurationWithDefault("SERVER_IDLE_TIMEOUT", 120*time.Second)

        // RDP config
        config.RDP.DefaultWidth = getIntWithDefault("RDP_DEFAULT_WIDTH", 1024)
        config.RDP.DefaultHeight = getIntWithDefault("RDP_DEFAULT_HEIGHT", 768)
        config.RDP.MaxWidth = getIntWithDefault("RDP_MAX_WIDTH", 3840)
        config.RDP.MaxHeight = getIntWithDefault("RDP_MAX_HEIGHT", 2160)
        config.RDP.BufferSize = getIntWithDefault("RDP_BUFFER_SIZE", 65536)
        config.RDP.Timeout = getDurationWithDefault("RDP_TIMEOUT", 10*time.Second)

        // Security config
        config.Security.AllowedOrigins = getStringSliceWithDefault("ALLOWED_ORIGINS", []string{})
        config.Security.MaxConnections = getIntWithDefault("MAX_CONNECTIONS", 100)
        config.Security.EnableRateLimit = getBoolWithDefault("ENABLE_RATE_LIMIT", true)
        config.Security.RateLimitPerMinute = getIntWithDefault("RATE_LIMIT_PER_MINUTE", 60)
        config.Security.EnableTLS = getBoolWithDefault("ENABLE_TLS", false)
        config.Security.TLSCertFile = getEnvWithDefault("TLS_CERT_FILE", "")
        config.Security.TLSKeyFile = getEnvWithDefault("TLS_KEY_FILE", "")
        config.Security.MinTLSVersion = getEnvWithDefault("MIN_TLS_VERSION", "1.2")
        config.Security.SkipTLSValidation = getBoolWithDefault("SKIP_TLS_VALIDATION", false) || opts.SkipTLSValidation
        config.Security.TLSServerName = getOverrideOrEnv(opts.TLSServerName, "TLS_SERVER_NAME", "")
        // Default to NLA enabled (true) unless explicitly disabled
        if opts.UseNLA </span><span class="cov0" title="0">{
                config.Security.UseNLA = true
        }</span> else<span class="cov3" title="3"> {
                config.Security.UseNLA = getBoolWithDefault("USE_NLA", true)
        }</span>

        // Logging config
        <span class="cov3" title="3">config.Logging.Level = getOverrideOrEnv(opts.LogLevel, "LOG_LEVEL", "info")
        config.Logging.Format = getEnvWithDefault("LOG_FORMAT", "text")
        config.Logging.EnableCaller = getBoolWithDefault("LOG_ENABLE_CALLER", false)
        config.Logging.File = getEnvWithDefault("LOG_FILE", "")

        // Validate configuration
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Store the configuration globally so other packages can access it
        <span class="cov3" title="3">configMutex.Lock()
        globalConfig = config
        configMutex.Unlock()

        return config, nil</span>
}

// GetGlobalConfig returns the globally stored configuration
// This should be used by packages that need access to the configuration
// loaded by the server with command-line overrides
func GetGlobalConfig() *Config <span class="cov0" title="0">{
        configMutex.Lock()
        defer configMutex.Unlock()
        return globalConfig
}</span>

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov7" title="12">{
        // Validate server config
        if c.Server.Port == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("server port cannot be empty")
        }</span>

        <span class="cov7" title="11">if port, err := strconv.Atoi(c.Server.Port); err != nil || port &lt; 1 || port &gt; 65535 </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid server port: %s", c.Server.Port)
        }</span>

        // Validate RDP config
        <span class="cov7" title="10">if c.RDP.DefaultWidth &lt;= 0 || c.RDP.DefaultHeight &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("default dimensions must be positive")
        }</span>

        <span class="cov6" title="9">if c.RDP.MaxWidth &lt; c.RDP.DefaultWidth || c.RDP.MaxHeight &lt; c.RDP.DefaultHeight </span><span class="cov1" title="1">{
                return fmt.Errorf("max dimensions must be &gt;= default dimensions")
        }</span>

        <span class="cov6" title="8">if c.RDP.BufferSize &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("buffer size must be positive")
        }</span>

        // Validate security config
        <span class="cov6" title="7">if c.Security.EnableTLS </span><span class="cov1" title="1">{
                if c.Security.TLSCertFile == "" || c.Security.TLSKeyFile == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("TLS certificate and key files must be specified when TLS is enabled")
                }</span>

                <span class="cov0" title="0">if _, err := os.Stat(c.Security.TLSCertFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS certificate file does not exist: %s", c.Security.TLSCertFile)
                }</span>

                <span class="cov0" title="0">if _, err := os.Stat(c.Security.TLSKeyFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS key file does not exist: %s", c.Security.TLSKeyFile)
                }</span>
        }

        <span class="cov5" title="6">if c.Security.MaxConnections &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max connections must be positive")
        }</span>

        <span class="cov5" title="6">if c.Security.RateLimitPerMinute &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("rate limit per minute must be positive")
        }</span>

        // Validate logging config
        <span class="cov5" title="6">validLogLevels := map[string]bool{
                "debug": true,
                "info":  true,
                "warn":  true,
                "error": true,
        }

        if !validLogLevels[c.Logging.Level] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid log level: %s", c.Logging.Level)
        }</span>

        <span class="cov5" title="5">validLogFormats := map[string]bool{
                "text": true,
                "json": true,
        }

        if !validLogFormats[c.Logging.Format] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid log format: %s", c.Logging.Format)
        }</span>

        <span class="cov4" title="4">return nil</span>
}

// Helper functions for environment variable parsing
func getEnvWithDefault(key, defaultValue string) string <span class="cov10" title="28">{
        if value := os.Getenv(key); value != "" </span><span class="cov5" title="5">{
                return value
        }</span>
        <span class="cov9" title="23">return defaultValue</span>
}

func getIntWithDefault(key string, defaultValue int) int <span class="cov9" title="24">{
        if value := os.Getenv(key); value != "" </span><span class="cov5" title="5">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov4" title="4">{
                        return intValue
                }</span>
        }
        <span class="cov9" title="20">return defaultValue</span>
}

func getBoolWithDefault(key string, defaultValue bool) bool <span class="cov8" title="19">{
        if value := os.Getenv(key); value != "" </span><span class="cov3" title="3">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov2" title="2">{
                        return boolValue
                }</span>
        }
        <span class="cov8" title="17">return defaultValue</span>
}

func getDurationWithDefault(key string, defaultValue time.Duration) time.Duration <span class="cov8" title="15">{
        if value := os.Getenv(key); value != "" </span><span class="cov2" title="2">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov1" title="1">{
                        return duration
                }</span>
        }
        <span class="cov8" title="14">return defaultValue</span>
}

func getStringSliceWithDefault(key string, defaultValue []string) []string <span class="cov5" title="6">{
        if value := os.Getenv(key); value != "" </span><span class="cov1" title="1">{
                return splitString(value, ",")
        }</span>
        <span class="cov5" title="5">return defaultValue</span>
}

// getOverrideOrEnv returns command-line override value, env value, or default
func getOverrideOrEnv(override, envKey, defaultValue string) string <span class="cov8" title="15">{
        if override != "" </span><span class="cov4" title="4">{
                return override
        }</span>
        <span class="cov7" title="11">return getEnvWithDefault(envKey, defaultValue)</span>
}

func splitString(s, sep string) []string <span class="cov5" title="5">{
        if s == "" </span><span class="cov1" title="1">{
                return []string{}
        }</span>

        <span class="cov4" title="4">var result []string
        for _, part := range strings.Split(s, sep) </span><span class="cov7" title="12">{
                if trimmed := strings.TrimSpace(part); trimmed != "" </span><span class="cov7" title="11">{
                        result = append(result, trimmed)
                }</span>
        }
        <span class="cov4" title="4">return result</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handler

import (
        "context"
        "errors"
        "fmt"
        "log"
        "net/http"
        "os"
        "strconv"
        "strings"

        "github.com/gorilla/websocket"

        "github.com/kulaginds/rdp-html5/internal/pkg/config"
        "github.com/kulaginds/rdp-html5/internal/pkg/rdp"
        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/fastpath"
        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu"
)

const (
        webSocketReadBufferSize  = 8192
        webSocketWriteBufferSize = 8192 * 2
)

type rdpConn interface {
        GetUpdate() (*fastpath.UpdatePDU, error)
        SendInputEvent(data []byte) error
}

func Connect(w http.ResponseWriter, r *http.Request) <span class="cov10" title="10">{
        upgrader := websocket.Upgrader{
                ReadBufferSize:  webSocketReadBufferSize,
                WriteBufferSize: webSocketWriteBufferSize,
                CheckOrigin: func(r *http.Request) bool </span><span class="cov1" title="1">{
                        return isAllowedOrigin(r.Header.Get("Origin"))
                }</span>,
        }
        <span class="cov10" title="10">protocol := r.Header.Get("Sec-Websocket-Protocol")

        wsConn, err := upgrader.Upgrade(w, r, http.Header{
                "Sec-Websocket-Protocol": {protocol},
        })
        if err != nil </span><span class="cov9" title="9">{
                log.Println(fmt.Errorf("upgrade websocket: %w", err))

                return
        }</span>

        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err = wsConn.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Println(fmt.Errorf("error closing websocket: %w", err))
                }</span>
        }()

        <span class="cov1" title="1">ctx, cancel := context.WithCancel(r.Context())
        defer cancel()

        width, err := strconv.Atoi(r.URL.Query().Get("width"))
        if err != nil </span><span class="cov0" title="0">{
                log.Println(fmt.Errorf("get width: %w", err))

                return
        }</span>

        <span class="cov1" title="1">height, err := strconv.Atoi(r.URL.Query().Get("height"))
        if err != nil </span><span class="cov0" title="0">{
                log.Println(fmt.Errorf("get height: %w", err))

                return
        }</span>

        <span class="cov1" title="1">host := r.URL.Query().Get("host")
        user := r.URL.Query().Get("user")
        password := r.URL.Query().Get("password")

        rdpClient, err := rdp.NewClient(host, user, password, width, height)
        if err != nil </span><span class="cov1" title="1">{
                log.Println(fmt.Errorf("rdp init: %w", err))

                return
        }</span>
        <span class="cov0" title="0">defer rdpClient.Close()

        // Set TLS configuration from server config (use global config if available)
        cfg := config.GetGlobalConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                // Fallback to loading config if global config not available (for testing)
                var err error
                cfg, err = config.Load()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to load config for TLS settings: %v", err)
                        cfg = &amp;config.Config{}
                }</span>
        }

        <span class="cov0" title="0">log.Printf("Setting RDP client TLS config: SkipValidation=%t, ServerName='%s'",
                cfg.Security.SkipTLSValidation, cfg.Security.TLSServerName)
        rdpClient.SetTLSConfig(cfg.Security.SkipTLSValidation, cfg.Security.TLSServerName)

        // Set NLA configuration - enable NLA by default for servers that require it
        log.Printf("Setting RDP client NLA config: UseNLA=%t", cfg.Security.UseNLA)
        rdpClient.SetUseNLA(cfg.Security.UseNLA)

        // TODO: implement
        //rdpClient.SetRemoteApp("C:\\agent\\agent.exe", ".\\Downloads\\cbct1.zip", "C:\\Users\\Doc")
        //rdpClient.SetRemoteApp("explore", "", "")

        if err = rdpClient.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Println(fmt.Errorf("rdp connect: %w", err))

                return
        }</span>

        <span class="cov0" title="0">log.Println("begin proxying")

        go wsToRdp(ctx, wsConn, rdpClient, cancel)
        rdpToWs(ctx, rdpClient, wsConn)</span>
}

func wsToRdp(ctx context.Context, wsConn *websocket.Conn, rdpConn rdpConn, cancel context.CancelFunc) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                log.Println("wsToRdp done")
                cancel()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span> // pass
                }

                <span class="cov0" title="0">_, data, err := wsConn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if strings.HasSuffix(err.Error(), "use of closed network connection") </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">log.Println(fmt.Errorf("error reading message from ws: %w", err))

                        return</span>
                }

                <span class="cov0" title="0">if err = rdpConn.SendInputEvent(data); err != nil </span><span class="cov0" title="0">{
                        log.Println(fmt.Errorf("failed writing to rdp: %w", err))

                        return
                }</span>
        }
}

func rdpToWs(ctx context.Context, rdpConn rdpConn, wsConn *websocket.Conn) <span class="cov1" title="1">{
        defer func() </span><span class="cov1" title="1">{
                log.Println("rdpToWs done")
        }</span>()

        <span class="cov1" title="1">var (
                update *fastpath.UpdatePDU
                err    error
        )

        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                default:<span class="cov0" title="0"></span> // pass
                }

                <span class="cov0" title="0">update, err = rdpConn.GetUpdate()
                switch </span>{
                case err == nil:<span class="cov0" title="0"></span> // pass
                case errors.Is(err, pdu.ErrDeactiateAll):<span class="cov0" title="0">
                        log.Println("deactivate all")

                        return</span>

                default:<span class="cov0" title="0">
                        log.Println(fmt.Errorf("get update: %w", err))

                        return</span>
                }

                <span class="cov0" title="0">if err = wsConn.WriteMessage(websocket.BinaryMessage, update.Data); err != nil </span><span class="cov0" title="0">{
                        if err == websocket.ErrCloseSent </span><span class="cov0" title="0">{
                                log.Println("sent to closed websocket")

                                return
                        }</span>

                        <span class="cov0" title="0">log.Println(fmt.Errorf("failed sending message to ws: %w", err))

                        return</span>
                }
        }
}

func isAllowedOrigin(origin string) bool <span class="cov8" title="7">{
        if origin == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="7">normalized := strings.TrimPrefix(strings.TrimPrefix(origin, "http://"), "https://")
        normalized = strings.TrimSuffix(normalized, "/")

        allowed := os.Getenv("ALLOWED_ORIGINS")
        if allowed == "" </span><span class="cov5" title="3">{
                return strings.HasPrefix(normalized, "localhost") || strings.HasPrefix(normalized, "127.0.0.1")
        }</span>

        // Always allow localhost-style origins for development, even when a list is provided
        <span class="cov6" title="4">if strings.HasPrefix(normalized, "localhost") || strings.HasPrefix(normalized, "127.0.0.1") </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov5" title="3">for _, entry := range strings.Split(allowed, ",") </span><span class="cov7" title="5">{
                candidate := strings.TrimSpace(entry)
                if candidate == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Support allow-list entries with or without scheme
                <span class="cov7" title="5">if candidate == origin || candidate == normalized </span><span class="cov3" title="2">{
                        return true
                }</span>

                <span class="cov5" title="3">if strings.TrimPrefix(candidate, "http://") == normalized || strings.TrimPrefix(candidate, "https://") == normalized </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package ber

import (
        "encoding/binary"
        "errors"
        "fmt"
        "io"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/asn1"
)

func ReadApplicationTag(r io.Reader) (uint8, error) <span class="cov0" title="0">{
        var (
                identifier uint8
                tag        uint8
                err        error
        )

        err = binary.Read(r, binary.BigEndian, &amp;identifier)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if identifier != (asn1.ClassApplication|asn1.PCConstruct)|asn1.TagMask </span><span class="cov0" title="0">{
                return 0, errors.New("ReadApplicationTag invalid data")
        }</span>

        <span class="cov0" title="0">err = binary.Read(r, binary.BigEndian, &amp;tag)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return tag, nil</span>
}

func ReadLength(r io.Reader) (uint16, error) <span class="cov0" title="0">{
        var (
                ret  uint16
                size uint8
                err  error
        )

        err = binary.Read(r, binary.BigEndian, &amp;size)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if size&amp;0x80 &gt; 0 </span><span class="cov0" title="0">{
                size = size &amp;^ 0x80

                if size == 1 </span><span class="cov0" title="0">{
                        err = binary.Read(r, binary.BigEndian, &amp;size)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>

                        <span class="cov0" title="0">ret = uint16(size)</span>
                } else<span class="cov0" title="0"> if size == 2 </span><span class="cov0" title="0">{
                        err = binary.Read(r, binary.BigEndian, &amp;ret)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return 0, errors.New("BER length may be 1 or 2")
                }</span>
        } else<span class="cov0" title="0"> {
                ret = uint16(size)
        }</span>

        <span class="cov0" title="0">return ret, nil</span>
}

func berPC(pc bool) uint8 <span class="cov0" title="0">{
        if pc </span><span class="cov0" title="0">{
                return asn1.PCConstruct
        }</span>
        <span class="cov0" title="0">return asn1.PCPrimitive</span>
}

func ReadUniversalTag(tag uint8, pc bool, r io.Reader) (bool, error) <span class="cov0" title="0">{
        var bb uint8

        err := binary.Read(r, binary.BigEndian, &amp;bb)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return bb == (asn1.ClassUniversal|berPC(pc))|(asn1.TagMask&amp;tag), nil</span>
}

func ReadEnumerated(r io.Reader) (uint8, error) <span class="cov0" title="0">{
        universalTag, err := ReadUniversalTag(asn1.TagEnumerated, false, r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if !universalTag </span><span class="cov0" title="0">{
                return 0, errors.New("invalid ber tag")
        }</span>

        <span class="cov0" title="0">length, err := ReadLength(r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if length != 1 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("enumerate size is wrong, get %v, expect 1", length)
        }</span>

        <span class="cov0" title="0">var enumerated uint8

        return enumerated, binary.Read(r, binary.BigEndian, &amp;enumerated)</span>
}

func ReadInteger(r io.Reader) (int, error) <span class="cov0" title="0">{
        universalTag, err := ReadUniversalTag(asn1.TagInteger, false, r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if !universalTag </span><span class="cov0" title="0">{
                return 0, errors.New("Bad integer tag")
        }</span>

        <span class="cov0" title="0">size, err := ReadLength(r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">switch size </span>{
        case 1:<span class="cov0" title="0">
                var num uint8

                return int(num), binary.Read(r, binary.BigEndian, &amp;num)</span>
        case 2:<span class="cov0" title="0">
                var num uint16

                return int(num), binary.Read(r, binary.BigEndian, &amp;num)</span>
        case 3:<span class="cov0" title="0">
                var (
                        int1 uint8
                        int2 uint16
                )

                err = binary.Read(r, binary.BigEndian, &amp;int1)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">err = binary.Read(r, binary.BigEndian, &amp;int2)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">return int(int1)&lt;&lt;0x10 + int(int2), nil</span>
        case 4:<span class="cov0" title="0">
                var num uint32

                return int(num), binary.Read(r, binary.BigEndian, &amp;num)</span>
        default:<span class="cov0" title="0">
                return 0, errors.New("wrong size")</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package ber

import (
        "encoding/binary"
        "io"
)

func WriteBoolean(b bool, w io.Writer) <span class="cov0" title="0">{
        bb := uint8(0)
        if b </span><span class="cov0" title="0">{
                bb = uint8(0xff)
        }</span>
        <span class="cov0" title="0">w.Write([]byte{0x01}) // tag boolean
        WriteLength(1, w)
        w.Write([]byte{bb})</span>
}

func WriteInteger(n int, w io.Writer) <span class="cov0" title="0">{
        w.Write([]byte{0x02}) // tag integer
        if n &lt;= 0xff </span><span class="cov0" title="0">{
                WriteLength(1, w)
                w.Write([]byte{uint8(n)})
        }</span> else<span class="cov0" title="0"> if n &lt;= 0xffff </span><span class="cov0" title="0">{
                WriteLength(2, w)
                binary.Write(w, binary.BigEndian, uint16(n))
        }</span> else<span class="cov0" title="0"> {
                WriteLength(4, w)
                binary.Write(w, binary.BigEndian, uint32(n))
        }</span>
}

func WriteOctetString(str []byte, w io.Writer) <span class="cov0" title="0">{
        w.Write([]byte{0x04}) // tag octet string
        WriteLength(len(str), w)
        w.Write(str)
}</span>

func WriteSequence(data []byte, w io.Writer) <span class="cov0" title="0">{
        w.Write([]byte{0x30}) // tag sequence
        WriteLength(len(data), w)
        w.Write(data)
}</span>

func WriteApplicationTag(tag uint8, size int, w io.Writer) <span class="cov0" title="0">{
        if tag &gt; 30 </span><span class="cov0" title="0">{
                w.Write([]byte{
                        0x7f, // leading octet for tags with number greater than or equal to 31
                        tag,
                })
                WriteLength(size, w)
        }</span> else<span class="cov0" title="0"> {
                w.Write([]byte{tag})
                WriteLength(size, w)
        }</span>
}

func WriteLength(size int, w io.Writer) <span class="cov0" title="0">{
        if size &gt; 0x7f </span><span class="cov0" title="0">{
                w.Write([]byte{0x82})
                binary.Write(w, binary.BigEndian, uint16(size))
        }</span> else<span class="cov0" title="0"> {
                w.Write([]byte{uint8(size)})
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package rdp

import "github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu"

func (c *client) capabilitiesExchange() error <span class="cov0" title="0">{
        _, wire, err := c.mcsLayer.Receive()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var resp pdu.ServerDemandActive
        if err = resp.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.shareID = resp.ShareID
        c.serverCapabilitySets = resp.CapabilitySets

        req := pdu.NewClientConfirmActive(resp.ShareID, c.userID, c.desktopWidth, c.desktopHeight, c.remoteApp != nil)

        return c.mcsLayer.Send(c.userID, c.channelIDMap["global"], req.Serialize())</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package rdp

import (
        "bufio"
        "fmt"
        "net"
        "time"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/fastpath"
        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/mcs"
        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu"
        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/tpkt"
        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/x224"
)

type RemoteApp struct {
        App        string
        WorkingDir string
        Args       string
}

type client struct {
        conn       net.Conn
        buffReader *bufio.Reader
        tpktLayer  *tpkt.Protocol
        x224Layer  *x224.Protocol
        mcsLayer   *mcs.Protocol
        fastPath   *fastpath.Protocol

        domain   string
        username string
        password string

        desktopWidth, desktopHeight uint16

        serverCapabilitySets []pdu.CapabilitySet
        remoteApp            *RemoteApp
        railState            RailState

        selectedProtocol       pdu.NegotiationProtocol
        serverNegotiationFlags pdu.NegotiationResponseFlag
        channels               []string
        channelIDMap           map[string]uint16
        skipChannelJoin        bool
        shareID                uint32
        userID                 uint16

        // TLS configuration
        skipTLSValidation bool
        tlsServerName     string

        // NLA configuration
        useNLA bool
}

const (
        tcpConnectionTimeout = 5 * time.Second
        readBufferSize       = 64 * 1024
)

func NewClient(
        hostname, username, password string,
        desktopWidth, desktopHeight int,
) (*client, error) <span class="cov10" title="2">{
        c := client{
                domain:   "",
                username: username,
                password: password,

                desktopWidth:  uint16(desktopWidth),
                desktopHeight: uint16(desktopHeight),

                selectedProtocol: pdu.NegotiationProtocolSSL,
                // Default TLS configuration - can be overridden with SetTLSConfig
                skipTLSValidation: false,
                tlsServerName:     "",
        }

        var err error

        c.conn, err = net.DialTimeout("tcp", hostname, tcpConnectionTimeout)
        if err != nil </span><span class="cov10" title="2">{
                return nil, fmt.Errorf("tcp connect: %w", err)
        }</span>

        <span class="cov0" title="0">c.buffReader = bufio.NewReaderSize(c.conn, readBufferSize)

        c.tpktLayer = tpkt.New(&amp;c)
        c.x224Layer = x224.New(c.tpktLayer)
        c.mcsLayer = mcs.New(c.x224Layer)
        c.fastPath = fastpath.New(&amp;c)

        return &amp;c, nil</span>
}

// SetTLSConfig allows setting TLS configuration for the RDP client
func (c *client) SetTLSConfig(skipValidation bool, serverName string) <span class="cov0" title="0">{
        c.skipTLSValidation = skipValidation
        c.tlsServerName = serverName
}</span>

// SetUseNLA enables or disables Network Level Authentication
func (c *client) SetUseNLA(useNLA bool) <span class="cov0" title="0">{
        c.useNLA = useNLA
        if useNLA </span><span class="cov0" title="0">{
                c.selectedProtocol = pdu.NegotiationProtocolHybrid
        }</span> else<span class="cov0" title="0"> {
                c.selectedProtocol = pdu.NegotiationProtocolSSL
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package rdp

import (
        "net"
        "testing"
        "time"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu"
        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/require"
)

func TestClient_getServerName_extended(t *testing.T) <span class="cov0" title="0">{
        tests := []struct {
                name           string
                setupConn      func() net.Conn
                expectedResult string
                expectedEmpty  bool
        }{
                {
                        name: "valid connection with hostname",
                        setupConn: func() net.Conn </span><span class="cov0" title="0">{
                                // Create a mock connection
                                _, client := net.Pipe()
                                client.Close() // Close one end to simulate a real connection
                                return client
                        }</span>,
                        expectedResult: "", // Pipe will fallback to empty
                        expectedEmpty:  true,
                },
                {
                        name: "nil connection",
                        setupConn: func() net.Conn <span class="cov0" title="0">{
                                return nil
                        }</span>,
                        expectedResult: "",
                        expectedEmpty:  true,
                },
        }

        <span class="cov0" title="0">for _, tt := range tests </span><span class="cov0" title="0">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov0" title="0">{
                        client := &amp;client{
                                conn: tt.setupConn(),
                        }

                        result := client.getServerName()

                        if tt.expectedEmpty </span><span class="cov0" title="0">{
                                assert.Empty(t, result)
                        }</span> else<span class="cov0" title="0"> {
                                assert.Equal(t, tt.expectedResult, result)
                        }</span>
                })
        }
}

func TestClient_StartTLS_Configuration_extended(t *testing.T) <span class="cov0" title="0">{
        tests := []struct {
                name        string
                setupClient func() *client
                expectError bool
                errorMsg    string
        }{
                {
                        name: "nil connection",
                        setupClient: func() *client </span><span class="cov0" title="0">{
                                return &amp;client{
                                        conn: nil,
                                }
                        }</span>,
                        expectError: true,
                        errorMsg:    "TLS handshake",
                },
                {
                        name: "valid TLS config",
                        setupClient: func() *client <span class="cov0" title="0">{
                                return &amp;client{
                                        conn: &amp;mockConn{},
                                }
                        }</span>,
                        expectError: true, // Will fail handshake but config should be valid
                        errorMsg:    "TLS handshake",
                },
        }

        <span class="cov0" title="0">for _, tt := range tests </span><span class="cov0" title="0">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov0" title="0">{
                        client := tt.setupClient()

                        err := client.StartTLS()

                        if tt.expectError </span><span class="cov0" title="0">{
                                assert.Error(t, err)
                                if tt.errorMsg != "" </span><span class="cov0" title="0">{
                                        assert.Contains(t, err.Error(), tt.errorMsg)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                assert.NoError(t, err)
                        }</span>
                })
        }
}

// Mock connection for testing
type mockConn struct {
        net.Conn
}

func (m *mockConn) Read(b []byte) (n int, err error) <span class="cov0" title="0">{
        return 0, nil
}</span>

func (m *mockConn) Write(b []byte) (n int, err error) <span class="cov0" title="0">{
        return len(b), nil
}</span>

func (m *mockConn) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func (m *mockConn) LocalAddr() net.Addr <span class="cov0" title="0">{
        return &amp;mockAddr{"localhost:8080"}
}</span>

func (m *mockConn) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return &amp;mockAddr{"server:3389"}
}</span>

func (m *mockConn) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *mockConn) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *mockConn) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return nil
}</span>

// Mock address for testing
type mockAddr struct {
        address string
}

func (m *mockAddr) Network() string <span class="cov0" title="0">{
        return "tcp"
}</span>

func (m *mockAddr) String() string <span class="cov0" title="0">{
        return m.address
}</span>

func TestClientConstants(t *testing.T) <span class="cov0" title="0">{
        // Test that constants have expected values
        assert.Equal(t, 5*time.Second, tcpConnectionTimeout)
        assert.Equal(t, 64*1024, readBufferSize)
}</span>

func TestClientStruct(t *testing.T) <span class="cov0" title="0">{
        // Test client struct initialization
        client := &amp;client{
                username:         "testuser",
                password:         "testpass",
                desktopWidth:     1024,
                desktopHeight:    768,
                selectedProtocol: pdu.NegotiationProtocolSSL,
        }

        assert.Equal(t, "testuser", client.username)
        assert.Equal(t, "testpass", client.password)
        assert.Equal(t, uint16(1024), client.desktopWidth)
        assert.Equal(t, uint16(768), client.desktopHeight)
        assert.Equal(t, pdu.NegotiationProtocolSSL, client.selectedProtocol)
}</span>

func TestClient_ChannelIDMap(t *testing.T) <span class="cov0" title="0">{
        client := &amp;client{
                channelIDMap: make(map[string]uint16),
                channels:     []string{"cliprdr", "rdpdr"},
        }

        // Simulate channel initialization
        serverNetworkData := &amp;pdu.ServerNetworkData{
                ChannelIdArray: []uint16{1001, 1002},
                MCSChannelId:   1003,
        }

        client.initChannels(serverNetworkData)

        // Check that channels are mapped correctly
        assert.Equal(t, uint16(1001), client.channelIDMap["cliprdr"])
        assert.Equal(t, uint16(1002), client.channelIDMap["rdpdr"])
        assert.Equal(t, uint16(1003), client.channelIDMap["global"])
}</span>

func TestClient_SkipChannelJoin(t *testing.T) <span class="cov0" title="0">{
        tests := []struct {
                name                 string
                earlyCapabilityFlags uint32
                expectedSkip         bool
        }{
                {
                        name:                 "skip channel join supported",
                        earlyCapabilityFlags: 0x00000008, // RNS_UD_SC_SKIP_CHANNELJOIN_SUPPORTED
                        expectedSkip:         true,
                },
                {
                        name:                 "skip channel join not supported",
                        earlyCapabilityFlags: 0x00000000,
                        expectedSkip:         false,
                },
        }

        for _, tt := range tests </span><span class="cov0" title="0">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov0" title="0">{
                        client := &amp;client{}
                        client.skipChannelJoin = tt.earlyCapabilityFlags&amp;0x8 == 0x8

                        client.skipChannelJoin = tt.earlyCapabilityFlags&amp;0x8 == 0x8

                        assert.Equal(t, tt.expectedSkip, client.skipChannelJoin)
                }</span>)
        }
}

// Integration-style tests for client lifecycle
func TestClient_ConnectionFlow(t *testing.T) <span class="cov0" title="0">{
        // Test client initialization phases
        client := &amp;client{
                username:         "testuser",
                password:         "testpass",
                domain:           "TESTDOMAIN",
                desktopWidth:     1024,
                desktopHeight:    768,
                selectedProtocol: pdu.NegotiationProtocolSSL,
                channelIDMap:     make(map[string]uint16),
                railState:        0,
        }

        // Test initial state
        assert.Empty(t, client.channelIDMap)
        assert.Equal(t, "testuser", client.username)
        assert.Equal(t, "testpass", client.password)
        assert.Equal(t, "TESTDOMAIN", client.domain)
        assert.Equal(t, uint16(1024), client.desktopWidth)
        assert.Equal(t, uint16(768), client.desktopHeight)
        assert.Equal(t, pdu.NegotiationProtocolSSL, client.selectedProtocol)
        assert.Equal(t, uint16(0), client.userID)
        assert.Equal(t, uint32(0), client.shareID)
}</span>

// Test error scenarios
func TestClient_ErrorHandling(t *testing.T) <span class="cov0" title="0">{
        tests := []struct {
                name        string
                hostname    string
                username    string
                password    string
                width       int
                height      int
                expectError bool
                errorType   string
        }{
                {
                        name:        "valid parameters but unreachable host",
                        hostname:    "192.0.2.1:3389",
                        username:    "testuser",
                        password:    "testpass",
                        width:       1024,
                        height:      768,
                        expectError: true,
                        errorType:   "tcp connect",
                },
                {
                        name:        "invalid hostname format",
                        hostname:    "invalid-host",
                        username:    "testuser",
                        password:    "testpass",
                        width:       1024,
                        height:      768,
                        expectError: true,
                        errorType:   "tcp connect",
                },
                {
                        name:        "valid IPv6 host",
                        hostname:    "[::1]:3389",
                        username:    "testuser",
                        password:    "testpass",
                        width:       1024,
                        height:      768,
                        expectError: true, // Will be unreachable
                        errorType:   "tcp connect",
                },
        }

        for _, tt := range tests </span><span class="cov0" title="0">{
                t.Run(tt.name, func(t *testing.T) </span><span class="cov0" title="0">{
                        client, err := NewClient(tt.hostname, tt.username, tt.password, tt.width, tt.height)

                        if tt.expectError </span><span class="cov0" title="0">{
                                require.Error(t, err)
                                assert.Contains(t, err.Error(), tt.errorType)
                                assert.Nil(t, client)
                        }</span> else<span class="cov0" title="0"> {
                                require.NoError(t, err)
                                require.NotNil(t, client)
                                assert.Equal(t, tt.username, client.username)
                                assert.Equal(t, tt.password, client.password)
                                assert.Equal(t, uint16(tt.width), client.desktopWidth)
                                assert.Equal(t, uint16(tt.height), client.desktopHeight)
                        }</span>
                })
        }
}

func TestClient_RemoteApp(t *testing.T) <span class="cov0" title="0">{
        app := &amp;RemoteApp{
                App:        "notepad.exe",
                WorkingDir: "C:\\Users\\TestUser",
                Args:       "",
        }

        client := &amp;client{
                remoteApp: app,
        }

        assert.Equal(t, app, client.remoteApp)
}</span>

func TestClient_Channels(t *testing.T) <span class="cov0" title="0">{
        channels := []string{"cliprdr", "rdpdr", "rdpsnd"}
        client := &amp;client{
                channels:     channels,
                channelIDMap: make(map[string]uint16),
        }

        assert.Equal(t, channels, client.channels)
        assert.Empty(t, client.channelIDMap)

        // Test channel mapping
        serverNetworkData := &amp;pdu.ServerNetworkData{
                ChannelIdArray: []uint16{1001, 1002, 1003},
                MCSChannelId:   1004,
        }

        client.initChannels(serverNetworkData)

        assert.Equal(t, uint16(1001), client.channelIDMap["cliprdr"])
        assert.Equal(t, uint16(1002), client.channelIDMap["rdpdr"])
        assert.Equal(t, uint16(1003), client.channelIDMap["rdpsnd"])
        assert.Equal(t, uint16(1004), client.channelIDMap["global"])
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package rdp

func (c *client) Close() error <span class="cov0" title="0">{
        if c.remoteApp != nil </span><span class="cov0" title="0">{
                c.railState = RailStateUninitialized
        }</span>

        <span class="cov0" title="0">return c.conn.Close()</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package rdp

import (
        "fmt"
        "io"
        "log"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu"
)

func (c *client) Connect() error <span class="cov0" title="0">{
        var err error

        if err = c.connectionInitiation(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connection initiation: %w", err)
        }</span>

        <span class="cov0" title="0">if err = c.basicSettingsExchange(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("basic settings exchange: %w", err)
        }</span>

        <span class="cov0" title="0">if err = c.channelConnection(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("channel connection: %w", err)
        }</span>

        <span class="cov0" title="0">if err = c.secureSettingsExchange(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("secure settings exchange: %w", err)
        }</span>

        <span class="cov0" title="0">if err = c.licensing(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("licensing: %w", err)
        }</span>

        <span class="cov0" title="0">if err = c.capabilitiesExchange(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("capabilities exchange: %w", err)
        }</span>

        <span class="cov0" title="0">if err = c.connectionFinalization(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connection finalizatioin: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *client) connectionInitiation() error <span class="cov0" title="0">{
        var err error

        protocolName := "SSL"
        if c.selectedProtocol.IsHybrid() </span><span class="cov0" title="0">{
                protocolName = "Hybrid (NLA)"
        }</span>
        <span class="cov0" title="0">log.Printf("RDP: Requesting protocol: %s (0x%08X)", protocolName, uint32(c.selectedProtocol))

        req := pdu.ClientConnectionRequest{
                NegotiationRequest: pdu.NegotiationRequest{
                        RequestedProtocols: c.selectedProtocol,
                },
        }

        var (
                resp pdu.ServerConnectionConfirm
                wire io.Reader
        )

        if wire, err = c.x224Layer.Connect(req.Serialize()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = resp.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if resp.Type.IsFailure() </span><span class="cov0" title="0">{
                failureCode := resp.FailureCode()
                log.Printf("RDP: Negotiation failed with code: %s (0x%08X)", failureCode.String(), uint32(failureCode))

                // Provide helpful error messages
                switch failureCode </span>{
                case pdu.NegotiationFailureCodeHybridRequired:<span class="cov0" title="0">
                        return fmt.Errorf("server requires Network Level Authentication (NLA/CredSSP). This client only supports TLS. Disable NLA on the server: System Properties &gt; Remote &gt; uncheck 'Allow connections only from computers running Remote Desktop with Network Level Authentication'")</span>
                case pdu.NegotiationFailureCodeSSLRequired:<span class="cov0" title="0">
                        return fmt.Errorf("server requires SSL/TLS but negotiation failed")</span>
                case pdu.NegotiationFailureCodeSSLWithUserAuthRequired:<span class="cov0" title="0">
                        return fmt.Errorf("server requires SSL with user authentication")</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("negotiation failure: %s (code=%d)", failureCode.String(), uint32(failureCode))</span>
                }
        }

        <span class="cov0" title="0">c.serverNegotiationFlags = resp.Flags

        selectedProto := resp.SelectedProtocol()

        // Handle SSL protocol
        if selectedProto.IsSSL() </span><span class="cov0" title="0">{
                log.Println("RDP: Server selected SSL protocol")
                return c.StartTLS()
        }</span>

        // Handle Hybrid (NLA) protocol
        <span class="cov0" title="0">if selectedProto.IsHybrid() </span><span class="cov0" title="0">{
                log.Println("RDP: Server selected Hybrid (NLA) protocol")
                return c.StartNLA()
        }</span>

        <span class="cov0" title="0">log.Printf("RDP: Server selected unsupported protocol: 0x%08X", uint32(selectedProto))
        return ErrUnsupportedRequestedProtocol</span>
}

func (c *client) basicSettingsExchange() error <span class="cov0" title="0">{
        clientUserDataSet := pdu.NewClientUserDataSet(uint32(c.selectedProtocol), c.desktopWidth, c.desktopHeight, c.channels)

        wire, err := c.mcsLayer.Connect(clientUserDataSet.Serialize())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var serverUserData pdu.ServerUserData
        err = serverUserData.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.initChannels(serverUserData.ServerNetworkData)

        log.Println("MCS: Server Connect Response: earlyCapabilityFlags: ", serverUserData.ServerCoreData.EarlyCapabilityFlags)

        // RNS_UD_SC_SKIP_CHANNELJOIN_SUPPORTED = 0x00000008
        c.skipChannelJoin = serverUserData.ServerCoreData.EarlyCapabilityFlags&amp;0x8 == 0x8

        return nil</span>
}

func (c *client) initChannels(serverNetworkData *pdu.ServerNetworkData) <span class="cov0" title="0">{
        if c.channels == nil </span><span class="cov0" title="0">{
                c.channelIDMap = make(map[string]uint16, len(c.channels))
        }</span>

        <span class="cov0" title="0">for i, channelName := range c.channels </span><span class="cov0" title="0">{
                c.channelIDMap[channelName] = serverNetworkData.ChannelIdArray[i]
        }</span>

        <span class="cov0" title="0">c.channelIDMap["global"] = serverNetworkData.MCSChannelId</span>
}

func (c *client) channelConnection() error <span class="cov0" title="0">{
        err := c.mcsLayer.ErectDomain()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.userID, err = c.mcsLayer.AttachUser()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.channelIDMap["user"] = c.userID

        if c.skipChannelJoin </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">err = c.mcsLayer.JoinChannels(c.userID, c.channelIDMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *client) secureSettingsExchange() error <span class="cov0" title="0">{
        clientInfoPDU := pdu.NewClientInfo(c.domain, c.username, c.password)

        if c.remoteApp != nil </span><span class="cov0" title="0">{
                clientInfoPDU.InfoPacket.Flags |= pdu.InfoFlagRail
        }</span>

        <span class="cov0" title="0">log.Println("RDP: Client Info")

        if err := c.mcsLayer.Send(c.userID, c.channelIDMap["global"], clientInfoPDU.Serialize()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("client info: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *client) licensing() error <span class="cov0" title="0">{
        log.Println("RDP: Server License")

        _, wire, err := c.mcsLayer.Receive()
        if err != nil </span><span class="cov0" title="0">{
                // Check for disconnect ultimatum which often means NLA is required
                if err.Error() == "disconnect ultimatum" </span><span class="cov0" title="0">{
                        return fmt.Errorf("server disconnected during licensing - this typically means Network Level Authentication (NLA) is required. Disable NLA on the server or use a client that supports CredSSP")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">var resp pdu.ServerLicenseError
        if err = resp.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server license error: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("RDP: License message type: 0x%02X, error code: 0x%08X", resp.Preamble.MsgType, resp.ValidClientMessage.ErrorCode)

        if resp.Preamble.MsgType == 0x03 </span><span class="cov0" title="0">{ // NEW_LICENSE
                log.Println("RDP: License granted (NEW_LICENSE)")
                return nil
        }</span>

        <span class="cov0" title="0">if resp.Preamble.MsgType != 0xFF </span><span class="cov0" title="0">{ // ERROR_ALERT
                return fmt.Errorf("unknown license msg type: 0x%02X", resp.Preamble.MsgType)
        }</span>

        <span class="cov0" title="0">if resp.ValidClientMessage.ErrorCode != 0x00000007 </span><span class="cov0" title="0">{ // STATUS_VALID_CLIENT
                return fmt.Errorf("license error code: 0x%08X (expected STATUS_VALID_CLIENT 0x00000007)", resp.ValidClientMessage.ErrorCode)
        }</span>

        <span class="cov0" title="0">if resp.ValidClientMessage.StateTransition != 0x00000002 </span><span class="cov0" title="0">{ // ST_NO_TRANSITION
                return fmt.Errorf("license state transition: 0x%08X (expected ST_NO_TRANSITION 0x00000002)", resp.ValidClientMessage.StateTransition)
        }</span>

        <span class="cov0" title="0">log.Println("RDP: License accepted (STATUS_VALID_CLIENT)")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package rdp

import (
        "fmt"
        "io"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu"
)

func (c *client) connectionFinalization() error <span class="cov0" title="0">{
        var err error

        synchronize := pdu.NewSynchronize(c.shareID, c.userID)
        if err = c.mcsLayer.Send(c.userID, c.channelIDMap["global"], synchronize.Serialize()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">controlCooperate := pdu.NewControl(c.shareID, c.userID, pdu.ControlActionCooperate)
        if err = c.mcsLayer.Send(c.userID, c.channelIDMap["global"], controlCooperate.Serialize()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">controlRequestControl := pdu.NewControl(c.shareID, c.userID, pdu.ControlActionRequestControl)
        if err = c.mcsLayer.Send(c.userID, c.channelIDMap["global"], controlRequestControl.Serialize()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fontList := pdu.NewFontList(c.shareID, c.userID)

        err = c.mcsLayer.Send(c.userID, c.channelIDMap["global"], fontList.Serialize())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var (
                serverSynchronizeReceived bool
                controlCooperateReceived  bool
                grantedControlReceived    bool
                fontMapReceived           bool

                dataPDU *pdu.Data
                wire    io.Reader
        )

        for </span><span class="cov0" title="0">{
                if serverSynchronizeReceived &amp;&amp; controlCooperateReceived &amp;&amp; grantedControlReceived &amp;&amp; fontMapReceived </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">_, wire, err = c.mcsLayer.Receive()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">dataPDU = &amp;pdu.Data{}
                if err = dataPDU.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">pduType2 := dataPDU.ShareDataHeader.PDUType2

                switch </span>{
                case pduType2.IsSynchronize():<span class="cov0" title="0">
                        serverSynchronizeReceived = true</span>
                case pduType2.IsControl():<span class="cov0" title="0">
                        if dataPDU.ControlPDUData.Action == pdu.ControlActionCooperate </span><span class="cov0" title="0">{
                                controlCooperateReceived = true
                        }</span>

                        <span class="cov0" title="0">if dataPDU.ControlPDUData.Action == pdu.ControlActionGrantedControl </span><span class="cov0" title="0">{
                                grantedControlReceived = true
                        }</span>
                case pduType2.IsFontmap():<span class="cov0" title="0">
                        fontMapReceived = true</span>
                case pduType2.IsErrorInfo():<span class="cov0" title="0">
                        return fmt.Errorf("server error info: %d", dataPDU.ErrorInfoPDUData.ErrorInfo)</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unknown server message with pduType2 = %d", pduType2)</span>
                }
        }

        <span class="cov0" title="0">if c.remoteApp != nil </span><span class="cov0" title="0">{
                c.railState = RailStateInitializing
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package fastpath

import (
        "io"
)

type Protocol struct {
        conn io.ReadWriter

        updatePDUData []byte
}

func New(conn io.ReadWriter) *Protocol <span class="cov0" title="0">{
        return &amp;Protocol{
                conn: conn,

                updatePDUData: make([]byte, 64*1024),
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package fastpath

import (
        "encoding/binary"
        "errors"
        "io"
)

type UpdateCode uint8

const (
        UpdateCodeOrders       UpdateCode = 0x0
        UpdateCodeBitmap       UpdateCode = 0x1
        UpdateCodePalette      UpdateCode = 0x2
        UpdateCodeSynchronize  UpdateCode = 0x3
        UpdateCodeSurfCMDs     UpdateCode = 0x4
        UpdateCodePTRNull      UpdateCode = 0x5
        UpdateCodePTRDefault   UpdateCode = 0x6
        UpdateCodePTRPosition  UpdateCode = 0x8
        UpdateCodeColor        UpdateCode = 0x9
        UpdateCodeCached       UpdateCode = 0xa
        UpdateCodePointer      UpdateCode = 0xb
        UpdateCodeLargePointer UpdateCode = 0xc
)

type Fragment uint8

const (
        FragmentSingle Fragment = 0x0
        FragmentLast   Fragment = 0x1
        FragmentFirst  Fragment = 0x2
        FragmentNext   Fragment = 0x3
)

type Compression uint8

const (
        CompressionUsed Compression = 0x2
)

type Update struct {
        UpdateCode       UpdateCode
        fragmentation    Fragment
        compression      Compression
        compressionFlags uint8
        size             uint16

        paletteUpdateData         *paletteUpdateData
        bitmapUpdateData          *bitmapUpdateData
        pointerPositionUpdateData *pointerPositionUpdateData
        colorPointerUpdateData    *colorPointerUpdateData
}

func (u *Update) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        var updateHeader uint8
        err = binary.Read(wire, binary.LittleEndian, &amp;updateHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">u.UpdateCode = UpdateCode(updateHeader &amp; 0xf)
        u.fragmentation = Fragment((updateHeader &gt;&gt; 4) &amp; 0x3)
        u.compression = Compression((updateHeader &gt;&gt; 6) &amp; 0x3)

        if u.compression&amp;CompressionUsed == CompressionUsed </span><span class="cov0" title="0">{
                err = binary.Read(wire, binary.LittleEndian, &amp;u.compressionFlags)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;u.size)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //switch u.UpdateCode {
        //case UpdateCodePalette:
        //        u.paletteUpdateData = &amp;paletteUpdateData{}
        //
        //        return u.paletteUpdateData.Deserialize(wire)
        //case UpdateCodeBitmap:
        //        u.bitmapUpdateData = &amp;bitmapUpdateData{}
        //
        //        return u.bitmapUpdateData.Deserialize(wire)
        //case UpdateCodeSynchronize: // do nothing
        //case UpdateCodePTRPosition:
        //        u.pointerPositionUpdateData = &amp;pointerPositionUpdateData{}
        //
        //        return u.pointerPositionUpdateData.Deserialize(wire)
        //case UpdateCodePTRNull: // do nothing
        //case UpdateCodePTRDefault: // do nothing
        //case UpdateCodeCached:
        //        u.colorPointerUpdateData = &amp;colorPointerUpdateData{}
        //
        //        return u.colorPointerUpdateData.Deserialize(wire)
        //}

        <span class="cov0" title="0">d := make([]byte, u.size)
        _, err = wire.Read(d)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type UpdatePDUAction uint8

const (
        UpdatePDUActionFastPath UpdatePDUAction = 0x0
        UpdatePDUActionX224     UpdatePDUAction = 0x3
)

type UpdatePDUFlag uint8

const (
        UpdatePDUFlagSecureChecksum UpdatePDUFlag = 0x1
        UpdatePDUFlagEncrypted      UpdatePDUFlag = 0x2
)

type UpdatePDU struct {
        fpOutputHeader uint8
        Action         UpdatePDUAction
        Flags          UpdatePDUFlag
        Data           []byte
}

var ErrUnexpectedX224 = errors.New("unexpected x224")

func (pdu *UpdatePDU) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        err := binary.Read(wire, binary.LittleEndian, &amp;pdu.fpOutputHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pdu.Action = UpdatePDUAction(pdu.fpOutputHeader &amp; 0x3)
        pdu.Flags = UpdatePDUFlag((pdu.fpOutputHeader &gt;&gt; 6) &amp; 0x3)

        if pdu.Action == UpdatePDUActionX224 </span><span class="cov0" title="0">{
                return ErrUnexpectedX224
        }</span>

        <span class="cov0" title="0">if pdu.Flags&amp;UpdatePDUFlagSecureChecksum == UpdatePDUFlagSecureChecksum </span><span class="cov0" title="0">{
                return errors.New("checksum not supported")
        }</span>

        <span class="cov0" title="0">if pdu.Flags&amp;UpdatePDUFlagEncrypted == UpdatePDUFlagEncrypted </span><span class="cov0" title="0">{
                return errors.New("encryption not supported")
        }</span>

        <span class="cov0" title="0">var (
                length           uint16
                length1, length2 uint8
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;length1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">length = uint16(length1)

        if length1&amp;0x80 == 0x80 </span><span class="cov0" title="0">{
                err = binary.Read(wire, binary.LittleEndian, &amp;length2)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">length1 -= 0x80

                length = binary.BigEndian.Uint16([]byte{length1, length2})</span>
        }

        <span class="cov0" title="0">if length &gt; 0x4000 </span><span class="cov0" title="0">{
                return errors.New("too big packet")
        }</span>

        <span class="cov0" title="0">if len(pdu.Data) != 0 </span><span class="cov0" title="0">{
                pdu.Data = pdu.Data[:length]
        }</span> else<span class="cov0" title="0"> {
                pdu.Data = make([]byte, length)
        }</span>

        <span class="cov0" title="0">_, err = wire.Read(pdu.Data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (i *Protocol) Receive() (*UpdatePDU, error) <span class="cov0" title="0">{
        var pdu UpdatePDU
        pdu.Data = i.updatePDUData
        if err := pdu.Deserialize(i.conn); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;pdu, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package fastpath

import (
        "bytes"
        "encoding/binary"
        "io"
)

type InputEventPDU struct {
        action    uint8
        numEvents uint8
        flags     uint8
        eventData []byte
}

func NewInputEventPDU(eventData []byte) *InputEventPDU <span class="cov8" title="1">{
        return &amp;InputEventPDU{
                numEvents: 1,
                eventData: eventData,
        }
}</span>

func (pdu *InputEventPDU) Serialize() []byte <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        fpInputHeader := pdu.action&amp;0x3 | ((pdu.numEvents &amp; 0xf) &lt;&lt; 2) | ((pdu.flags &amp; 0x3) &lt;&lt; 6)
        length := 1 + len(pdu.eventData) // without length bytes

        binary.Write(buf, binary.LittleEndian, fpInputHeader)
        pdu.SerializeLength(length, buf)
        buf.Write(pdu.eventData)

        return buf.Bytes()
}</span>

func (pdu *InputEventPDU) SerializeLength(value int, w io.Writer) error <span class="cov8" title="1">{
        if value &gt; 0x7f </span><span class="cov0" title="0">{
                value += 2 // 2 bytes length

                return binary.Write(w, binary.BigEndian, value|0x8000)
        }</span>

        <span class="cov8" title="1">value += 1 // 1 byte length
        if _, err := w.Write([]byte{uint8(value)}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (i *Protocol) Send(pdu *InputEventPDU) error <span class="cov0" title="0">{
        data := pdu.Serialize()

        _, err := i.conn.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package fastpath

import (
        "encoding/binary"
        "io"
)

type PaletteEntry struct {
        Red   uint8
        Green uint8
        Blue  uint8
}

func (e *PaletteEntry) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;e.Red)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;e.Green)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;e.Green)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type paletteUpdateData struct {
        PaletteEntries []PaletteEntry
}

func (d *paletteUpdateData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        var updateType uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;updateType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var numberColors uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;numberColors)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d.PaletteEntries = make([]PaletteEntry, numberColors)

        for i := 0; i &lt; len(d.PaletteEntries); i++ </span><span class="cov0" title="0">{
                err = d.PaletteEntries[i].Deserialize(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type CompressedDataHeader struct {
        CbCompMainBodySize uint16
        CbScanWidth        uint16
        CbUncompressedSize uint16
}

func (h *CompressedDataHeader) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        var cbCompFirstRowSize uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;cbCompFirstRowSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;h.CbCompMainBodySize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;h.CbScanWidth)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;h.CbUncompressedSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type BitmapDataFlag uint16

const (
        // BitmapDataFlagCompression BITMAP_COMPRESSION
        BitmapDataFlagCompression BitmapDataFlag = 0x0001

        // BitmapDataFlagNoHDR NO_BITMAP_COMPRESSION_HDR
        BitmapDataFlagNoHDR BitmapDataFlag = 0x0400
)

type BitmapData struct {
        DestLeft         uint16
        DestTop          uint16
        DestRight        uint16
        DestBottom       uint16
        Width            uint16
        Height           uint16
        BitsPerPixel     uint16
        Flags            BitmapDataFlag
        BitmapLength     uint16
        BitmapComprHdr   *CompressedDataHeader
        BitmapDataStream []byte
}

func (d *BitmapData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;d.DestLeft)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.DestTop)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.DestRight)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.DestBottom)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.Width)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.Height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.BitsPerPixel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.Flags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.BitmapLength)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if d.Flags&amp;BitmapDataFlagNoHDR != BitmapDataFlagNoHDR &amp;&amp; d.Flags&amp;BitmapDataFlagCompression == BitmapDataFlagCompression </span><span class="cov0" title="0">{
                err = d.BitmapComprHdr.Deserialize(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">d.BitmapLength -= 8</span>
        }

        <span class="cov0" title="0">d.BitmapDataStream = make([]byte, d.BitmapLength)

        _, err = wire.Read(d.BitmapDataStream)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type bitmapUpdateData struct {
        Rectangles []BitmapData
}

func (d *bitmapUpdateData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        var updateType uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;updateType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var numberRectangles uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;numberRectangles)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d.Rectangles = make([]BitmapData, numberRectangles)

        for i := range d.Rectangles </span><span class="cov0" title="0">{
                err = d.Rectangles[i].Deserialize(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type pointerPositionUpdateData struct {
        xPos uint16
        yPos uint16
}

func (d *pointerPositionUpdateData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;d.xPos)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.yPos)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type colorPointerUpdateData struct {
        cacheIndex    uint16
        xPos          uint16
        yPos          uint16
        width         uint16
        height        uint16
        lengthAndMask uint16
        lengthXorMask uint16
        xorMaskData   []byte
        andMaskData   []byte
}

func (d *colorPointerUpdateData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;d.cacheIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.xPos)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.yPos)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.width)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.lengthAndMask)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.lengthXorMask)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if d.lengthXorMask &gt; 0 </span><span class="cov0" title="0">{
                d.xorMaskData = make([]byte, d.lengthXorMask)
                _, err = wire.Read(d.xorMaskData)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if d.lengthAndMask &gt; 0 </span><span class="cov0" title="0">{
                d.andMaskData = make([]byte, d.lengthAndMask)
                _, err = wire.Read(d.andMaskData)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">var padding uint8

        return binary.Read(wire, binary.LittleEndian, &amp;padding)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package gcc

import (
        "bytes"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/per"
)

type ConferenceCreateRequest struct {
        UserData []byte
}

func NewConferenceCreateRequest(userData []byte) *ConferenceCreateRequest <span class="cov0" title="0">{
        return &amp;ConferenceCreateRequest{
                UserData: userData,
        }
}</span>

func (r *ConferenceCreateRequest) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        per.WriteChoice(0, buf)
        per.WriteObjectIdentifier(t124_02_98_oid, buf)
        per.WriteLength(uint16(14+len(r.UserData)), buf)

        per.WriteChoice(0, buf)
        per.WriteSelection(0x08, buf)

        per.WriteNumericString("1", 1, buf)
        per.WritePadding(1, buf)
        per.WriteNumberOfSet(1, buf)
        per.WriteChoice(0xc0, buf)
        per.WriteOctetStream(h221CSKey, 4, buf)
        per.WriteOctetStream(string(r.UserData), 0, buf)

        return buf.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package gcc

import (
        "errors"
        "io"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/per"
)

type ConferenceCreateResponse struct{}

func (r *ConferenceCreateResponse) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        _, err := per.ReadChoice(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var objectIdentifier bool

        objectIdentifier, err = per.ReadObjectIdentifier(t124_02_98_oid, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !objectIdentifier </span><span class="cov0" title="0">{
                return errors.New("bad object identifier t124")
        }</span>

        <span class="cov0" title="0">_, err = per.ReadLength(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = per.ReadChoice(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = per.ReadInteger16(1001, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = per.ReadInteger(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = per.ReadEnumerates(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = per.ReadNumberOfSet(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = per.ReadChoice(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var octetStream bool

        octetStream, err = per.ReadOctetStream([]byte(h221SCKey), 4, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !octetStream </span><span class="cov0" title="0">{
                return errors.New("bad H221 SC_KEY")
        }</span>

        <span class="cov0" title="0">_, err = per.ReadLength(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package rdp

import (
        "errors"
        "fmt"
        "log"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/fastpath"
        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/pdu"
)

func (c *client) GetUpdate() (*fastpath.UpdatePDU, error) <span class="cov0" title="0">{
        protocol, err := receiveProtocol(c.buffReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if protocol.IsX224() </span><span class="cov0" title="0">{
                err = c.getX224Update()
                switch </span>{
                case err == nil:<span class="cov0" title="0"></span> // pass
                case errors.Is(err, pdu.ErrDeactiateAll):<span class="cov0" title="0">
                        return nil, err</span>

                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("get X.224 update: %w", err)</span>
                }

                <span class="cov0" title="0">return c.GetUpdate()</span>
        }

        <span class="cov0" title="0">return c.fastPath.Receive()</span>
}

func (c *client) getX224Update() error <span class="cov0" title="0">{
        channelID, wire, err := c.mcsLayer.Receive()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if channelID == c.channelIDMap["rail"] </span><span class="cov0" title="0">{
                err = c.handleRail(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">var data pdu.Data
        if err = data.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if data.ShareDataHeader.PDUType2.IsErrorInfo() </span><span class="cov0" title="0">{
                log.Printf("received error info: %s\n", data.ErrorInfoPDUData.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package headers

import (
        "bytes"
        "encoding/binary"
        "errors"
        "io"
)

func WrapMCSDomainPDU(tag uint8, data []byte) []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        buf.WriteByte(tag &lt;&lt; 2) // per-encoded DomainMCSPDU choice
        buf.Write(data)

        return buf.Bytes()
}</span>

func UnwrapMCSDomainPDU(tag uint8, wire io.Reader) error <span class="cov0" title="0">{
        var choiceID uint8

        if err := binary.Read(wire, binary.BigEndian, &amp;choiceID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">choiceID &gt;&gt;= 2

        if choiceID != tag </span><span class="cov0" title="0">{
                return errors.New("unexpected MCS choice")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func WrapMCSSendData(data []byte) []byte <span class="cov0" title="0">{
        return WrapMCSDomainPDU(25, data)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package headers

import (
        "bytes"
        "encoding/binary"
        "io"
)

func WrapSecurityFlag(flag uint16, data []byte) []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, flag)
        buf.Write([]byte{0x00, 0x00}) // flagsHi

        buf.Write(data)

        return buf.Bytes()
}</span>

func UnwrapSecurityFlag(wire io.Reader) (uint16, error) <span class="cov0" title="0">{
        var (
                flags   uint16
                flagsHi uint16
                err     error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;flags)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;flagsHi)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return flags, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package headers

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
)

const (
        tpktHeaderLen = 4
)

func WrapTPKT(data []byte) []byte <span class="cov0" title="0">{
        buf := bytes.NewBuffer(make([]byte, 0, tpktHeaderLen+len(data)))
        dataLen := uint16(tpktHeaderLen + len(data))

        buf.Write([]byte{
                3, // TPKT version number
                0, // reserved for further study
        })

        // TPKT length
        _ = binary.Write(buf, binary.BigEndian, dataLen)

        buf.Write(data)

        return buf.Bytes()
}</span>

// UnwrapTPKT unwrap TPKT response header and return data length.
func UnwrapTPKT(wire io.Reader) (int, error) <span class="cov0" title="0">{
        tpktHeaderData := make([]byte, tpktHeaderLen)

        _, err := wire.Read(tpktHeaderData)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("read TPKT header: %w", err)
        }</span>

        <span class="cov0" title="0">dataLen := binary.BigEndian.Uint16(tpktHeaderData[2:4])
        dataLen -= tpktHeaderLen

        return int(dataLen), nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package headers

import (
        "bytes"
        "fmt"
        "io"
)

const (
        x224LI           = 1
        x224FixedPartLen = 6 // without length indicator (LI)
)

func WrapX224ConnectionRequestPDU(data []byte) []byte <span class="cov0" title="0">{
        pduLen := uint8(x224FixedPartLen + len(data))

        buf := new(bytes.Buffer)

        buf.Write([]byte{
                pduLen,     // LI
                0xE0,       // CR + CDT: TPDU_CONNECTION_REQUEST
                0x00, 0x00, // DST-REF
                0x00, 0x00, // SRC-REF
                0x00, // CLASS OPTION
        })

        // Variable part
        buf.Write(data)

        return buf.Bytes()
}</span>

func WrapX224DataPDU(data []byte) []byte <span class="cov0" title="0">{
        buf := bytes.NewBuffer(make([]byte, 0, 3+len(data)))

        buf.Write([]byte{
                0x02, // packet size
                0xF0, // message type TPDU_DATA
                0x80, // EOT flag is up, which indicates that current TPDU is the last data unit of a complete TPDU sequence
        })
        buf.Write(data)

        return buf.Bytes()
}</span>

func UnwrapX224ConnectionConfirmPDU(wire io.Reader, dataLen int) ([]byte, error) <span class="cov0" title="0">{
        x224Data := make([]byte, dataLen)

        _, err := wire.Read(x224Data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read X224 data: %w", err)
        }</span>

        <span class="cov0" title="0">x224Data = x224Data[x224LI+x224FixedPartLen:] // offset to rdpNegData

        return x224Data, nil</span>
}

func UnwrapX224DataPDU(wire io.Reader, dataLen int) ([]byte, error) <span class="cov0" title="0">{
        const fixedPartLen = 2

        x224Data := make([]byte, dataLen)

        _, err := wire.Read(x224Data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read X224 data: %w", err)
        }</span>

        <span class="cov0" title="0">x224Data = x224Data[x224LI+fixedPartLen:]

        return x224Data, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package mcs

import (
        "fmt"
        "io"
        "log"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/per"
)

type ClientAttachUserRequest struct{}

func (pdu *ClientAttachUserRequest) Serialize() []byte <span class="cov8" title="1">{
        // empty structure in T.125, section 7, page 18
        return nil
}</span>

type ServerAttachUserConfirm struct {
        Result    uint8
        Initiator uint16
}

func (pdu *ServerAttachUserConfirm) Deserialize(wire io.Reader) error <span class="cov8" title="1">{
        var err error

        pdu.Result, err = per.ReadEnumerates(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pdu.Initiator, err = per.ReadInteger16(1001, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (p *Protocol) AttachUser() (uint16, error) <span class="cov0" title="0">{
        req := DomainPDU{
                Application:             attachUserRequest,
                ClientAttachUserRequest: &amp;ClientAttachUserRequest{},
        }

        log.Println("MCS: Attach User Request")

        if err := p.x224Conn.Send(req.Serialize()); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("client MCS attach user request: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("MCS: Attach User Confirm")

        wire, err := p.x224Conn.Receive()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">var resp DomainPDU
        if err = resp.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("server MCS attach user confirm reponse: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.ServerAttachUserConfirm.Result != RTSuccessful </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("unsuccessful MCS attach user; result=%d", resp.ServerAttachUserConfirm.Result)
        }</span>

        <span class="cov0" title="0">return resp.ServerAttachUserConfirm.Initiator, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package mcs

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "log"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/asn1"
        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/ber"
        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/gcc"
)

type ConnectPDUApplication uint8

const (
        connectInitial ConnectPDUApplication = iota + 101
        connectResponse
        connectAdditional
        connectResult
)

type ConnectPDU struct {
        Application           ConnectPDUApplication
        ClientConnectInitial  *ClientConnectInitial
        ServerConnectResponse *ServerConnectResponse
}

func (pdu *ConnectPDU) Serialize() []byte <span class="cov8" title="1">{
        var data []byte

        switch pdu.Application </span>{
        case connectInitial:<span class="cov8" title="1">
                data = pdu.ClientConnectInitial.Serialize()</span>
        }

        <span class="cov8" title="1">buf := new(bytes.Buffer)

        ber.WriteApplicationTag(uint8(pdu.Application), len(data), buf)
        buf.Write(data)

        return buf.Bytes()</span>
}

func (pdu *ConnectPDU) Deserialize(wire io.Reader) error <span class="cov8" title="1">{
        var (
                application uint8
                err         error
        )

        application, err = ber.ReadApplicationTag(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">pdu.Application = ConnectPDUApplication(application)

        _, err = ber.ReadLength(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">switch pdu.Application </span>{
        case connectResponse:<span class="cov8" title="1">
                pdu.ServerConnectResponse = &amp;ServerConnectResponse{}

                return pdu.ServerConnectResponse.Deserialize(wire)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("%w: application=%v", ErrUnknownConnectApplication, pdu.Application)</span>
}

type ClientConnectInitial struct {
        calledDomainSelector  []byte
        callingDomainSelector []byte
        upwardFlag            bool
        targetParameters      domainParameters
        minimumParameters     domainParameters
        maximumParameters     domainParameters
        userData              *gcc.ConferenceCreateRequest
}

func NewClientMCSConnectInitial(userData []byte) *ClientConnectInitial <span class="cov8" title="1">{
        pdu := ClientConnectInitial{
                calledDomainSelector:  []byte{0x01},
                callingDomainSelector: []byte{0x01},
                upwardFlag:            true,
                targetParameters: domainParameters{
                        maxChannelIds:   34,
                        maxUserIds:      2,
                        maxTokenIds:     0,
                        numPriorities:   1,
                        minThroughput:   0,
                        maxHeight:       1,
                        maxMCSPDUsize:   65535,
                        protocolVersion: 2,
                },
                minimumParameters: domainParameters{
                        maxChannelIds:   1,
                        maxUserIds:      1,
                        maxTokenIds:     1,
                        numPriorities:   1,
                        minThroughput:   0,
                        maxHeight:       1,
                        maxMCSPDUsize:   1056,
                        protocolVersion: 2,
                },
                maximumParameters: domainParameters{
                        maxChannelIds:   65535,
                        maxUserIds:      65535,
                        maxTokenIds:     65535,
                        numPriorities:   1,
                        minThroughput:   0,
                        maxHeight:       1,
                        maxMCSPDUsize:   65535,
                        protocolVersion: 2,
                },
                userData: gcc.NewConferenceCreateRequest(userData),
        }

        return &amp;pdu
}</span>

func (pdu *ClientConnectInitial) Serialize() []byte <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        ber.WriteOctetString(pdu.calledDomainSelector, buf)
        ber.WriteOctetString(pdu.callingDomainSelector, buf)
        ber.WriteBoolean(pdu.upwardFlag, buf)
        ber.WriteSequence(pdu.targetParameters.Serialize(), buf)
        ber.WriteSequence(pdu.minimumParameters.Serialize(), buf)
        ber.WriteSequence(pdu.maximumParameters.Serialize(), buf)
        ber.WriteOctetString(pdu.userData.Serialize(), buf)

        return buf.Bytes()
}</span>

type ServerConnectResponse struct {
        Result           uint8
        calledConnectId  int
        DomainParameters domainParameters
        UserData         gcc.ConferenceCreateResponse
}

func (pdu *ServerConnectResponse) Deserialize(wire io.Reader) error <span class="cov8" title="1">{
        var err error

        pdu.Result, err = ber.ReadEnumerated(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pdu.calledConnectId, err = ber.ReadInteger(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">universalTag, err := ber.ReadUniversalTag(asn1.TagSequence, true, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !universalTag </span><span class="cov0" title="0">{
                return errors.New("bad BER tags")
        }</span>

        <span class="cov8" title="1">_, err = ber.ReadLength(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = pdu.DomainParameters.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">universalTag, err = ber.ReadUniversalTag(asn1.TagOctetString, false, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !universalTag </span><span class="cov0" title="0">{
                return errors.New("invalid expected BER tag")
        }</span>

        <span class="cov8" title="1">_, err = ber.ReadLength(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return pdu.UserData.Deserialize(wire)</span>
}

func (p *Protocol) Connect(userData []byte) (io.Reader, error) <span class="cov0" title="0">{
        req := ConnectPDU{
                Application:          connectInitial,
                ClientConnectInitial: NewClientMCSConnectInitial(userData),
        }

        log.Println("MCS: Connect Initial")

        if err := p.x224Conn.Send(req.Serialize()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("client MCS connect initial request: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("MCS: Connect Response")

        wire, err := p.x224Conn.Receive()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var resp ConnectPDU
        if err = resp.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("server MCS connect response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.ServerConnectResponse.Result != RTSuccessful </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsuccessful MCS connect initial; result=%d", resp.ServerConnectResponse.Result)
        }</span>

        <span class="cov0" title="0">return wire, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package mcs

import (
        "fmt"
)

type ClientDisconnectUltimatumRequest struct{}

func (pdu *ClientDisconnectUltimatumRequest) Serialize() []byte <span class="cov8" title="1">{
        // per aligned RNUserRequested
        return []byte{
                0x21,
                0x80,
        }
}</span>

func (p *Protocol) Disconnect() error <span class="cov0" title="0">{
        req := ClientDisconnectUltimatumRequest{}

        if err := p.x224Conn.Send(req.Serialize()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("client MCS disconnect ultimatum: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package mcs

import (
        "bytes"
        "fmt"
        "io"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/per"
)

type DomainPDUApplication uint8

const (
        plumbDomainIndication DomainPDUApplication = iota
        erectDomainRequest
        mergeChannelsRequest
        mergeChannelsConfirm
        purgeChannelsIndication
        mergeTokensRequest
        mergeTokensConfirm
        purgeTokensIndication
        disconnectProviderUltimatum
        rejectMCSPDUUltimatum
        attachUserRequest
        attachUserConfirm
        detachUserRequest
        detachUserIndication
        channelJoinRequest
        channelJoinConfirm
        channelLeaveRequest
        channelConveneRequest
        channelConveneConfirm
        channelDisbandRequest
        channelDisbandIndication
        channelAdmitRequest
        channelAdmitIndication
        channelExpelRequest
        channelExpelIndication
        SendDataRequest
        SendDataIndication
        uniformSendDataRequest
        uniformSendDataIndication
        tokenGrabRequest
        tokenGrabConfirm
        tokenInhibitRequest
        tokenInhibitConfirm
        tokenGiveRequest
        tokenGiveIndication
        tokenGiveResponse
        tokenGiveConfirm
        tokenPleaseRequest
        tokenPleaseIndication
        tokenReleaseRequest
        tokenReleaseConfirm
        tokenTestRequest
        tokenTestConfirm
)

type DomainPDU struct {
        Application DomainPDUApplication

        ClientErectDomainRequest *ClientErectDomainRequest
        ClientAttachUserRequest  *ClientAttachUserRequest
        ClientChannelJoinRequest *ClientChannelJoinRequest
        ClientSendDataRequest    *ClientSendDataRequest

        ServerAttachUserConfirm  *ServerAttachUserConfirm
        ServerChannelJoinConfirm *ServerChannelJoinConfirm
        ServerSendDataIndication *ServerSendDataIndication
}

func (pdu *DomainPDU) Serialize() []byte <span class="cov10" title="5">{
        buf := new(bytes.Buffer)

        per.WriteChoice(uint8(pdu.Application&lt;&lt;2), buf)

        var data []byte

        switch pdu.Application </span>{
        case attachUserRequest:<span class="cov1" title="1">
                data = pdu.ClientAttachUserRequest.Serialize()</span>
        case erectDomainRequest:<span class="cov1" title="1">
                data = pdu.ClientErectDomainRequest.Serialize()</span>
        case channelJoinRequest:<span class="cov7" title="3">
                data = pdu.ClientChannelJoinRequest.Serialize()</span>
        case SendDataRequest:<span class="cov0" title="0">
                data = pdu.ClientSendDataRequest.Serialize()</span>
        }

        <span class="cov10" title="5">buf.Write(data)

        return buf.Bytes()</span>
}

func (pdu *DomainPDU) Deserialize(wire io.Reader) error <span class="cov8" title="4">{
        var (
                application uint8
                err         error
        )

        application, err = per.ReadChoice(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="4">pdu.Application = DomainPDUApplication(application &gt;&gt; 2)

        switch pdu.Application </span>{
        case attachUserConfirm:<span class="cov1" title="1">
                pdu.ServerAttachUserConfirm = &amp;ServerAttachUserConfirm{}

                return pdu.ServerAttachUserConfirm.Deserialize(wire)</span>
        case channelJoinConfirm:<span class="cov7" title="3">
                pdu.ServerChannelJoinConfirm = &amp;ServerChannelJoinConfirm{}

                return pdu.ServerChannelJoinConfirm.Deserialize(wire)</span>
        case SendDataIndication:<span class="cov0" title="0">
                pdu.ServerSendDataIndication = &amp;ServerSendDataIndication{}

                return pdu.ServerSendDataIndication.Deserialize(wire)</span>
        case SendDataRequest:<span class="cov0" title="0">
                pdu.ClientSendDataRequest = &amp;ClientSendDataRequest{}

                return pdu.ClientSendDataRequest.Deserialize(wire)</span>
        case disconnectProviderUltimatum:<span class="cov0" title="0">
                return ErrDisconnectUltimatum</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("%w: application=%v", ErrUnknownDomainApplication, pdu.Application)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package mcs

import (
        "bytes"
        "fmt"
        "log"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/per"
)

type ClientErectDomainRequest struct{}

func (pdu *ClientErectDomainRequest) Serialize() []byte <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        per.WriteInteger(0, buf)
        per.WriteInteger(0, buf)

        return buf.Bytes()
}</span>

func (p *Protocol) ErectDomain() error <span class="cov0" title="0">{
        req := DomainPDU{
                Application:              erectDomainRequest,
                ClientErectDomainRequest: &amp;ClientErectDomainRequest{},
        }

        log.Println("MCS: Erect Domain")

        if err := p.x224Conn.Send(req.Serialize()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("client MCS erect domain request: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package mcs

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "log"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/per"
)

type ClientChannelJoinRequest struct {
        Initiator uint16
        ChannelId uint16
}

func (pdu *ClientChannelJoinRequest) Serialize() []byte <span class="cov10" title="3">{
        buf := new(bytes.Buffer)

        per.WriteInteger16(pdu.Initiator, 1001, buf)
        per.WriteInteger16(pdu.ChannelId, 0, buf)

        return buf.Bytes()
}</span>

type ServerChannelJoinConfirm struct {
        Result    uint8
        Initiator uint16
        Requested uint16
        ChannelId uint16
}

func (pdu *ServerChannelJoinConfirm) Deserialize(wire io.Reader) error <span class="cov10" title="3">{
        var err error

        pdu.Result, err = per.ReadEnumerates(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="3">pdu.Initiator, err = per.ReadInteger16(1001, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="3">pdu.Requested, err = per.ReadInteger16(0, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // optional
        <span class="cov10" title="3">pdu.ChannelId, err = per.ReadInteger16(0, wire)
        switch </span>{
        case errors.Is(err, nil), // pass
                errors.Is(err, io.EOF):<span class="cov10" title="3"></span>
        default:<span class="cov0" title="0">
                return err</span>
        }

        <span class="cov10" title="3">return nil</span>
}

func (p *Protocol) JoinChannels(userID uint16, channelIDMap map[string]uint16) error <span class="cov0" title="0">{
        if len(channelIDMap) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for channelName, channelID := range channelIDMap </span><span class="cov0" title="0">{
                req := DomainPDU{
                        Application: channelJoinRequest,
                        ClientChannelJoinRequest: &amp;ClientChannelJoinRequest{
                                Initiator: userID,
                                ChannelId: channelID,
                        },
                }

                log.Printf("MCS: Channel Join Request: %s\n", channelName)

                if err := p.x224Conn.Send(req.Serialize()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("client MCS channel join request for channel=%s: %w", channelName, err)
                }</span>

                <span class="cov0" title="0">log.Printf("MCS: Channel Join Confirm: %s\n", channelName)

                wire, err := p.x224Conn.Receive()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var resp DomainPDU
                if err = resp.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server MCS channel join confirm reponse: %w", err)
                }</span>

                <span class="cov0" title="0">if resp.ServerChannelJoinConfirm.Result != RTSuccessful </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "unsuccessful MCS channel join confirm for channel=%s; result=%d",
                                channelName,
                                resp.ServerChannelJoinConfirm.Result,
                        )
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package mcs

import "github.com/kulaginds/rdp-html5/internal/pkg/rdp/x224"

type Protocol struct {
        x224Conn *x224.Protocol
}

func New(x224Conn *x224.Protocol) *Protocol <span class="cov0" title="0">{
        return &amp;Protocol{
                x224Conn: x224Conn,
        }
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package mcs

import (
        "io"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/per"
)

type ServerSendDataIndication struct {
        Initiator uint16
        ChannelId uint16
}

func (d *ServerSendDataIndication) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        d.Initiator, err = per.ReadInteger16(1001, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d.ChannelId, err = per.ReadInteger16(0, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = per.ReadEnumerates(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = per.ReadLength(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Receive returns channelName, reader or error
func (p *Protocol) Receive() (uint16, io.Reader, error) <span class="cov0" title="0">{
        wire, err := p.x224Conn.Receive()
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        <span class="cov0" title="0">var resp DomainPDU
        if err = resp.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        <span class="cov0" title="0">if resp.Application != SendDataIndication </span><span class="cov0" title="0">{
                return 0, nil, ErrUnknownDomainApplication
        }</span>

        <span class="cov0" title="0">return resp.ServerSendDataIndication.ChannelId, wire, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package mcs

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/per"
)

type ClientSendDataRequest struct {
        Initiator uint16
        ChannelId uint16
        Data      []byte
}

func (d *ClientSendDataRequest) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        per.WriteInteger16(d.Initiator, 1001, buf)
        per.WriteInteger16(d.ChannelId, 0, buf)
        buf.WriteByte(0x70) // magic word
        per.WriteLength(uint16(len(d.Data)), buf)

        buf.Write(d.Data)

        return buf.Bytes()
}</span>

func (d *ClientSendDataRequest) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        d.Initiator, err = per.ReadInteger16(1001, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d.ChannelId, err = per.ReadInteger16(0, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var magic uint8
        err = binary.Read(wire, binary.LittleEndian, &amp;magic)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = per.ReadLength(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (p *Protocol) Send(userID, channelID uint16, pduData []byte) error <span class="cov0" title="0">{
        req := DomainPDU{
                Application: SendDataRequest,
                ClientSendDataRequest: &amp;ClientSendDataRequest{
                        Initiator: userID,
                        ChannelId: channelID,
                        Data:      pduData,
                },
        }

        if err := p.x224Conn.Send(req.Serialize()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("client MCS send data request: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package mcs

import (
        "bytes"
        "io"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/ber"
)

const (
        RTSuccessful uint8 = iota
        RTDomainMerging
        RTDomainNotHierarchical
        RTNoSuchChannel
        RTNoSuchDomain
        RTNoSuchUser
        RTNotAdmitted
        RTOtherUserId
        RTParametersUnacceptable
        RTTokenNotAvailable
        RTTokenNotPossessed
        RTTooManyChannels
        RTTooManyTokens
        RTTooManyUsers
        RTUnspecifiedFailure
        RTUserRejected
)

const (
        RNDomainDisconnected uint8 = iota
        RNProviderInitiated
        RNTokenPurged
        RNUserRequested
        RNChannelPurged
)

type domainParameters struct {
        maxChannelIds   int
        maxUserIds      int
        maxTokenIds     int
        numPriorities   int
        minThroughput   int
        maxHeight       int
        maxMCSPDUsize   int
        protocolVersion int
}

func (params *domainParameters) Serialize() []byte <span class="cov10" title="3">{
        buf := new(bytes.Buffer)

        ber.WriteInteger(params.maxChannelIds, buf)
        ber.WriteInteger(params.maxUserIds, buf)
        ber.WriteInteger(params.maxTokenIds, buf)
        ber.WriteInteger(params.numPriorities, buf)
        ber.WriteInteger(params.minThroughput, buf)
        ber.WriteInteger(params.maxHeight, buf)
        ber.WriteInteger(params.maxMCSPDUsize, buf)
        ber.WriteInteger(params.protocolVersion, buf)

        return buf.Bytes()
}</span>

func (params *domainParameters) Deserialize(wire io.Reader) error <span class="cov1" title="1">{
        var err error

        params.maxChannelIds, err = ber.ReadInteger(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">params.maxUserIds, err = ber.ReadInteger(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">params.maxTokenIds, err = ber.ReadInteger(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">params.numPriorities, err = ber.ReadInteger(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">params.minThroughput, err = ber.ReadInteger(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">params.maxHeight, err = ber.ReadInteger(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">params.maxMCSPDUsize, err = ber.ReadInteger(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">params.protocolVersion, err = ber.ReadInteger(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package rdp

import (
        "bufio"
        "crypto/tls"
        "encoding/asn1"
        "fmt"
        "log"
        "net"
        "strings"
        "time"

        "github.com/kulaginds/rdp-html5/internal/pkg/config"
        "github.com/tomatome/grdp/protocol/nla"
)

// StartNLA performs Network Level Authentication using CredSSP/NTLMv2
func (c *client) StartNLA() error <span class="cov0" title="0">{
        log.Println("NLA: Starting Network Level Authentication")

        // First, establish TLS connection
        if err := c.startTLSForNLA(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA TLS setup failed: %w", err)
        }</span>

        // Parse domain from username if present (DOMAIN\user or user@domain)
        <span class="cov0" title="0">domain, user := c.parseDomainUser()

        // Create NTLMv2 context using grdp's implementation
        ntlm := nla.NewNTLMv2(domain, user, c.password)

        // Step 1: Send NTLM Negotiate message
        log.Println("NLA: Sending NTLM Negotiate message")
        negoMsg := ntlm.GetNegotiateMessage()
        tsReq := nla.EncodeDERTRequest([]nla.Message{negoMsg}, nil, nil)

        if _, err := c.conn.Write(tsReq); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to send negotiate message: %w", err)
        }</span>

        // Step 2: Receive server challenge
        <span class="cov0" title="0">log.Println("NLA: Waiting for server challenge")
        resp := make([]byte, 4096)
        n, err := c.conn.Read(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to read challenge: %w", err)
        }</span>

        <span class="cov0" title="0">tsResp, err := nla.DecodeDERTRequest(resp[:n])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to decode challenge: %w", err)
        }</span>

        <span class="cov0" title="0">if len(tsResp.NegoTokens) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: no challenge token received from server")
        }</span>

        // Step 3: Process challenge and get authenticate message
        <span class="cov0" title="0">log.Println("NLA: Processing challenge, generating authenticate message")
        authMsg, ntlmSec := ntlm.GetAuthenticateMessage(tsResp.NegoTokens[0].Data)
        if authMsg == nil || ntlmSec == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to generate authenticate message")
        }</span>

        // Get the server's public key from the TLS connection
        <span class="cov0" title="0">pubKey, err := c.getTLSPublicKey()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to get TLS public key: %w", err)
        }</span>

        // Encrypt the public key
        <span class="cov0" title="0">encryptedPubKey := ntlmSec.GssEncrypt(pubKey)

        // Send authenticate message with encrypted public key
        log.Println("NLA: Sending authenticate message")
        tsReq = nla.EncodeDERTRequest([]nla.Message{authMsg}, nil, encryptedPubKey)
        if _, err := c.conn.Write(tsReq); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to send authenticate message: %w", err)
        }</span>

        // Step 4: Receive public key verification from server
        <span class="cov0" title="0">log.Println("NLA: Waiting for server public key verification")
        resp = make([]byte, 4096)
        n, err = c.conn.Read(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to read public key response: %w", err)
        }</span>

        <span class="cov0" title="0">tsResp, err = nla.DecodeDERTRequest(resp[:n])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to decode public key response: %w", err)
        }</span>

        // Verify server's public key (optional, can be skipped for compatibility)
        <span class="cov0" title="0">if len(tsResp.PubKeyAuth) &gt; 0 </span><span class="cov0" title="0">{
                log.Println("NLA: Server public key verification received")
                // The server returns pubKey + 1, we could verify this but skip for now
        }</span>

        // Step 5: Send credentials
        <span class="cov0" title="0">log.Println("NLA: Sending encrypted credentials")
        domainBytes, userBytes, passBytes := ntlm.GetEncodedCredentials()
        credentials := nla.EncodeDERTCredentials(domainBytes, userBytes, passBytes)
        encryptedCreds := ntlmSec.GssEncrypt(credentials)

        tsReq = nla.EncodeDERTRequest(nil, encryptedCreds, nil)
        if _, err := c.conn.Write(tsReq); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to send credentials: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("NLA: Authentication completed successfully")
        return nil</span>
}

// startTLSForNLA establishes TLS connection for NLA
func (c *client) startTLSForNLA() error <span class="cov0" title="0">{
        insecureSkipVerify := c.skipTLSValidation
        serverName := c.tlsServerName
        minTLSVersion := "1.2"

        cfg := config.GetGlobalConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                var err error
                cfg, err = config.Load()
                if err != nil </span><span class="cov0" title="0">{
                        cfg = &amp;config.Config{}
                }</span>
        }

        <span class="cov0" title="0">if cfg != nil </span><span class="cov0" title="0">{
                if !insecureSkipVerify </span><span class="cov0" title="0">{
                        insecureSkipVerify = cfg.Security.SkipTLSValidation
                }</span>
                <span class="cov0" title="0">if serverName == "" </span><span class="cov0" title="0">{
                        serverName = cfg.Security.TLSServerName
                }</span>
                <span class="cov0" title="0">if cfg.Security.MinTLSVersion != "" </span><span class="cov0" title="0">{
                        minTLSVersion = cfg.Security.MinTLSVersion
                }</span>
        }

        <span class="cov0" title="0">if serverName == "" </span><span class="cov0" title="0">{
                serverName = c.getServerName()
        }</span>

        <span class="cov0" title="0">if insecureSkipVerify </span><span class="cov0" title="0">{
                minTLSVersion = "1.0"
        }</span>

        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{
                InsecureSkipVerify: insecureSkipVerify,
                MinVersion:         c.getMinTLSVersion(minTLSVersion),
                MaxVersion:         tls.VersionTLS13,
                ServerName:         serverName,
        }

        if tlsConfig.InsecureSkipVerify &amp;&amp; tlsConfig.ServerName == "" </span><span class="cov0" title="0">{
                if c.conn != nil </span><span class="cov0" title="0">{
                        remoteAddr := c.conn.RemoteAddr().String()
                        host, _, err := net.SplitHostPort(remoteAddr)
                        if err == nil &amp;&amp; host != "" </span><span class="cov0" title="0">{
                                tlsConfig.ServerName = host
                        }</span>
                }
                <span class="cov0" title="0">if tlsConfig.ServerName == "" </span><span class="cov0" title="0">{
                        tlsConfig.ServerName = "rdp-server"
                }</span>
        }

        <span class="cov0" title="0">log.Println("NLA: Starting TLS for CredSSP")

        tlsConn := tls.Client(c.conn, tlsConfig)

        if tcpConn, ok := c.conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                tcpConn.SetReadDeadline(time.Now().Add(30 * time.Second))
                tcpConn.SetWriteDeadline(time.Now().Add(30 * time.Second))
        }</span>

        <span class="cov0" title="0">if err := tlsConn.Handshake(); err != nil </span><span class="cov0" title="0">{
                if insecureSkipVerify </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS handshake failed even with validation skipped: %w", err)
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "certificate") || strings.Contains(err.Error(), "x509") </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS certificate verification failed: %w. Consider using --skip-tls-validation", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("TLS handshake failed: %w", err)</span>
        }

        <span class="cov0" title="0">if tcpConn, ok := c.conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                tcpConn.SetReadDeadline(time.Time{})
                tcpConn.SetWriteDeadline(time.Time{})
        }</span>

        <span class="cov0" title="0">c.conn = tlsConn
        c.buffReader = bufio.NewReaderSize(c.conn, readBufferSize)

        return nil</span>
}

// getTLSPublicKey extracts the server's public key from the TLS connection
func (c *client) getTLSPublicKey() ([]byte, error) <span class="cov0" title="0">{
        tlsConn, ok := c.conn.(*tls.Conn)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connection is not TLS")
        }</span>

        <span class="cov0" title="0">state := tlsConn.ConnectionState()
        if len(state.PeerCertificates) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no peer certificates")
        }</span>

        // Get the raw public key from the certificate
        <span class="cov0" title="0">cert := state.PeerCertificates[0]
        pubKeyBytes, err := asn1.Marshal(cert.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback: use raw public key info
                return cert.RawSubjectPublicKeyInfo, nil
        }</span>

        <span class="cov0" title="0">return pubKeyBytes, nil</span>
}

// parseDomainUser parses DOMAIN\user or user@domain format
func (c *client) parseDomainUser() (domain, user string) <span class="cov0" title="0">{
        username := c.username

        // Check for DOMAIN\user format
        if idx := strings.Index(username, "\\"); idx != -1 </span><span class="cov0" title="0">{
                return username[:idx], username[idx+1:]
        }</span>

        // Check for user@domain format
        <span class="cov0" title="0">if idx := strings.Index(username, "@"); idx != -1 </span><span class="cov0" title="0">{
                return username[idx+1:], username[:idx]
        }</span>

        // No domain specified
        <span class="cov0" title="0">return c.domain, username</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "errors"
        "io"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/utf16"
)

const (
        rdpVersion5Plus             = 0x00080004
        keyboardTypeIBM101or102Keys = 0x00000004
)

// earlyCapabilityFlags
const (
        ECFSupportErrInfoPDU        uint16 = 0x0001
        ECFWant32BPPSession         uint16 = 0x0002
        ECFSupportStatusInfoPDU     uint16 = 0x0004
        ECFStrongAsymmetricKeys     uint16 = 0x0008
        ECFUnused                   uint16 = 0x0010
        ECFValidConnectionType      uint16 = 0x0020
        ECFSupportMonitorLayoutPDU  uint16 = 0x0040
        ECFSupportNetCharAutodetect uint16 = 0x0080
        ECFSupportDynvcGFXProtocol  uint16 = 0x0100
        ECFSupportDynamicTimeZone   uint16 = 0x0200
        ECFSupportHeartbeatPDU      uint16 = 0x0400
)

type ClientCoreData struct {
        Version                uint32
        DesktopWidth           uint16
        DesktopHeight          uint16
        ColorDepth             uint16
        SASSequence            uint16
        KeyboardLayout         uint32
        ClientBuild            uint32
        ClientName             [32]byte
        KeyboardType           uint32
        KeyboardSubType        uint32
        KeyboardFunctionKey    uint32
        ImeFileName            [64]byte
        PostBeta2ColorDepth    uint16
        ClientProductId        uint16
        SerialNumber           uint32
        HighColorDepth         uint16
        SupportedColorDepths   uint16
        EarlyCapabilityFlags   uint16
        ClientDigProductId     [64]byte
        ConnectionType         uint8
        Pad1octet              uint8
        ServerSelectedProtocol uint32
}

func newClientCoreData(selectedProtocol uint32, desktopWidth, desktopHeight uint16) *ClientCoreData <span class="cov1" title="1">{
        data := ClientCoreData{
                Version:                rdpVersion5Plus,
                DesktopWidth:           desktopWidth,
                DesktopHeight:          desktopHeight,
                ColorDepth:             0xCA01,     // RNS_UD_COLOR_8BPP
                SASSequence:            0xAA03,     // RNS_UD_SAS_DEL
                KeyboardLayout:         0x00000409, // US
                ClientBuild:            0xece,
                ClientName:             [32]byte{},
                KeyboardType:           keyboardTypeIBM101or102Keys,
                KeyboardSubType:        0x00000000,
                KeyboardFunctionKey:    12,
                ImeFileName:            [64]byte{},
                PostBeta2ColorDepth:    0xCA03, // RNS_UD_COLOR_16BPP_565
                ClientProductId:        0x0001,
                SerialNumber:           0x00000000,
                HighColorDepth:         0x0010, // HIGH_COLOR_16BPP
                SupportedColorDepths:   0x0002, // RNS_UD_16BPP_SUPPORT
                EarlyCapabilityFlags:   ECFSupportErrInfoPDU,
                ClientDigProductId:     [64]byte{},
                ConnectionType:         0x00,
                Pad1octet:              0x00,
                ServerSelectedProtocol: selectedProtocol,
        }

        copy(data.ClientName[:], utf16.Encode(projectName))

        return &amp;data
}</span>

const (
        // EncryptionFlag40Bit ENCRYPTION_FLAG_40BIT
        EncryptionFlag40Bit uint32 = 0x00000001

        // EncryptionFlag128Bit ENCRYPTION_FLAG_128BIT
        EncryptionFlag128Bit uint32 = 0x00000002

        // EncryptionFlag56Bit ENCRYPTION_FLAG_56BIT
        EncryptionFlag56Bit uint32 = 0x00000008

        // FIPSEncryptionFlag FIPS_ENCRYPTION_FLAG
        FIPSEncryptionFlag uint32 = 0x00000010
)

type ClientSecurityData struct {
        EncryptionMethods    uint32
        ExtEncryptionMethods uint32
}

func newClientSecurityData() *ClientSecurityData <span class="cov1" title="1">{
        data := ClientSecurityData{
                EncryptionMethods:    0,
                ExtEncryptionMethods: 0,
        }

        return &amp;data
}</span>

type ChannelDefinitionStructure struct {
        Name    [8]byte // seven ANSI chars with null-termination char in the end
        Options uint32
}

type ClientNetworkData struct {
        ChannelCount    uint32
        ChannelDefArray []ChannelDefinitionStructure
}

type ClientClusterData struct {
        Flags               uint32
        RedirectedSessionID uint32
}

type ClientUserDataSet struct {
        ClientCoreData     *ClientCoreData
        ClientSecurityData *ClientSecurityData
        ClientNetworkData  *ClientNetworkData
        ClientClusterData  *ClientClusterData
}

func NewClientUserDataSet(selectedProtocol uint32,
        desktopWidth, desktopHeight uint16,
        channelNames []string) *ClientUserDataSet <span class="cov1" title="1">{
        return &amp;ClientUserDataSet{
                ClientCoreData:     newClientCoreData(selectedProtocol, desktopWidth, desktopHeight),
                ClientSecurityData: newClientSecurityData(),
                ClientNetworkData:  newClientNetworkData(channelNames),
        }
}</span>

func (data ClientCoreData) Serialize() []byte <span class="cov1" title="1">{
        const dataLen uint16 = 216

        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, uint16(0xC001)) // header type CS_CORE
        binary.Write(buf, binary.LittleEndian, dataLen)        // packet size

        binary.Write(buf, binary.LittleEndian, data.Version)
        binary.Write(buf, binary.LittleEndian, data.DesktopWidth)
        binary.Write(buf, binary.LittleEndian, data.DesktopHeight)
        binary.Write(buf, binary.LittleEndian, data.ColorDepth)
        binary.Write(buf, binary.LittleEndian, data.SASSequence)
        binary.Write(buf, binary.LittleEndian, data.KeyboardLayout)
        binary.Write(buf, binary.LittleEndian, data.ClientBuild)
        binary.Write(buf, binary.LittleEndian, data.ClientName)
        binary.Write(buf, binary.LittleEndian, data.KeyboardType)
        binary.Write(buf, binary.LittleEndian, data.KeyboardSubType)
        binary.Write(buf, binary.LittleEndian, data.KeyboardFunctionKey)
        binary.Write(buf, binary.LittleEndian, data.ImeFileName)
        binary.Write(buf, binary.LittleEndian, data.PostBeta2ColorDepth)
        binary.Write(buf, binary.LittleEndian, data.ClientProductId)
        binary.Write(buf, binary.LittleEndian, data.SerialNumber)
        binary.Write(buf, binary.LittleEndian, data.HighColorDepth)
        binary.Write(buf, binary.LittleEndian, data.SupportedColorDepths)
        binary.Write(buf, binary.LittleEndian, data.EarlyCapabilityFlags)
        binary.Write(buf, binary.LittleEndian, data.ClientDigProductId)
        binary.Write(buf, binary.LittleEndian, data.ConnectionType)
        binary.Write(buf, binary.LittleEndian, data.Pad1octet)
        binary.Write(buf, binary.LittleEndian, data.ServerSelectedProtocol)

        return buf.Bytes()
}</span>

const (
        // EncryptionMethodFlag40Bit 40BIT_ENCRYPTION_FLAG
        EncryptionMethodFlag40Bit uint32 = 0x00000001

        // EncryptionMethodFlag56Bit 56BIT_ENCRYPTION_FLAG
        EncryptionMethodFlag56Bit uint32 = 0x00000008

        // EncryptionMethodFlag128Bit 128BIT_ENCRYPTION_FLAG
        EncryptionMethodFlag128Bit uint32 = 0x00000002

        // EncryptionMethodFlagFIPS FIPS_ENCRYPTION_FLAG
        EncryptionMethodFlagFIPS uint32 = 0x00000010
)

func (data ClientSecurityData) Serialize() []byte <span class="cov1" title="1">{
        const dataLen uint16 = 12

        buf := bytes.NewBuffer(make([]byte, 0, 6))

        binary.Write(buf, binary.LittleEndian, uint16(0xC002)) // header type CS_SECURITY
        binary.Write(buf, binary.LittleEndian, dataLen)        // packet size

        binary.Write(buf, binary.LittleEndian, data.EncryptionMethods)
        binary.Write(buf, binary.LittleEndian, data.ExtEncryptionMethods)

        return buf.Bytes()
}</span>

func (s ChannelDefinitionStructure) Serialize() []byte <span class="cov10" title="3">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, s.Name)
        binary.Write(buf, binary.LittleEndian, s.Options)

        return buf.Bytes()
}</span>

func newClientNetworkData(channelNames []string) *ClientNetworkData <span class="cov1" title="1">{
        data := ClientNetworkData{
                ChannelCount: uint32(len(channelNames)),
        }

        if data.ChannelCount == 0 </span><span class="cov0" title="0">{
                return &amp;data
        }</span>

        <span class="cov1" title="1">for _, channelName := range channelNames </span><span class="cov10" title="3">{
                channelDefinition := ChannelDefinitionStructure{}
                copy(channelDefinition.Name[:], channelName)

                data.ChannelDefArray = append(data.ChannelDefArray, channelDefinition)
        }</span>

        <span class="cov1" title="1">return &amp;data</span>
}

func (data ClientNetworkData) Serialize() []byte <span class="cov1" title="1">{
        const headerLen = 8

        chBuf := new(bytes.Buffer)

        for _, channelDef := range data.ChannelDefArray </span><span class="cov10" title="3">{
                chBuf.Write(channelDef.Serialize())
        }</span>

        <span class="cov1" title="1">buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, uint16(0xC003))                // header type CS_NET
        binary.Write(buf, binary.LittleEndian, uint16(headerLen+chBuf.Len())) // packet size

        binary.Write(buf, binary.LittleEndian, data.ChannelCount)

        buf.Write(chBuf.Bytes())

        return buf.Bytes()</span>
}

func (d ClientClusterData) Serialize() []byte <span class="cov1" title="1">{
        const dataLen uint16 = 12

        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, uint16(0xC004)) // header type CS_CLUSTER
        binary.Write(buf, binary.LittleEndian, dataLen)        // packet size

        binary.Write(buf, binary.LittleEndian, d.Flags)
        binary.Write(buf, binary.LittleEndian, d.RedirectedSessionID)

        return buf.Bytes()
}</span>

func (ud ClientUserDataSet) Serialize() []byte <span class="cov1" title="1">{
        buf := new(bytes.Buffer)

        buf.Write(ud.ClientCoreData.Serialize())

        if ud.ClientClusterData != nil </span><span class="cov1" title="1">{
                buf.Write(ud.ClientClusterData.Serialize())
        }</span>

        <span class="cov1" title="1">buf.Write(ud.ClientSecurityData.Serialize())
        buf.Write(ud.ClientNetworkData.Serialize())

        return buf.Bytes()</span>
}

type ServerCoreData struct {
        Version                  uint32
        ClientRequestedProtocols uint32
        EarlyCapabilityFlags     uint32

        DataLen uint16
}

func (d *ServerCoreData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        if err = binary.Read(wire, binary.LittleEndian, &amp;d.Version); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if d.DataLen == 4 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;d.ClientRequestedProtocols); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if d.DataLen == 8 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;d.EarlyCapabilityFlags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type RSAPublicKey struct {
        Magic   uint32
        KeyLen  uint32
        BitLen  uint32
        DataLen uint32
        PubExp  uint32
        Modulus []byte
}

func (k *RSAPublicKey) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        if err = binary.Read(wire, binary.LittleEndian, &amp;k.Magic); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;k.KeyLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;k.BitLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;k.DataLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;k.PubExp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">k.Modulus = make([]byte, k.KeyLen)

        if _, err = wire.Read(k.Modulus); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type ServerProprietaryCertificate struct {
        DwSigAlgId        uint32
        DwKeyAlgId        uint32
        PublicKeyBlobType uint16
        PublicKeyBlobLen  uint16
        PublicKeyBlob     RSAPublicKey
        SignatureBlobType uint16
        SignatureBlobLen  uint16
        SignatureBlob     []byte
}

func (c *ServerProprietaryCertificate) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        if err = binary.Read(wire, binary.LittleEndian, &amp;c.DwSigAlgId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;c.DwKeyAlgId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;c.PublicKeyBlobType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;c.PublicKeyBlobLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = c.PublicKeyBlob.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;c.SignatureBlobType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;c.SignatureBlobLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.SignatureBlob = make([]byte, c.SignatureBlobLen)

        if _, err = wire.Read(c.SignatureBlob); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type ServerCertificate struct {
        DwVersion       uint32
        ProprietaryCert *ServerProprietaryCertificate
        X509Cert        []byte

        ServerCertLen uint32
}

func (c *ServerCertificate) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        if err = binary.Read(wire, binary.LittleEndian, &amp;c.DwVersion); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if c.DwVersion&amp;0x00000001 == 0x00000001 </span><span class="cov0" title="0">{
                c.ProprietaryCert = &amp;ServerProprietaryCertificate{}

                return c.ProprietaryCert.Deserialize(wire)
        }</span>

        <span class="cov0" title="0">c.X509Cert = make([]byte, c.ServerCertLen-4)

        if _, err = wire.Read(c.X509Cert); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type ServerSecurityData struct {
        EncryptionMethod  uint32
        EncryptionLevel   uint32
        ServerRandomLen   uint32
        ServerCertLen     uint32
        ServerRandom      []byte
        ServerCertificate *ServerCertificate
}

func (d *ServerSecurityData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        if err = binary.Read(wire, binary.LittleEndian, &amp;d.EncryptionMethod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;d.EncryptionLevel); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if d.EncryptionMethod == 0 &amp;&amp; d.EncryptionLevel == 0 </span><span class="cov0" title="0">{ // ENCRYPTION_METHOD_NONE and ENCRYPTION_LEVEL_NONE
                return nil
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;d.ServerRandomLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;d.ServerCertLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d.ServerRandom = make([]byte, d.ServerRandomLen)

        if _, err = wire.Read(d.ServerRandom); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if d.ServerCertLen &gt; 0 </span><span class="cov0" title="0">{
                d.ServerCertificate = &amp;ServerCertificate{
                        ServerCertLen: d.ServerCertLen,
                }

                return d.ServerCertificate.Deserialize(wire)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type ServerNetworkData struct {
        MCSChannelId   uint16
        ChannelCount   uint16
        ChannelIdArray []uint16
}

func (d *ServerNetworkData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        if err = binary.Read(wire, binary.LittleEndian, &amp;d.MCSChannelId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = binary.Read(wire, binary.LittleEndian, &amp;d.ChannelCount); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if d.ChannelCount == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">d.ChannelIdArray = make([]uint16, d.ChannelCount)

        if err = binary.Read(wire, binary.LittleEndian, &amp;d.ChannelIdArray); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if d.ChannelCount%2 == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">padding := make([]byte, 2)

        if _, err = wire.Read(padding); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type ServerMessageChannelData struct {
        MCSChannelID uint16
}

type ServerMultitransportChannelData struct {
        Flags uint32
}

type ServerUserData struct {
        ServerCoreData                  *ServerCoreData
        ServerNetworkData               *ServerNetworkData
        ServerSecurityData              *ServerSecurityData
        ServerMessageChannelData        *ServerMessageChannelData
        ServerMultitransportChannelData *ServerMultitransportChannelData
}

func (ud *ServerUserData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var (
                dataType uint16
                dataLen  uint16
                err      error
        )

        for </span><span class="cov0" title="0">{
                err = binary.Read(wire, binary.LittleEndian, &amp;dataType)
                switch err </span>{
                case nil:<span class="cov0" title="0"></span> // pass
                case io.EOF:<span class="cov0" title="0">
                        return nil</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }

                <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;dataLen)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">dataLen -= 4 // exclude User Data Header

                switch dataType </span>{
                case 0x0C01:<span class="cov0" title="0">
                        ud.ServerCoreData = &amp;ServerCoreData{DataLen: dataLen}

                        if err = ud.ServerCoreData.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case 0x0C02:<span class="cov0" title="0">
                        ud.ServerSecurityData = &amp;ServerSecurityData{}

                        if err = ud.ServerSecurityData.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case 0x0C03:<span class="cov0" title="0">
                        ud.ServerNetworkData = &amp;ServerNetworkData{}

                        if err = ud.ServerNetworkData.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case 0x0C04:<span class="cov0" title="0">
                        ud.ServerMessageChannelData = &amp;ServerMessageChannelData{}

                        if err = binary.Read(wire, binary.LittleEndian, &amp;ud.ServerMessageChannelData.MCSChannelID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case 0x0C08:<span class="cov0" title="0">
                        ud.ServerMultitransportChannelData = &amp;ServerMultitransportChannelData{}

                        if err = binary.Read(wire, binary.LittleEndian, &amp;ud.ServerMultitransportChannelData.Flags); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        return errors.New("unknown header type")</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
)

type GeneralCapabilitySet struct {
        OSMajorType           uint16
        OSMinorType           uint16
        ExtraFlags            uint16
        RefreshRectSupport    uint8
        SuppressOutputSupport uint8
}

func NewGeneralCapabilitySet() CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeGeneral,
                GeneralCapabilitySet: &amp;GeneralCapabilitySet{
                        OSMajorType: 0x000A,                                     // Windows 10+ platform
                        OSMinorType: 0x0000,                                     // Latest version
                        ExtraFlags:  0x0001 | 0x0004 | 0x0400 | 0x0080 | 0x0100, // Enhanced features: FASTPATH_OUTPUT_SUPPORTED, LONG_CREDENTIALS_SUPPORTED, NO_BITMAP_COMPRESSION_HDR, DYNAMIC_DST_SUPPORTED, TILE_SUPPORT
                },
        }
}</span>

func (s *GeneralCapabilitySet) Serialize() []byte <span class="cov3" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.OSMajorType)
        _ = binary.Write(buf, binary.LittleEndian, s.OSMinorType)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0200)) // protocolVersion
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // padding
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // compressionTypes
        _ = binary.Write(buf, binary.LittleEndian, s.ExtraFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // updateCapabilityFlag
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // remoteUnshareFlag
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // compressionLevel
        _ = binary.Write(buf, binary.LittleEndian, s.RefreshRectSupport)
        _ = binary.Write(buf, binary.LittleEndian, s.SuppressOutputSupport)

        return buf.Bytes()
}</span>

func (s *GeneralCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.OSMajorType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.OSMinorType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var protocolVersion uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;protocolVersion)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var compressionTypes uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;compressionTypes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.ExtraFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var updateCapabilityFlag uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;updateCapabilityFlag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var remoteUnshareFlag uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;remoteUnshareFlag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var compressionLevel uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;compressionLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.RefreshRectSupport)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.SuppressOutputSupport)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type BitmapCapabilitySet struct {
        PreferredBitsPerPixel uint16
        Receive1BitPerPixel   uint16
        Receive4BitsPerPixel  uint16
        Receive8BitsPerPixel  uint16
        DesktopWidth          uint16
        DesktopHeight         uint16
        DesktopResizeFlag     uint16
        DrawingFlags          uint8
}

func NewBitmapCapabilitySet(desktopWidth, desktopHeight uint16) CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeBitmap,
                BitmapCapabilitySet: &amp;BitmapCapabilitySet{
                        PreferredBitsPerPixel: 0x0020, // HIGH_COLOR_32BPP (32-bit color support)
                        Receive1BitPerPixel:   0x0001,
                        Receive4BitsPerPixel:  0x0001,
                        Receive8BitsPerPixel:  0x0001,
                        DesktopWidth:          desktopWidth,
                        DesktopHeight:         desktopHeight,
                        DesktopResizeFlag:     0x0001, // Support dynamic resizing
                },
        }
}</span>

func (s *BitmapCapabilitySet) Serialize() []byte <span class="cov3" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.PreferredBitsPerPixel)
        _ = binary.Write(buf, binary.LittleEndian, s.Receive1BitPerPixel)
        _ = binary.Write(buf, binary.LittleEndian, s.Receive4BitsPerPixel)
        _ = binary.Write(buf, binary.LittleEndian, s.Receive8BitsPerPixel)
        _ = binary.Write(buf, binary.LittleEndian, s.DesktopWidth)
        _ = binary.Write(buf, binary.LittleEndian, s.DesktopHeight)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // padding
        _ = binary.Write(buf, binary.LittleEndian, s.DesktopResizeFlag)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0001)) // bitmapCompressionFlag
        _ = binary.Write(buf, binary.LittleEndian, uint8(0))       // highColorFlags
        _ = binary.Write(buf, binary.LittleEndian, s.DrawingFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0001)) // multipleRectangleSupport
        _ = binary.Write(buf, binary.LittleEndian, uint16(0))      // padding

        return buf.Bytes()
}</span>

func (s *BitmapCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.PreferredBitsPerPixel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.Receive1BitPerPixel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.Receive4BitsPerPixel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.Receive8BitsPerPixel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.DesktopWidth)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.DesktopHeight)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.DesktopResizeFlag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var bitmapCompressionFlag uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;bitmapCompressionFlag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var highColorFlags uint8
        err = binary.Read(wire, binary.LittleEndian, &amp;highColorFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.DrawingFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var multipleRectangleSupport uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;multipleRectangleSupport)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type OrderCapabilitySet struct {
        OrderFlags          uint16
        OrderSupport        [32]byte
        textFlags           uint16
        OrderSupportExFlags uint16
        DesktopSaveSize     uint32
        textANSICodePage    uint16
}

func NewOrderCapabilitySet() CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeOrder,
                OrderCapabilitySet: &amp;OrderCapabilitySet{
                        OrderFlags:      0x2 | 0x0008, // NEGOTIATEORDERSUPPORT, ZEROBOUNDSDELTASSUPPORT this flags must be set
                        DesktopSaveSize: 480 * 480,
                },
        }
}</span>

func (s *OrderCapabilitySet) Serialize() []byte <span class="cov3" title="3">{
        buf := new(bytes.Buffer)

        buf.Write(make([]byte, 16))                            // terminalDescriptor
        _ = binary.Write(buf, binary.LittleEndian, uint32(0))  // padding
        _ = binary.Write(buf, binary.LittleEndian, uint16(1))  // desktopSaveXGranularity
        _ = binary.Write(buf, binary.LittleEndian, uint16(20)) // desktopSaveYGranularity
        _ = binary.Write(buf, binary.LittleEndian, uint16(0))  // padding
        _ = binary.Write(buf, binary.LittleEndian, uint16(1))  // maximumOrderLevel = ORD_LEVEL_1_ORDERS
        _ = binary.Write(buf, binary.LittleEndian, uint16(0))  // numberFonts
        _ = binary.Write(buf, binary.LittleEndian, s.OrderFlags)
        _ = binary.Write(buf, binary.LittleEndian, s.OrderSupport)
        _ = binary.Write(buf, binary.LittleEndian, s.textFlags) // textFlags
        _ = binary.Write(buf, binary.LittleEndian, s.OrderSupportExFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint32(0)) // padding
        _ = binary.Write(buf, binary.LittleEndian, s.DesktopSaveSize)
        _ = binary.Write(buf, binary.LittleEndian, uint32(0))          // padding
        _ = binary.Write(buf, binary.LittleEndian, s.textANSICodePage) // textANSICodePage
        _ = binary.Write(buf, binary.LittleEndian, uint16(0))          // padding

        return buf.Bytes()
}</span>

func (s *OrderCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var (
                err                     error
                terminalDescriptor      [16]byte
                padding                 uint32
                desktopSaveXGranularity uint16
                desktopSaveYGranularity uint16
                padding2                uint16
                maximumOrderLevel       uint16
                numberFonts             uint16
                textFlags               uint16
                textANSICodePage        uint16
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;terminalDescriptor)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;desktopSaveXGranularity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;desktopSaveYGranularity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;padding2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;maximumOrderLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;numberFonts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.OrderFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.OrderSupport)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;textFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.OrderSupportExFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.DesktopSaveSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;textANSICodePage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;padding2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type BitmapCacheCapabilitySetRev1 struct {
        Cache0Entries         uint16
        Cache0MaximumCellSize uint16
        Cache1Entries         uint16
        Cache1MaximumCellSize uint16
        Cache2Entries         uint16
        Cache2MaximumCellSize uint16
}

func NewBitmapCacheCapabilitySetRev1() CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType:            CapabilitySetTypeBitmapCache,
                BitmapCacheCapabilitySetRev1: &amp;BitmapCacheCapabilitySetRev1{},
        }
}</span>

func (s *BitmapCacheCapabilitySetRev1) Serialize() []byte <span class="cov1" title="1">{
        buf := new(bytes.Buffer)

        buf.Write(make([]byte, 24)) // padding
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.Cache0Entries)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.Cache0MaximumCellSize)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.Cache1Entries)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.Cache1MaximumCellSize)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.Cache2Entries)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.Cache2MaximumCellSize)

        return buf.Bytes()
}</span>

func (s *BitmapCacheCapabilitySetRev1) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var (
                padding [24]byte
                err     error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.Cache0Entries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.Cache0MaximumCellSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.Cache1Entries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.Cache1MaximumCellSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.Cache2Entries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.Cache2MaximumCellSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type BitmapCacheCapabilitySetRev2 struct {
        CacheFlags           uint16
        NumCellCaches        uint8
        BitmapCache0CellInfo uint32
        BitmapCache1CellInfo uint32
        BitmapCache2CellInfo uint32
        BitmapCache3CellInfo uint32
        BitmapCache4CellInfo uint32
}

func NewBitmapCacheCapabilitySetRev2() *CapabilitySet <span class="cov0" title="0">{
        return &amp;CapabilitySet{
                CapabilitySetType:            CapabilitySetTypeBitmapCacheRev2,
                BitmapCacheCapabilitySetRev2: &amp;BitmapCacheCapabilitySetRev2{},
        }
}</span>

func (s *BitmapCacheCapabilitySetRev2) Serialize() []byte <span class="cov2" title="2">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, &amp;s.CacheFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint8(0)) // padding
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.NumCellCaches)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.BitmapCache0CellInfo)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.BitmapCache1CellInfo)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.BitmapCache2CellInfo)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.BitmapCache3CellInfo)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.BitmapCache4CellInfo)
        buf.Write(make([]byte, 12)) // padding

        return buf.Bytes()
}</span>

func (s *BitmapCacheCapabilitySetRev2) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.CacheFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var padding uint8
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.NumCellCaches)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.BitmapCache0CellInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.BitmapCache1CellInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.BitmapCache2CellInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.BitmapCache3CellInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.BitmapCache4CellInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.BitmapCache4CellInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var padding2 [12]byte
        err = binary.Read(wire, binary.LittleEndian, &amp;padding2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type ColorCacheCapabilitySet struct {
        ColorTableCacheSize uint16
}

func (s *ColorCacheCapabilitySet) Serialize() []byte <span class="cov2" title="2">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, &amp;s.ColorTableCacheSize)
        binary.Write(buf, binary.LittleEndian, uint16(0)) // padding

        return buf.Bytes()
}</span>

func (s *ColorCacheCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var (
                padding uint16
                err     error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;s.ColorTableCacheSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return binary.Read(wire, binary.LittleEndian, &amp;padding)</span>
}

type PointerCapabilitySet struct {
        ColorPointerFlag      uint16
        ColorPointerCacheSize uint16
        PointerCacheSize      uint16
        lengthCapability      uint16
}

func NewPointerCapabilitySet() CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypePointer,
                PointerCapabilitySet: &amp;PointerCapabilitySet{
                        ColorPointerFlag: 1, // color mouse cursors are supported
                        PointerCacheSize: 25,
                },
        }
}</span>

func (s *PointerCapabilitySet) Serialize() []byte <span class="cov2" title="2">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.ColorPointerFlag)
        _ = binary.Write(buf, binary.LittleEndian, s.ColorPointerCacheSize)
        _ = binary.Write(buf, binary.LittleEndian, s.PointerCacheSize)

        return buf.Bytes()
}</span>

func (s *PointerCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.ColorPointerFlag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.ColorPointerCacheSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if s.lengthCapability == 4 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.PointerCacheSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type InputCapabilitySet struct {
        InputFlags          uint16
        KeyboardLayout      uint32
        KeyboardType        uint32
        KeyboardSubType     uint32
        KeyboardFunctionKey uint32
        ImeFileName         [64]byte
}

func NewInputCapabilitySet() CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeInput,
                InputCapabilitySet: &amp;InputCapabilitySet{
                        InputFlags:          0x0001 | 0x0004 | 0x0010 | 0x0020, // INPUT_FLAG_SCANCODES, INPUT_FLAG_MOUSEX, INPUT_FLAG_UNICODE, INPUT_FLAG_FASTPATH_INPUT2
                        KeyboardLayout:      0x00000409,                        // US
                        KeyboardType:        0x00000004,                        // IBM enhanced (101- or 102-key) keyboard
                        KeyboardFunctionKey: 12,
                },
        }
}</span>

func (s *InputCapabilitySet) Serialize() []byte <span class="cov3" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.InputFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // padding
        _ = binary.Write(buf, binary.LittleEndian, s.KeyboardLayout)
        _ = binary.Write(buf, binary.LittleEndian, s.KeyboardType)
        _ = binary.Write(buf, binary.LittleEndian, s.KeyboardSubType)
        _ = binary.Write(buf, binary.LittleEndian, s.KeyboardFunctionKey)
        _ = binary.Write(buf, binary.LittleEndian, s.ImeFileName)

        return buf.Bytes()
}</span>

func (s *InputCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.InputFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.KeyboardLayout)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.KeyboardType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.KeyboardSubType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.KeyboardFunctionKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.ImeFileName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type BrushSupportLevel uint32

const (
        // BrushSupportLevelDefault BRUSH_DEFAULT
        BrushSupportLevelDefault BrushSupportLevel = 0

        // BrushSupportLevelColor8x8 BRUSH_COLOR_8x8
        BrushSupportLevelColor8x8 BrushSupportLevel = 1

        // BrushSupportLevelFull BRUSH_COLOR_FULL
        BrushSupportLevelFull BrushSupportLevel = 2
)

type BrushCapabilitySet struct {
        BrushSupportLevel BrushSupportLevel
}

func NewBrushCapabilitySet() CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType:  CapabilitySetTypeBrush,
                BrushCapabilitySet: &amp;BrushCapabilitySet{},
        }
}</span>

func (s *BrushCapabilitySet) Serialize() []byte <span class="cov3" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint32(s.BrushSupportLevel))

        return buf.Bytes()
}</span>

func (s *BrushCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        return binary.Read(wire, binary.LittleEndian, &amp;s.BrushSupportLevel)
}</span>

type CacheDefinition struct {
        CacheEntries         uint16
        CacheMaximumCellSize uint16
}

func (d *CacheDefinition) Serialize() []byte <span class="cov10" title="30">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, d.CacheEntries)
        _ = binary.Write(buf, binary.LittleEndian, d.CacheMaximumCellSize)

        return buf.Bytes()
}</span>

func (d *CacheDefinition) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;d.CacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;d.CacheMaximumCellSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type GlyphSupportLevel uint16

const (
        // GlyphSupportLevelNone GLYPH_SUPPORT_NONE
        GlyphSupportLevelNone GlyphSupportLevel = 0

        // GlyphSupportLevelPartial GLYPH_SUPPORT_PARTIAL
        GlyphSupportLevelPartial GlyphSupportLevel = 1

        // GlyphSupportLevelFull GLYPH_SUPPORT_FULL
        GlyphSupportLevelFull GlyphSupportLevel = 2

        // GlyphSupportLevelEncode GLYPH_SUPPORT_ENCODE
        GlyphSupportLevelEncode GlyphSupportLevel = 3
)

type GlyphCacheCapabilitySet struct {
        GlyphCache        [10]CacheDefinition
        FragCache         uint32
        GlyphSupportLevel GlyphSupportLevel
}

func NewGlyphCacheCapabilitySet() CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType:       CapabilitySetTypeGlyphCache,
                GlyphCacheCapabilitySet: &amp;GlyphCacheCapabilitySet{},
        }
}</span>

func (s *GlyphCacheCapabilitySet) Serialize() []byte <span class="cov3" title="3">{
        buf := new(bytes.Buffer)

        for i := range s.GlyphCache </span><span class="cov10" title="30">{
                buf.Write(s.GlyphCache[i].Serialize())
        }</span>

        <span class="cov3" title="3">_ = binary.Write(buf, binary.LittleEndian, s.FragCache)
        _ = binary.Write(buf, binary.LittleEndian, s.GlyphSupportLevel)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // padding

        return buf.Bytes()</span>
}

func (s *GlyphCacheCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        for i := range s.GlyphCache </span><span class="cov0" title="0">{
                err = s.GlyphCache[i].Deserialize(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.FragCache)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.GlyphSupportLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type OffscreenBitmapCacheCapabilitySet struct {
        OffscreenSupportLevel uint32
        OffscreenCacheSize    uint16
        OffscreenCacheEntries uint16
}

func NewOffscreenBitmapCacheCapabilitySet() CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType:                 CapabilitySetTypeOffscreenBitmapCache,
                OffscreenBitmapCacheCapabilitySet: &amp;OffscreenBitmapCacheCapabilitySet{},
        }
}</span>

func (s *OffscreenBitmapCacheCapabilitySet) Serialize() []byte <span class="cov3" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.OffscreenSupportLevel)
        _ = binary.Write(buf, binary.LittleEndian, s.OffscreenCacheSize)
        _ = binary.Write(buf, binary.LittleEndian, s.OffscreenCacheEntries)

        return buf.Bytes()
}</span>

func (s *OffscreenBitmapCacheCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.OffscreenSupportLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.OffscreenCacheSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.OffscreenCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type VirtualChannelCapabilitySet struct {
        Flags       uint32
        VCChunkSize uint32
}

func NewVirtualChannelCapabilitySet() CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType:           CapabilitySetTypeVirtualChannel,
                VirtualChannelCapabilitySet: &amp;VirtualChannelCapabilitySet{},
        }
}</span>

func (s *VirtualChannelCapabilitySet) Serialize() []byte <span class="cov3" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.Flags)
        _ = binary.Write(buf, binary.LittleEndian, s.VCChunkSize)

        return buf.Bytes()
}</span>

func (s *VirtualChannelCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.Flags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.VCChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type DrawNineGridCacheCapabilitySet struct {
        drawNineGridSupportLevel uint32
        drawNineGridCacheSize    uint16
        drawNineGridCacheEntries uint16
}

func (s *DrawNineGridCacheCapabilitySet) Serialize() []byte <span class="cov2" title="2">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, s.drawNineGridSupportLevel)
        binary.Write(buf, binary.LittleEndian, s.drawNineGridCacheSize)
        binary.Write(buf, binary.LittleEndian, s.drawNineGridCacheEntries)

        return buf.Bytes()
}</span>

func (s *DrawNineGridCacheCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.drawNineGridSupportLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.drawNineGridCacheSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.drawNineGridCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type GDICacheEntries struct {
        GdipGraphicsCacheEntries        uint16
        GdipBrushCacheEntries           uint16
        GdipPenCacheEntries             uint16
        GdipImageCacheEntries           uint16
        GdipImageAttributesCacheEntries uint16
}

func (e *GDICacheEntries) Serialize() []byte <span class="cov2" title="2">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, e.GdipGraphicsCacheEntries)
        binary.Write(buf, binary.LittleEndian, e.GdipBrushCacheEntries)
        binary.Write(buf, binary.LittleEndian, e.GdipPenCacheEntries)
        binary.Write(buf, binary.LittleEndian, e.GdipImageCacheEntries)
        binary.Write(buf, binary.LittleEndian, e.GdipImageAttributesCacheEntries)

        return buf.Bytes()
}</span>

func (e *GDICacheEntries) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;e.GdipGraphicsCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;e.GdipBrushCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;e.GdipPenCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;e.GdipImageCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;e.GdipImageAttributesCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type GDICacheChunkSize struct {
        GdipGraphicsCacheChunkSize              uint16
        GdipObjectBrushCacheChunkSize           uint16
        GdipObjectPenCacheChunkSize             uint16
        GdipObjectImageAttributesCacheChunkSize uint16
}

func (s *GDICacheChunkSize) Serialize() []byte <span class="cov2" title="2">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, s.GdipGraphicsCacheChunkSize)
        binary.Write(buf, binary.LittleEndian, s.GdipObjectBrushCacheChunkSize)
        binary.Write(buf, binary.LittleEndian, s.GdipObjectPenCacheChunkSize)
        binary.Write(buf, binary.LittleEndian, s.GdipObjectImageAttributesCacheChunkSize)

        return buf.Bytes()
}</span>

func (s *GDICacheChunkSize) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.GdipGraphicsCacheChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.GdipObjectBrushCacheChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.GdipObjectPenCacheChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.GdipObjectImageAttributesCacheChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type GDIImageCacheProperties struct {
        GdipObjectImageCacheChunkSize uint16
        GdipObjectImageCacheTotalSize uint16
        GdipObjectImageCacheMaxSize   uint16
}

func (p *GDIImageCacheProperties) Serialize() []byte <span class="cov2" title="2">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, p.GdipObjectImageCacheChunkSize)
        binary.Write(buf, binary.LittleEndian, p.GdipObjectImageCacheTotalSize)
        binary.Write(buf, binary.LittleEndian, p.GdipObjectImageCacheMaxSize)

        return buf.Bytes()
}</span>

func (p *GDIImageCacheProperties) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;p.GdipObjectImageCacheChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;p.GdipObjectImageCacheTotalSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;p.GdipObjectImageCacheMaxSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type DrawGDIPlusCapabilitySet struct {
        drawGDIPlusSupportLevel  uint32
        GdipVersion              uint32
        drawGdiplusCacheLevel    uint32
        GdipCacheEntries         GDICacheEntries
        GdipCacheChunkSize       GDICacheChunkSize
        GdipImageCacheProperties GDIImageCacheProperties
}

func (s *DrawGDIPlusCapabilitySet) Serialize() []byte <span class="cov2" title="2">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, s.drawGDIPlusSupportLevel)
        binary.Write(buf, binary.LittleEndian, s.GdipVersion)
        binary.Write(buf, binary.LittleEndian, s.drawGdiplusCacheLevel)

        buf.Write(s.GdipCacheEntries.Serialize())
        buf.Write(s.GdipCacheChunkSize.Serialize())
        buf.Write(s.GdipImageCacheProperties.Serialize())

        return buf.Bytes()
}</span>

func (s *DrawGDIPlusCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.drawGDIPlusSupportLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.GdipVersion)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;s.drawGdiplusCacheLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.GdipCacheEntries.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.GdipCacheChunkSize.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.GdipImageCacheProperties.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type SoundCapabilitySet struct {
        SoundFlags uint16
}

func NewSoundCapabilitySet() CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType:  CapabilitySetTypeSound,
                SoundCapabilitySet: &amp;SoundCapabilitySet{},
        }
}</span>

func (s *SoundCapabilitySet) Serialize() []byte <span class="cov3" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.SoundFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0))

        return buf.Bytes()
}</span>

func (s *SoundCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.SoundFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type BitmapCacheHostSupportCapabilitySet struct{}

func NewBitmapCacheHostSupportCapabilitySet() *CapabilitySet <span class="cov0" title="0">{
        return &amp;CapabilitySet{
                CapabilitySetType:                   CapabilitySetTypeBitmapCacheHostSupport,
                BitmapCacheHostSupportCapabilitySet: &amp;BitmapCacheHostSupportCapabilitySet{},
        }
}</span>

func (s *BitmapCacheHostSupportCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var (
                cacheVersion uint8
                padding1     uint8
                padding2     uint16
                err          error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;cacheVersion)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;padding1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;padding2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}

type ControlCapabilitySet struct{}

func (s *ControlCapabilitySet) Serialize() []byte <span class="cov2" title="2">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, uint16(0)) // controlFlags
        binary.Write(buf, binary.LittleEndian, uint16(0)) // remoteDetachFlag
        binary.Write(buf, binary.LittleEndian, uint16(2)) // controlInterest
        binary.Write(buf, binary.LittleEndian, uint16(2)) // detachInterest

        return buf.Bytes()
}</span>

func (s *ControlCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        padding := make([]byte, 8)

        return binary.Read(wire, binary.LittleEndian, &amp;padding)
}</span>

type WindowActivationCapabilitySet struct{}

func (s *WindowActivationCapabilitySet) Serialize() []byte <span class="cov2" title="2">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, uint16(0)) // helpKeyFlag
        binary.Write(buf, binary.LittleEndian, uint16(0)) // helpKeyIndexFlag
        binary.Write(buf, binary.LittleEndian, uint16(0)) // helpExtendedKeyFlag
        binary.Write(buf, binary.LittleEndian, uint16(0)) // windowManagerKeyFlag

        return buf.Bytes()
}</span>

func (s *WindowActivationCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        padding := make([]byte, 8)

        return binary.Read(wire, binary.LittleEndian, &amp;padding)
}</span>

type ShareCapabilitySet struct{}

func (s *ShareCapabilitySet) Serialize() []byte <span class="cov2" title="2">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, uint16(0)) // nodeID
        binary.Write(buf, binary.LittleEndian, uint16(0)) // pad2octets

        return buf.Bytes()
}</span>

func (s *ShareCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        padding := make([]byte, 4)

        return binary.Read(wire, binary.LittleEndian, &amp;padding)
}</span>

type FontCapabilitySet struct {
        fontSupportFlags uint16
}

func (s *FontCapabilitySet) Serialize() []byte <span class="cov2" title="2">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, s.fontSupportFlags)
        binary.Write(buf, binary.LittleEndian, uint16(0)) // padding

        return buf.Bytes()
}</span>

func (s *FontCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        padding := make([]byte, 2)

        err := binary.Read(wire, binary.LittleEndian, &amp;s.fontSupportFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return binary.Read(wire, binary.LittleEndian, &amp;padding)</span>
}

type MultifragmentUpdateCapabilitySet struct {
        MaxRequestSize uint32
}

func NewMultifragmentUpdateCapabilitySet() CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType:                CapabilitySetTypeMultifragmentUpdate,
                MultifragmentUpdateCapabilitySet: &amp;MultifragmentUpdateCapabilitySet{},
        }
}</span>

func (s *MultifragmentUpdateCapabilitySet) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, &amp;s.MaxRequestSize)

        return buf.Bytes()
}</span>

func (s *MultifragmentUpdateCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        return binary.Read(wire, binary.LittleEndian, &amp;s.MaxRequestSize)
}</span>

type LargePointerCapabilitySet struct {
        LargePointerSupportFlags uint16
}

func (s *LargePointerCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        return binary.Read(wire, binary.LittleEndian, &amp;s.LargePointerSupportFlags)
}</span>

type DesktopCompositionCapabilitySet struct {
        CompDeskSupportLevel uint16
}

func (s *DesktopCompositionCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        return binary.Read(wire, binary.LittleEndian, &amp;s.CompDeskSupportLevel)
}</span>

type SurfaceCommandsCapabilitySet struct {
        CmdFlags uint32
}

func (s *SurfaceCommandsCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var (
                reserved uint32
                err      error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;s.CmdFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;reserved)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type BitmapCodec struct {
        CodecGUID       [16]byte
        CodecID         uint8
        CodecProperties []byte
}

func (c *BitmapCodec) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;c.CodecGUID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;c.CodecID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var codecPropertiesLength uint16

        err = binary.Read(wire, binary.LittleEndian, &amp;codecPropertiesLength)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.CodecProperties = make([]byte, codecPropertiesLength)

        _, err = wire.Read(c.CodecProperties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type BitmapCodecsCapabilitySet struct {
        BitmapCodecArray []BitmapCodec
}

func (s *BitmapCodecsCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var (
                bitmapCodecCount uint8
                err              error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;bitmapCodecCount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.BitmapCodecArray = make([]BitmapCodec, bitmapCodecCount)

        for i := range s.BitmapCodecArray </span><span class="cov0" title="0">{
                err = s.BitmapCodecArray[i].Deserialize(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type RailCapabilitySet struct {
        RailSupportLevel uint32
}

func NewRailCapabilitySet() CapabilitySet <span class="cov0" title="0">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeRail,
                RailCapabilitySet: &amp;RailCapabilitySet{
                        RailSupportLevel: 1, // TS_RAIL_LEVEL_SUPPORTED
                },
        }
}</span>

func (s *RailCapabilitySet) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, s.RailSupportLevel)

        return buf.Bytes()
}</span>

type WindowListCapabilitySet struct {
        WndSupportLevel     uint32
        NumIconCaches       uint8
        NumIconCacheEntries uint16
}

func NewWindowListCapabilitySet() CapabilitySet <span class="cov0" title="0">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeWindow,
                WindowListCapabilitySet: &amp;WindowListCapabilitySet{
                        WndSupportLevel: 0, // TS_WINDOW_LEVEL_NOT_SUPPORTED
                },
        }
}</span>

func (s *WindowListCapabilitySet) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, s.WndSupportLevel)
        binary.Write(buf, binary.LittleEndian, s.NumIconCaches)
        binary.Write(buf, binary.LittleEndian, s.NumIconCacheEntries)

        return buf.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
)

type CapabilitySetType uint16

const (
        // CapabilitySetTypeGeneral CAPSTYPE_GENERAL
        CapabilitySetTypeGeneral CapabilitySetType = 0x0001

        // CapabilitySetTypeBitmap CAPSTYPE_BITMAP
        CapabilitySetTypeBitmap CapabilitySetType = 0x0002

        // CapabilitySetTypeOrder CAPSTYPE_ORDER
        CapabilitySetTypeOrder CapabilitySetType = 0x0003

        // CapabilitySetTypeBitmapCache CAPSTYPE_BITMAPCACHE
        CapabilitySetTypeBitmapCache CapabilitySetType = 0x0004

        // CapabilitySetTypeControl CAPSTYPE_CONTROL
        CapabilitySetTypeControl CapabilitySetType = 0x0005

        // CapabilitySetTypeActivation CAPSTYPE_ACTIVATION
        CapabilitySetTypeActivation CapabilitySetType = 0x0007

        // CapabilitySetTypePointer CAPSTYPE_POINTER
        CapabilitySetTypePointer CapabilitySetType = 0x0008

        // CapabilitySetTypeShare CAPSTYPE_SHARE
        CapabilitySetTypeShare CapabilitySetType = 0x0009

        // CapabilitySetTypeColorCache CAPSTYPE_COLORCACHE
        CapabilitySetTypeColorCache CapabilitySetType = 0x000A

        // CapabilitySetTypeSound CAPSTYPE_SOUND
        CapabilitySetTypeSound CapabilitySetType = 0x000C

        // CapabilitySetTypeInput CAPSTYPE_INPUT
        CapabilitySetTypeInput CapabilitySetType = 0x000D

        // CapabilitySetTypeFont CAPSTYPE_FONT
        CapabilitySetTypeFont CapabilitySetType = 0x000E

        // CapabilitySetTypeBrush CAPSTYPE_BRUSH
        CapabilitySetTypeBrush CapabilitySetType = 0x000F

        // CapabilitySetTypeGlyphCache CAPSTYPE_GLYPHCACHE
        CapabilitySetTypeGlyphCache CapabilitySetType = 0x0010

        // CapabilitySetTypeOffscreenBitmapCache CAPSTYPE_OFFSCREENCACHE
        CapabilitySetTypeOffscreenBitmapCache CapabilitySetType = 0x0011

        // CapabilitySetTypeBitmapCacheHostSupport CAPSTYPE_BITMAPCACHE_HOSTSUPPORT
        CapabilitySetTypeBitmapCacheHostSupport CapabilitySetType = 0x0012

        // CapabilitySetTypeBitmapCacheRev2 CAPSTYPE_BITMAPCACHE_REV2
        CapabilitySetTypeBitmapCacheRev2 CapabilitySetType = 0x0013

        // CapabilitySetTypeVirtualChannel CAPSTYPE_VIRTUALCHANNEL
        CapabilitySetTypeVirtualChannel CapabilitySetType = 0x0014

        // CapabilitySetTypeDrawNineGridCache CAPSTYPE_DRAWNINEGRIDCACHE
        CapabilitySetTypeDrawNineGridCache CapabilitySetType = 0x0015

        // CapabilitySetTypeDrawGDIPlus CAPSTYPE_DRAWGDIPLUS
        CapabilitySetTypeDrawGDIPlus CapabilitySetType = 0x0016

        // CapabilitySetTypeRail CAPSTYPE_RAIL
        CapabilitySetTypeRail CapabilitySetType = 0x0017

        // CapabilitySetTypeWindow CAPSTYPE_WINDOW
        CapabilitySetTypeWindow CapabilitySetType = 0x0018

        // CapabilitySetTypeCompDesk CAPSETTYPE_COMPDESK
        CapabilitySetTypeCompDesk CapabilitySetType = 0x0019

        // CapabilitySetTypeMultifragmentUpdate CAPSETTYPE_MULTIFRAGMENTUPDATE
        CapabilitySetTypeMultifragmentUpdate CapabilitySetType = 0x001A

        // CapabilitySetTypeLargePointer CAPSETTYPE_LARGE_POINTER
        CapabilitySetTypeLargePointer CapabilitySetType = 0x001B

        // CapabilitySetTypeSurfaceCommands CAPSETTYPE_SURFACE_COMMANDS
        CapabilitySetTypeSurfaceCommands CapabilitySetType = 0x001C

        // CapabilitySetTypeBitmapCodecs CAPSETTYPE_BITMAP_CODECS
        CapabilitySetTypeBitmapCodecs CapabilitySetType = 0x001D

        // CapabilitySetTypeFrameAcknowledge CAPSSETTYPE_FRAME_ACKNOWLEDGE
        CapabilitySetTypeFrameAcknowledge CapabilitySetType = 0x001E
)

type CapabilitySet struct {
        CapabilitySetType                   CapabilitySetType
        GeneralCapabilitySet                *GeneralCapabilitySet
        BitmapCapabilitySet                 *BitmapCapabilitySet
        OrderCapabilitySet                  *OrderCapabilitySet
        BitmapCacheCapabilitySetRev1        *BitmapCacheCapabilitySetRev1
        BitmapCacheCapabilitySetRev2        *BitmapCacheCapabilitySetRev2
        ColorCacheCapabilitySet             *ColorCacheCapabilitySet
        PointerCapabilitySet                *PointerCapabilitySet
        InputCapabilitySet                  *InputCapabilitySet
        BrushCapabilitySet                  *BrushCapabilitySet
        GlyphCacheCapabilitySet             *GlyphCacheCapabilitySet
        OffscreenBitmapCacheCapabilitySet   *OffscreenBitmapCacheCapabilitySet
        VirtualChannelCapabilitySet         *VirtualChannelCapabilitySet
        DrawNineGridCacheCapabilitySet      *DrawNineGridCacheCapabilitySet
        DrawGDIPlusCapabilitySet            *DrawGDIPlusCapabilitySet
        SoundCapabilitySet                  *SoundCapabilitySet
        BitmapCacheHostSupportCapabilitySet *BitmapCacheHostSupportCapabilitySet
        ControlCapabilitySet                *ControlCapabilitySet
        WindowActivationCapabilitySet       *WindowActivationCapabilitySet
        ShareCapabilitySet                  *ShareCapabilitySet
        FontCapabilitySet                   *FontCapabilitySet
        MultifragmentUpdateCapabilitySet    *MultifragmentUpdateCapabilitySet
        LargePointerCapabilitySet           *LargePointerCapabilitySet
        DesktopCompositionCapabilitySet     *DesktopCompositionCapabilitySet
        SurfaceCommandsCapabilitySet        *SurfaceCommandsCapabilitySet
        BitmapCodecsCapabilitySet           *BitmapCodecsCapabilitySet
        RailCapabilitySet                   *RailCapabilitySet
        WindowListCapabilitySet             *WindowListCapabilitySet
        FrameAcknowledgeCapabilitySet       *FrameAcknowledgeCapabilitySet
}

func (set *CapabilitySet) Serialize() []byte <span class="cov10" title="46">{
        var data []byte

        switch set.CapabilitySetType </span>{
        case CapabilitySetTypeGeneral:<span class="cov3" title="3">
                data = set.GeneralCapabilitySet.Serialize()</span>
        case CapabilitySetTypeBitmap:<span class="cov3" title="3">
                data = set.BitmapCapabilitySet.Serialize()</span>
        case CapabilitySetTypeOrder:<span class="cov3" title="3">
                data = set.OrderCapabilitySet.Serialize()</span>
        case CapabilitySetTypeBitmapCache:<span class="cov1" title="1">
                data = set.BitmapCacheCapabilitySetRev1.Serialize()</span>
        case CapabilitySetTypeBitmapCacheRev2:<span class="cov2" title="2">
                data = set.BitmapCacheCapabilitySetRev2.Serialize()</span>
        case CapabilitySetTypeColorCache:<span class="cov2" title="2">
                data = set.ColorCacheCapabilitySet.Serialize()</span>
        case CapabilitySetTypeActivation:<span class="cov2" title="2">
                data = set.WindowActivationCapabilitySet.Serialize()</span>
        case CapabilitySetTypeControl:<span class="cov2" title="2">
                data = set.ControlCapabilitySet.Serialize()</span>
        case CapabilitySetTypePointer:<span class="cov2" title="2">
                data = set.PointerCapabilitySet.Serialize()</span>
        case CapabilitySetTypeInput:<span class="cov3" title="3">
                data = set.InputCapabilitySet.Serialize()</span>
        case CapabilitySetTypeBrush:<span class="cov3" title="3">
                data = set.BrushCapabilitySet.Serialize()</span>
        case CapabilitySetTypeGlyphCache:<span class="cov3" title="3">
                data = set.GlyphCacheCapabilitySet.Serialize()</span>
        case CapabilitySetTypeOffscreenBitmapCache:<span class="cov3" title="3">
                data = set.OffscreenBitmapCacheCapabilitySet.Serialize()</span>
        case CapabilitySetTypeVirtualChannel:<span class="cov3" title="3">
                data = set.VirtualChannelCapabilitySet.Serialize()</span>
        case CapabilitySetTypeSound:<span class="cov3" title="3">
                data = set.SoundCapabilitySet.Serialize()</span>
        case CapabilitySetTypeShare:<span class="cov2" title="2">
                data = set.ShareCapabilitySet.Serialize()</span>
        case CapabilitySetTypeFont:<span class="cov2" title="2">
                data = set.FontCapabilitySet.Serialize()</span>
        case CapabilitySetTypeDrawNineGridCache:<span class="cov2" title="2">
                data = set.DrawNineGridCacheCapabilitySet.Serialize()</span>
        case CapabilitySetTypeDrawGDIPlus:<span class="cov2" title="2">
                data = set.DrawGDIPlusCapabilitySet.Serialize()</span>
        case CapabilitySetTypeMultifragmentUpdate:<span class="cov0" title="0">
                data = set.MultifragmentUpdateCapabilitySet.Serialize()</span>
        case CapabilitySetTypeRail:<span class="cov0" title="0">
                data = set.RailCapabilitySet.Serialize()</span>
        case CapabilitySetTypeWindow:<span class="cov0" title="0">
                data = set.WindowListCapabilitySet.Serialize()</span>
        case CapabilitySetTypeFrameAcknowledge:<span class="cov0" title="0">
                data = set.FrameAcknowledgeCapabilitySet.Serialize()</span>
        }

        <span class="cov10" title="46">buf := new(bytes.Buffer)

        lengthCapability := uint16(4 + len(data))

        _ = binary.Write(buf, binary.LittleEndian, set.CapabilitySetType)
        _ = binary.Write(buf, binary.LittleEndian, lengthCapability)
        buf.Write(data)

        return buf.Bytes()</span>
}

func (set *CapabilitySet) DeserializeQuick(wire io.Reader) error <span class="cov7" title="17">{
        var (
                lengthCapability uint16
                err              error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;set.CapabilitySetType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="17">err = binary.Read(wire, binary.LittleEndian, &amp;lengthCapability)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="17">data := make([]byte, lengthCapability-4)
        if _, err = wire.Read(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="17">return nil</span>
}

func (set *CapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var (
                lengthCapability uint16
                err              error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;set.CapabilitySetType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;lengthCapability)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch set.CapabilitySetType </span>{
        case CapabilitySetTypeGeneral:<span class="cov0" title="0">
                set.GeneralCapabilitySet = &amp;GeneralCapabilitySet{}

                return set.GeneralCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeBitmap:<span class="cov0" title="0">
                set.BitmapCapabilitySet = &amp;BitmapCapabilitySet{}

                return set.BitmapCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeOrder:<span class="cov0" title="0">
                set.OrderCapabilitySet = &amp;OrderCapabilitySet{}

                return set.OrderCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeBitmapCache:<span class="cov0" title="0">
                set.BitmapCacheCapabilitySetRev1 = &amp;BitmapCacheCapabilitySetRev1{}

                return set.BitmapCacheCapabilitySetRev1.Deserialize(wire)</span>
        case CapabilitySetTypeBitmapCacheRev2:<span class="cov0" title="0">
                set.BitmapCacheCapabilitySetRev2 = &amp;BitmapCacheCapabilitySetRev2{}

                return set.BitmapCacheCapabilitySetRev2.Deserialize(wire)</span>
        case CapabilitySetTypeColorCache:<span class="cov0" title="0">
                set.ColorCacheCapabilitySet = &amp;ColorCacheCapabilitySet{}

                return set.ColorCacheCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypePointer:<span class="cov0" title="0">
                set.PointerCapabilitySet = &amp;PointerCapabilitySet{
                        lengthCapability: lengthCapability - 4,
                }

                return set.PointerCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeInput:<span class="cov0" title="0">
                set.InputCapabilitySet = &amp;InputCapabilitySet{}

                return set.InputCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeBrush:<span class="cov0" title="0">
                set.BrushCapabilitySet = &amp;BrushCapabilitySet{}

                return set.BrushCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeGlyphCache:<span class="cov0" title="0">
                set.GlyphCacheCapabilitySet = &amp;GlyphCacheCapabilitySet{}

                return set.GlyphCacheCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeOffscreenBitmapCache:<span class="cov0" title="0">
                set.OffscreenBitmapCacheCapabilitySet = &amp;OffscreenBitmapCacheCapabilitySet{}

                return set.OffscreenBitmapCacheCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeVirtualChannel:<span class="cov0" title="0">
                set.VirtualChannelCapabilitySet = &amp;VirtualChannelCapabilitySet{}

                return set.VirtualChannelCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeDrawNineGridCache:<span class="cov0" title="0">
                set.DrawNineGridCacheCapabilitySet = &amp;DrawNineGridCacheCapabilitySet{}

                return set.DrawNineGridCacheCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeDrawGDIPlus:<span class="cov0" title="0">
                set.DrawGDIPlusCapabilitySet = &amp;DrawGDIPlusCapabilitySet{}

                return set.DrawGDIPlusCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeSound:<span class="cov0" title="0">
                set.SoundCapabilitySet = &amp;SoundCapabilitySet{}

                return set.SoundCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeFrameAcknowledge:<span class="cov0" title="0">
                set.FrameAcknowledgeCapabilitySet = &amp;FrameAcknowledgeCapabilitySet{}

                return set.FrameAcknowledgeCapabilitySet.Deserialize(wire)</span>
        }

        <span class="cov0" title="0">data := make([]byte, lengthCapability-4)
        if _, err = wire.Read(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Frame Acknowledge Capability Set - for RDP 8.0+
type FrameAcknowledgeCapabilitySet struct {
        MaxUnacknowledgedFrames uint32
}

func (s *FrameAcknowledgeCapabilitySet) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        binary.Write(buf, binary.LittleEndian, s.MaxUnacknowledgedFrames)
        return buf.Bytes()
}</span>

func (s *FrameAcknowledgeCapabilitySet) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        return binary.Read(wire, binary.LittleEndian, &amp;s.MaxUnacknowledgedFrames)
}</span>

func NewFrameAcknowledgeCapabilitySet() CapabilitySet <span class="cov1" title="1">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeFrameAcknowledge,
                FrameAcknowledgeCapabilitySet: &amp;FrameAcknowledgeCapabilitySet{
                        MaxUnacknowledgedFrames: 2, // Default value for better performance
                },
        }
}</span>

type ServerDemandActive struct {
        ShareControlHeader         ShareControlHeader
        ShareID                    uint32
        LengthSourceDescriptor     uint16
        LengthCombinedCapabilities uint16
        SourceDescriptor           []byte
        NumberCapabilities         uint16
        pad2Octets                 uint16
        CapabilitySets             []CapabilitySet
        SessionId                  uint32
}

func (pdu *ServerDemandActive) Deserialize(wire io.Reader) error <span class="cov1" title="1">{
        err := pdu.ShareControlHeader.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.ShareID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.LengthSourceDescriptor)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.LengthCombinedCapabilities)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">pdu.SourceDescriptor = make([]byte, pdu.LengthSourceDescriptor)

        _, err = wire.Read(pdu.SourceDescriptor)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.NumberCapabilities)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.pad2Octets)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">pdu.CapabilitySets = make([]CapabilitySet, 0, pdu.NumberCapabilities)

        for i := uint16(0); i &lt; pdu.NumberCapabilities; i++ </span><span class="cov7" title="17">{
                var capabilitySet CapabilitySet

                if err = capabilitySet.DeserializeQuick(wire); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov7" title="17">pdu.CapabilitySets = append(pdu.CapabilitySets, capabilitySet)</span>
        }

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.SessionId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type ClientConfirmActive struct {
        ShareControlHeader ShareControlHeader
        ShareID            uint32
        SourceDescriptor   []byte
        CapabilitySets     []CapabilitySet
}

func NewClientConfirmActive(shareID uint32, userId, desktopWidth, desktopHeight uint16, withRemoteApp bool) *ClientConfirmActive <span class="cov1" title="1">{
        pdu := ClientConfirmActive{
                ShareControlHeader: ShareControlHeader{
                        PDUType:   TypeConfirmActive,
                        PDUSource: userId,
                },
                ShareID:          shareID,
                SourceDescriptor: []byte(projectName),
                CapabilitySets: []CapabilitySet{
                        NewGeneralCapabilitySet(),
                        NewBitmapCapabilitySet(desktopWidth, desktopHeight),
                        NewOrderCapabilitySet(),
                        NewBitmapCacheCapabilitySetRev1(),
                        NewPointerCapabilitySet(),
                        NewInputCapabilitySet(),
                        NewBrushCapabilitySet(),
                        NewGlyphCacheCapabilitySet(),
                        NewOffscreenBitmapCacheCapabilitySet(),
                        NewVirtualChannelCapabilitySet(),
                        NewSoundCapabilitySet(),
                        NewMultifragmentUpdateCapabilitySet(),
                        NewFrameAcknowledgeCapabilitySet(),
                },
        }

        if withRemoteApp </span><span class="cov0" title="0">{
                pdu.CapabilitySets = append(pdu.CapabilitySets, NewRailCapabilitySet(), NewWindowListCapabilitySet())
        }</span>

        <span class="cov1" title="1">return &amp;pdu</span>
}

func (pdu *ClientConfirmActive) Serialize() []byte <span class="cov1" title="1">{
        capBuf := bytes.Buffer{}

        for _, set := range pdu.CapabilitySets </span><span class="cov7" title="18">{
                capBuf.Write(set.Serialize())
        }</span>

        <span class="cov1" title="1">lengthSourceDescriptor := uint16(len(pdu.SourceDescriptor))
        lengthCombinedCapabilities := uint16(4 + capBuf.Len())

        pdu.ShareControlHeader.PDUType = TypeConfirmActive
        pdu.ShareControlHeader.TotalLength = 6 + 4 + 2 + 2 + 2 + lengthSourceDescriptor + lengthCombinedCapabilities

        buf := new(bytes.Buffer)

        buf.Write(pdu.ShareControlHeader.Serialize())
        _ = binary.Write(buf, binary.LittleEndian, pdu.ShareID)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x03EA)) // originatorID
        _ = binary.Write(buf, binary.LittleEndian, lengthSourceDescriptor)
        _ = binary.Write(buf, binary.LittleEndian, lengthCombinedCapabilities)

        buf.Write(pdu.SourceDescriptor)

        _ = binary.Write(buf, binary.LittleEndian, uint16(len(pdu.CapabilitySets)))
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // padding

        buf.Write(capBuf.Bytes())

        return buf.Bytes()</span>
}

func (pdu *ClientConfirmActive) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = pdu.ShareControlHeader.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.ShareID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var originatorID uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;originatorID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var lengthSourceDescriptor uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;lengthSourceDescriptor)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var lengthCombinedCapabilities uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;lengthCombinedCapabilities)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pdu.SourceDescriptor = make([]byte, lengthSourceDescriptor)
        _, err = wire.Read(pdu.SourceDescriptor)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var numberCapabilities uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;numberCapabilities)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pdu.CapabilitySets = make([]CapabilitySet, numberCapabilities)

        for i := range pdu.CapabilitySets </span><span class="cov0" title="0">{
                err = pdu.CapabilitySets[i].Deserialize(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
)

type MessageType uint16

const (
        MessageTypeSync MessageType = 1
)

type SynchronizePDUData struct {
        MessageType MessageType
}

func NewSynchronize(shareID uint32, userId uint16) *Data <span class="cov5" title="2">{
        return &amp;Data{
                ShareDataHeader: *newShareDataHeader(shareID, userId, TypeData, Type2Synchronize),
                SynchronizePDUData: &amp;SynchronizePDUData{
                        MessageType: MessageTypeSync,
                },
        }
}</span>

const ServerChannelID uint16 = 1002

func (pdu *SynchronizePDUData) Serialize() []byte <span class="cov5" title="2">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(pdu.MessageType))
        _ = binary.Write(buf, binary.LittleEndian, ServerChannelID) // targetUser

        return buf.Bytes()
}</span>

func (pdu *SynchronizePDUData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;pdu.MessageType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var targetUser uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;targetUser)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type ControlAction uint16

const (
        // ControlActionRequestControl CTRLACTION_REQUEST_CONTROL
        ControlActionRequestControl ControlAction = 0x0001

        // ControlActionGrantedControl CTRLACTION_GRANTED_CONTROL
        ControlActionGrantedControl ControlAction = 0x0002

        // ControlActionDetach CTRLACTION_DETACH
        ControlActionDetach ControlAction = 0x0003

        // ControlActionCooperate CTRLACTION_COOPERATE
        ControlActionCooperate ControlAction = 0x0004
)

type ControlPDUData struct {
        Action    ControlAction
        GrantID   uint16
        ControlID uint32
}

func NewControl(shareID uint32, userId uint16, action ControlAction) *Data <span class="cov10" title="4">{
        return &amp;Data{
                ShareDataHeader: *newShareDataHeader(shareID, userId, TypeData, Type2Control),
                ControlPDUData: &amp;ControlPDUData{
                        Action: action,
                },
        }
}</span>

func (pdu *ControlPDUData) Serialize() []byte <span class="cov10" title="4">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(pdu.Action))
        _ = binary.Write(buf, binary.LittleEndian, pdu.GrantID)
        _ = binary.Write(buf, binary.LittleEndian, pdu.ControlID)

        return buf.Bytes()
}</span>

func (pdu *ControlPDUData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;pdu.Action)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.GrantID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.ControlID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type FontListPDUData struct{}

func NewFontList(shareID uint32, userId uint16) *Data <span class="cov5" title="2">{
        return &amp;Data{
                ShareDataHeader: *newShareDataHeader(shareID, userId, TypeData, Type2Fontlist),
                FontListPDUData: &amp;FontListPDUData{},
        }
}</span>

func (pdu *FontListPDUData) Serialize() []byte <span class="cov5" title="2">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // numberFonts
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // totalNumFonts
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0003)) // listFlags = FONTLIST_FIRST | FONTLIST_LAST
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0032)) // entrySize

        return buf.Bytes()
}</span>

type FontMapPDUData struct{}

func (pdu *FontMapPDUData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var (
                numberEntries   uint16
                totalNumEntries uint16
                mapFlags        uint16
                entrySize       uint16
                err             error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;numberEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;totalNumEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;mapFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;entrySize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
        "strings"
)

type NegotiationType uint8

const (
        // NegotiationTypeRequest TYPE_RDP_NEG_REQ
        NegotiationTypeRequest NegotiationType = 0x01

        // NegotiationTypeResponse TYPE_RDP_NEG_RSP
        NegotiationTypeResponse NegotiationType = 0x02

        // NegotiationTypeFailure TYPE_RDP_NEG_FAILURE
        NegotiationTypeFailure NegotiationType = 0x03
)

func (t NegotiationType) IsRequest() bool <span class="cov0" title="0">{
        return t == NegotiationTypeRequest
}</span>

func (t NegotiationType) IsResponse() bool <span class="cov0" title="0">{
        return t == NegotiationTypeResponse
}</span>

func (t NegotiationType) IsFailure() bool <span class="cov0" title="0">{
        return t == NegotiationTypeFailure
}</span>

// NegotiationRequestFlag Protocol flags.
type NegotiationRequestFlag uint8

const (
        // NegReqFlagRestrictedAdminModeRequired RESTRICTED_ADMIN_MODE_REQUIRED
        NegReqFlagRestrictedAdminModeRequired NegotiationRequestFlag = 0x01

        // NegReqFlagRedirectedAuthenticationModeRequired REDIRECTED_AUTHENTICATION_MODE_REQUIRED
        NegReqFlagRedirectedAuthenticationModeRequired NegotiationRequestFlag = 0x02

        // NegReqFlagCorrelationInfoPresent CORRELATION_INFO_PRESENT
        NegReqFlagCorrelationInfoPresent NegotiationRequestFlag = 0x08
)

func (f NegotiationRequestFlag) IsRestrictedAdminModeRequired() bool <span class="cov0" title="0">{
        return f&amp;NegReqFlagRestrictedAdminModeRequired == NegReqFlagRestrictedAdminModeRequired
}</span>

func (f NegotiationRequestFlag) IsRedirectedAuthenticationModeRequired() bool <span class="cov0" title="0">{
        return f&amp;NegReqFlagRedirectedAuthenticationModeRequired == NegReqFlagRedirectedAuthenticationModeRequired
}</span>

func (f NegotiationRequestFlag) IsCorrelationInfoPresent() bool <span class="cov8" title="1">{
        return f&amp;NegReqFlagCorrelationInfoPresent == NegReqFlagCorrelationInfoPresent
}</span>

// NegotiationProtocol Supported security protocol.
type NegotiationProtocol uint32

const (
        // NegotiationProtocolRDP PROTOCOL_RDP
        NegotiationProtocolRDP NegotiationProtocol = 0x00000000

        // NegotiationProtocolSSL PROTOCOL_SSL
        NegotiationProtocolSSL NegotiationProtocol = 0x00000001

        // NegotiationProtocolHybrid PROTOCOL_HYBRID
        NegotiationProtocolHybrid NegotiationProtocol = 0x00000002

        // NegotiationProtocolRDSTLS PROTOCOL_RDSTLS
        NegotiationProtocolRDSTLS NegotiationProtocol = 0x00000004

        // NegotiationProtocolHybridEx PROTOCOL_HYBRID_EX
        NegotiationProtocolHybridEx NegotiationProtocol = 0x00000008
)

func (p NegotiationProtocol) IsRDP() bool <span class="cov0" title="0">{
        return p == NegotiationProtocolRDP
}</span>

func (p NegotiationProtocol) IsSSL() bool <span class="cov0" title="0">{
        return p == NegotiationProtocolSSL
}</span>

func (p NegotiationProtocol) IsHybrid() bool <span class="cov0" title="0">{
        return p == NegotiationProtocolHybrid
}</span>

func (p NegotiationProtocol) IsRDSTLS() bool <span class="cov0" title="0">{
        return p == NegotiationProtocolRDSTLS
}</span>

func (p NegotiationProtocol) IsHybridEx() bool <span class="cov0" title="0">{
        return p == NegotiationProtocolHybridEx
}</span>

// NegotiationRequest RDP Negotiation Request (RDP_NEG_REQ).
type NegotiationRequest struct {
        Flags              NegotiationRequestFlag // Protocol flags
        RequestedProtocols NegotiationProtocol    // supported security protocols
}

func (r NegotiationRequest) Serialize() []byte <span class="cov8" title="1">{
        const negReqLen = uint16(8)

        buf := bytes.NewBuffer(make([]byte, 0, negReqLen))

        buf.Write([]byte{
                byte(NegotiationTypeRequest), // type TYPE_RDP_NEG_REQ
                byte(r.Flags),                // flags
        })

        // length (always 8 bytes)
        _ = binary.Write(buf, binary.LittleEndian, negReqLen)

        // requestedProtocols
        _ = binary.Write(buf, binary.LittleEndian, r.RequestedProtocols)

        return buf.Bytes()
}</span>

// CorrelationInfo RDP Correlation Info (RDP_NEG_CORRELATION_INFO).
type CorrelationInfo struct {
        correlationID []byte
}

func (i CorrelationInfo) SetCorrelationID(correlationID []byte) error <span class="cov0" title="0">{
        if len(correlationID) != 16 </span><span class="cov0" title="0">{
                return ErrInvalidCorrelationID
        }</span>

        // The first byte in the array SHOULD NOT have a value of 0x00 or 0xF4
        <span class="cov0" title="0">if correlationID[0] == 0x00 || correlationID[0] == 0xF4 </span><span class="cov0" title="0">{
                return ErrInvalidCorrelationID
        }</span>

        // value 0x0D SHOULD NOT be contained in any of the bytes
        <span class="cov0" title="0">for _, b := range correlationID </span><span class="cov0" title="0">{
                if b == 0x0D </span><span class="cov0" title="0">{
                        return ErrInvalidCorrelationID
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (i CorrelationInfo) Serialize() []byte <span class="cov0" title="0">{
        const corrInfoLen = uint16(36)

        buf := bytes.NewBuffer(make([]byte, 0, corrInfoLen))

        buf.Write([]byte{
                0x06, // type TYPE_RDP_CORRELATION_INFO
                0x00, // flags
        })

        // length (always 36 bytes)
        _ = binary.Write(buf, binary.LittleEndian, corrInfoLen)

        // correlationId
        if i.correlationID == nil </span><span class="cov0" title="0">{
                buf.Write(make([]byte, 16))
        }</span> else<span class="cov0" title="0"> {
                buf.Write(i.correlationID)
        }</span>

        // reserved
        <span class="cov0" title="0">buf.Write(make([]byte, 16))

        return buf.Bytes()</span>
}

// NegotiationResponseFlag RDP Negotiation Response flags
type NegotiationResponseFlag uint8

const (
        // NegotiationResponseFlagECDBSupported EXTENDED_CLIENT_DATA_SUPPORTED
        NegotiationResponseFlagECDBSupported NegotiationResponseFlag = 0x01

        // NegotiationResponseFlagGFXSupported DYNVC_GFX_PROTOCOL_SUPPORTED
        NegotiationResponseFlagGFXSupported NegotiationResponseFlag = 0x02

        // NegotiationResponseFlagAdminModeSupported RESTRICTED_ADMIN_MODE_SUPPORTED
        NegotiationResponseFlagAdminModeSupported NegotiationResponseFlag = 0x08

        // NegotiationResponseFlagAuthModeSupported REDIRECTED_AUTHENTICATION_MODE_SUPPORTED
        NegotiationResponseFlagAuthModeSupported NegotiationResponseFlag = 0x10
)

func (f NegotiationResponseFlag) IsExtendedClientDataSupported() bool <span class="cov0" title="0">{
        return f&amp;NegotiationResponseFlagECDBSupported == NegotiationResponseFlagECDBSupported
}</span>

func (f NegotiationResponseFlag) IsGFXProtocolSupported() bool <span class="cov0" title="0">{
        return f&amp;NegotiationResponseFlagGFXSupported == NegotiationResponseFlagGFXSupported
}</span>

func (f NegotiationResponseFlag) IsRestrictedAdminModeSupported() bool <span class="cov0" title="0">{
        return f&amp;NegotiationResponseFlagAdminModeSupported == NegotiationResponseFlagAdminModeSupported
}</span>

func (f NegotiationResponseFlag) IsRedirectedAuthModeSupported() bool <span class="cov0" title="0">{
        return f&amp;NegotiationResponseFlagAuthModeSupported == NegotiationResponseFlagAuthModeSupported
}</span>

func (f NegotiationResponseFlag) String() string <span class="cov0" title="0">{
        var features []string

        switch </span>{
        case f.IsExtendedClientDataSupported():<span class="cov0" title="0">
                features = append(features, "EXTENDED_CLIENT_DATA_SUPPORTED")</span>
        case f.IsGFXProtocolSupported():<span class="cov0" title="0">
                features = append(features, "DYNVC_GFX_PROTOCOL_SUPPORTED")</span>
        case f.IsRestrictedAdminModeSupported():<span class="cov0" title="0">
                features = append(features, "RESTRICTED_ADMIN_MODE_SUPPORTED")</span>
        case f.IsRedirectedAuthModeSupported():<span class="cov0" title="0">
                features = append(features, "REDIRECTED_AUTHENTICATION_MODE_SUPPORTED")</span>
        }

        <span class="cov0" title="0">return strings.Join(features, ", ")</span>
}

// NegotiationFailureCode RDP Negotiation Failure failureCode
type NegotiationFailureCode uint32

const (
        // NegotiationFailureCodeSSLRequired SSL_REQUIRED_BY_SERVER
        NegotiationFailureCodeSSLRequired NegotiationFailureCode = 0x00000001

        // NegotiationFailureCodeSSLNotAllowed SSL_NOT_ALLOWED_BY_SERVER
        NegotiationFailureCodeSSLNotAllowed NegotiationFailureCode = 0x00000002

        // NegotiationFailureCodeSSLCertNotOnServer SSL_CERT_NOT_ON_SERVER
        NegotiationFailureCodeSSLCertNotOnServer NegotiationFailureCode = 0x00000003

        // NegotiationFailureCodeInconsistentFlags INCONSISTENT_FLAGS
        NegotiationFailureCodeInconsistentFlags NegotiationFailureCode = 0x00000004

        // NegotiationFailureCodeHybridRequired HYBRID_REQUIRED_BY_SERVER
        NegotiationFailureCodeHybridRequired NegotiationFailureCode = 0x00000005

        // NegotiationFailureCodeSSLWithUserAuthRequired SSL_WITH_USER_AUTH_REQUIRED_BY_SERVER
        NegotiationFailureCodeSSLWithUserAuthRequired NegotiationFailureCode = 0x00000006
)

var NegotiationFailureCodeMap = map[NegotiationFailureCode]string{
        NegotiationFailureCodeSSLRequired:             "SSL_REQUIRED_BY_SERVER",
        NegotiationFailureCodeSSLNotAllowed:           "SSL_NOT_ALLOWED_BY_SERVER",
        NegotiationFailureCodeSSLCertNotOnServer:      "SSL_CERT_NOT_ON_SERVER",
        NegotiationFailureCodeInconsistentFlags:       "INCONSISTENT_FLAGS",
        NegotiationFailureCodeHybridRequired:          "HYBRID_REQUIRED_BY_SERVER",
        NegotiationFailureCodeSSLWithUserAuthRequired: "SSL_WITH_USER_AUTH_REQUIRED_BY_SERVER",
}

func (c NegotiationFailureCode) String() string <span class="cov0" title="0">{
        return NegotiationFailureCodeMap[c]
}</span>

// ClientConnectionRequest Client X.224 Connection Request PDU
type ClientConnectionRequest struct {
        RoutingToken       string // one of RoutingToken or Cookie ending CR+LF
        Cookie             string
        NegotiationRequest NegotiationRequest // RDP Negotiation Request
        CorrelationInfo    CorrelationInfo    // Correlation Info
}

func (pdu *ClientConnectionRequest) Serialize() []byte <span class="cov8" title="1">{
        const (
                CRLF         = "\r\n"
                cookieHeader = "Cookie: mstshash="
        )

        buf := new(bytes.Buffer)

        // routingToken or cookie
        if pdu.RoutingToken != "" </span><span class="cov0" title="0">{
                buf.WriteString(strings.Trim(pdu.RoutingToken, CRLF) + CRLF)
        }</span> else<span class="cov8" title="1"> if pdu.Cookie != "" </span><span class="cov8" title="1">{
                buf.WriteString(cookieHeader + strings.Trim(pdu.Cookie, CRLF) + CRLF)
        }</span>

        // rdpNegReq
        <span class="cov8" title="1">buf.Write(pdu.NegotiationRequest.Serialize())

        // rdpCorrelationInfo
        if pdu.NegotiationRequest.Flags.IsCorrelationInfoPresent() </span><span class="cov0" title="0">{
                buf.Write(pdu.CorrelationInfo.Serialize())
        }</span>

        <span class="cov8" title="1">return buf.Bytes()</span>
}

type ServerConnectionConfirm struct {
        Type   NegotiationType
        Flags  NegotiationResponseFlag // RDP Negotiation Response flags
        length uint16
        data   uint32 // RDP Negotiation Response selectedProtocol or RDP Negotiation Failure failureCode
}

func (pdu *ServerConnectionConfirm) SelectedProtocol() NegotiationProtocol <span class="cov0" title="0">{
        return NegotiationProtocol(pdu.data)
}</span>

func (pdu *ServerConnectionConfirm) FailureCode() NegotiationFailureCode <span class="cov0" title="0">{
        return NegotiationFailureCode(pdu.data)
}</span>

func (pdu *ServerConnectionConfirm) Deserialize(wire io.Reader) error <span class="cov8" title="1">{
        err := binary.Read(wire, binary.LittleEndian, &amp;pdu.Type)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.Flags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.length)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
)

type Type uint16

const (
        // TypeDemandActive PDUTYPE_DEMANDACTIVEPDU
        TypeDemandActive Type = 0x11

        // TypeConfirmActive PDUTYPE_CONFIRMACTIVEPDU
        TypeConfirmActive Type = 0x13

        // TypeDeactivateAll PDUTYPE_DEACTIVATEALLPDU
        TypeDeactivateAll Type = 0x16

        // TypeData PDUTYPE_DATAPDU
        TypeData Type = 0x17
)

func (t Type) IsDemandActive() bool <span class="cov0" title="0">{
        return t == TypeDemandActive
}</span>

func (t Type) IsConfirmActive() bool <span class="cov0" title="0">{
        return t == TypeConfirmActive
}</span>

func (t Type) IsDeactivateAll() bool <span class="cov0" title="0">{
        return t == TypeDeactivateAll
}</span>

func (t Type) IsData() bool <span class="cov0" title="0">{
        return t == TypeData
}</span>

type ShareControlHeader struct {
        TotalLength uint16
        PDUType     Type
        PDUSource   uint16
}

func newShareControlHeader(pduType Type, pduSource uint16) *ShareControlHeader <span class="cov9" title="8">{
        return &amp;ShareControlHeader{
                PDUType:   pduType,
                PDUSource: pduSource,
        }
}</span>

func (header *ShareControlHeader) Serialize() []byte <span class="cov10" title="9">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, header.TotalLength)
        binary.Write(buf, binary.LittleEndian, uint16(header.PDUType))
        binary.Write(buf, binary.LittleEndian, header.PDUSource)

        return buf.Bytes()
}</span>

func (header *ShareControlHeader) Deserialize(wire io.Reader) error <span class="cov1" title="1">{
        binary.Read(wire, binary.LittleEndian, &amp;header.TotalLength)
        binary.Read(wire, binary.LittleEndian, &amp;header.PDUType)
        binary.Read(wire, binary.LittleEndian, &amp;header.PDUSource)

        return nil
}</span>

type Type2 uint8

const (
        // Type2Update PDUTYPE2_UPDATE
        Type2Update Type2 = 0x02

        // Type2Control PDUTYPE2_CONTROL
        Type2Control Type2 = 0x14

        // Type2Pointer PDUTYPE2_POINTER
        Type2Pointer Type2 = 0x1B

        // Type2Input PDUTYPE2_INPUT
        Type2Input Type2 = 0x1C

        // Type2Synchronize PDUTYPE2_SYNCHRONIZE
        Type2Synchronize Type2 = 0x1F

        // Type2Fontlist PDUTYPE2_FONTLIST
        Type2Fontlist Type2 = 0x27

        // Type2Fontmap PDUTYPE2_FONTMAP
        Type2Fontmap Type2 = 0x28

        // Type2ErrorInfo PDUTYPE2_SET_ERROR_INFO_PDU
        Type2ErrorInfo Type2 = 0x2f

        // Type2SaveSessionInfo PDUTYPE2_SAVE_SESSION_INFO
        Type2SaveSessionInfo Type2 = 0x26
)

func (t Type2) IsUpdate() bool <span class="cov0" title="0">{
        return t == Type2Update
}</span>

func (t Type2) IsControl() bool <span class="cov8" title="6">{
        return t == Type2Control
}</span>

func (t Type2) IsPointer() bool <span class="cov0" title="0">{
        return t == Type2Pointer
}</span>

func (t Type2) IsInput() bool <span class="cov0" title="0">{
        return t == Type2Input
}</span>

func (t Type2) IsSynchronize() bool <span class="cov9" title="8">{
        return t == Type2Synchronize
}</span>

func (t Type2) IsFontlist() bool <span class="cov3" title="2">{
        return t == Type2Fontlist
}</span>

func (t Type2) IsErrorInfo() bool <span class="cov0" title="0">{
        return t == Type2ErrorInfo
}</span>

func (t Type2) IsFontmap() bool <span class="cov0" title="0">{
        return t == Type2Fontmap
}</span>

func (t Type2) IsSaveSessionInfo() bool <span class="cov0" title="0">{
        return t == Type2SaveSessionInfo
}</span>

type ShareDataHeader struct {
        ShareControlHeader ShareControlHeader
        ShareID            uint32
        StreamID           uint8
        UncompressedLength uint16
        PDUType2           Type2
        CompressedType     uint8
        CompressedLength   uint16
}

func newShareDataHeader(shareID uint32, pduSource uint16, pduType Type, pduType2 Type2) *ShareDataHeader <span class="cov9" title="8">{
        return &amp;ShareDataHeader{
                ShareControlHeader: *newShareControlHeader(pduType, pduSource),
                ShareID:            shareID,
                StreamID:           0x01, // STREAM_LOW
                PDUType2:           pduType2,
        }
}</span>

func (header *ShareDataHeader) Serialize() []byte <span class="cov9" title="8">{
        buf := new(bytes.Buffer)

        buf.Write(header.ShareControlHeader.Serialize())
        binary.Write(buf, binary.LittleEndian, header.ShareID)
        binary.Write(buf, binary.LittleEndian, uint8(0)) // padding
        binary.Write(buf, binary.LittleEndian, header.StreamID)
        binary.Write(buf, binary.LittleEndian, header.UncompressedLength)
        binary.Write(buf, binary.LittleEndian, uint8(header.PDUType2))
        binary.Write(buf, binary.LittleEndian, header.CompressedType)
        binary.Write(buf, binary.LittleEndian, header.CompressedLength)

        return buf.Bytes()
}</span>

func (header *ShareDataHeader) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var (
                padding uint8
                err     error
        )

        if err = header.ShareControlHeader.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if header.ShareControlHeader.PDUType.IsDeactivateAll() </span><span class="cov0" title="0">{
                return ErrDeactiateAll
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;header.ShareID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;header.StreamID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;header.UncompressedLength)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;header.PDUType2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;header.CompressedType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;header.CompressedLength)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type Data struct {
        ShareDataHeader    ShareDataHeader
        SynchronizePDUData *SynchronizePDUData
        ControlPDUData     *ControlPDUData
        FontListPDUData    *FontListPDUData
        FontMapPDUData     *FontMapPDUData
        ErrorInfoPDUData   *ErrorInfoPDUData
}

func (pdu *Data) Serialize() []byte <span class="cov9" title="8">{
        var data []byte

        switch </span>{
        case pdu.ShareDataHeader.PDUType2.IsSynchronize():<span class="cov3" title="2">
                data = pdu.SynchronizePDUData.Serialize()</span>
        case pdu.ShareDataHeader.PDUType2.IsControl():<span class="cov6" title="4">
                data = pdu.ControlPDUData.Serialize()</span>
        case pdu.ShareDataHeader.PDUType2.IsFontlist():<span class="cov3" title="2">
                data = pdu.FontListPDUData.Serialize()</span>
        }

        <span class="cov9" title="8">pdu.ShareDataHeader.ShareControlHeader.TotalLength = uint16(18 + len(data))
        pdu.ShareDataHeader.UncompressedLength = uint16(4 + len(data))

        buf := new(bytes.Buffer)

        buf.Write(pdu.ShareDataHeader.Serialize())
        buf.Write(data)

        return buf.Bytes()</span>
}

func (pdu *Data) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        if err = pdu.ShareDataHeader.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch </span>{
        case pdu.ShareDataHeader.PDUType2.IsSynchronize():<span class="cov0" title="0">
                pdu.SynchronizePDUData = &amp;SynchronizePDUData{}

                return pdu.SynchronizePDUData.Deserialize(wire)</span>
        case pdu.ShareDataHeader.PDUType2.IsControl():<span class="cov0" title="0">
                pdu.ControlPDUData = &amp;ControlPDUData{}

                return pdu.ControlPDUData.Deserialize(wire)</span>
        case pdu.ShareDataHeader.PDUType2.IsFontmap():<span class="cov0" title="0">
                pdu.FontMapPDUData = &amp;FontMapPDUData{}

                return pdu.FontMapPDUData.Deserialize(wire)</span>
        case pdu.ShareDataHeader.PDUType2.IsErrorInfo():<span class="cov0" title="0">
                pdu.ErrorInfoPDUData = &amp;ErrorInfoPDUData{}

                return pdu.ErrorInfoPDUData.Deserialize(wire)</span>
        case pdu.ShareDataHeader.PDUType2.IsSaveSessionInfo():<span class="cov0" title="0"> // ignore
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("unknown data pdu: %d", pdu.ShareDataHeader.PDUType2)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package pdu

import (
        "encoding/binary"
        "fmt"
        "io"
)

type ErrorInfoPDUData struct {
        ErrorInfo uint32
}

func (pdu *ErrorInfoPDUData) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        return binary.Read(wire, binary.LittleEndian, &amp;pdu.ErrorInfo)
}</span>

var errorInfoMap = map[uint32]string{
        0x00000000: "ERRINFO_NONE",
        0x00000001: "ERRINFO_RPC_INITIATED_DISCONNECT",
        0x00000002: "ERRINFO_RPC_INITIATED_LOGOFF",
        0x00000003: "ERRINFO_IDLE_TIMEOUT",
        0x00000004: "ERRINFO_LOGON_TIMEOUT",
        0x00000005: "ERRINFO_DISCONNECTED_BY_OTHERCONNECTION",
        0x00000006: "ERRINFO_OUT_OF_MEMORY",
        0x00000007: "ERRINFO_SERVER_DENIED_CONNECTION",
        0x00000009: "ERRINFO_SERVER_INSUFFICIENT_PRIVILEGES",
        0x0000000A: "ERRINFO_SERVER_FRESH_CREDENTIALS_REQUIRED",
        0x0000000B: "ERRINFO_RPC_INITIATED_DISCONNECT_BYUSER",
        0x0000000C: "ERRINFO_LOGOFF_BY_USER",
        0x0000000F: "ERRINFO_CLOSE_STACK_ON_DRIVER_NOT_READY",
        0x00000010: "ERRINFO_SERVER_DWM_CRASH",
        0x00000011: "ERRINFO_CLOSE_STACK_ON_DRIVER_FAILURE",
        0x00000012: "ERRINFO_CLOSE_STACK_ON_DRIVER_IFACE_FAILURE",
        0x00000017: "ERRINFO_SERVER_WINLOGON_CRASH",
        0x00000018: "ERRINFO_SERVER_CSRSS_CRASH",
        0x00000019: "ERRINFO_SERVER_SHUTDOWN",
        0x0000001A: "ERRINFO_SERVER_REBOOT",
        0x00000100: "ERRINFO_LICENSE_INTERNAL",
        0x00000101: "ERRINFO_LICENSE_NO_LICENSE_SERVER",
        0x00000102: "ERRINFO_LICENSE_NO_LICENSE",
        0x00000103: "ERRINFO_LICENSE_BAD_CLIENT_MSG",
        0x00000104: "ERRINFO_LICENSE_HWID_DOESNT_MATCH_LICENSE",
        0x00000105: "ERRINFO_LICENSE_BAD_CLIENT_LICENSE",
        0x00000106: "ERRINFO_LICENSE_CANT_FINISH_PROTOCOL",
        0x00000107: "ERRINFO_LICENSE_CLIENT_ENDED_PROTOCOL",
        0x00000108: "ERRINFO_LICENSE_BAD_CLIENT_ENCRYPTION",
        0x00000109: "ERRINFO_LICENSE_CANT_UPGRADE_LICENSE",
        0x0000010A: "ERRINFO_LICENSE_NO_REMOTE_CONNECTIONS",
        0x00000400: "ERRINFO_CB_DESTINATION_NOT_FOUND",
        0x00000402: "ERRINFO_CB_LOADING_DESTINATION",
        0x00000404: "ERRINFO_CB_REDIRECTING_TO_DESTINATION",
        0x00000405: "ERRINFO_CB_SESSION_ONLINE_VM_WAKE",
        0x00000406: "ERRINFO_CB_SESSION_ONLINE_VM_BOOT",
        0x00000407: "ERRINFO_CB_SESSION_ONLINE_VM_NO_DNS",
        0x00000408: "ERRINFO_CB_DESTINATION_POOL_NOT_FREE",
        0x00000409: "ERRINFO_CB_CONNECTION_CANCELLED",
        0x00000410: "ERRINFO_CB_CONNECTION_ERROR_INVALID_SETTINGS",
        0x00000411: "ERRINFO_CB_SESSION_ONLINE_VM_BOOT_TIMEOUT",
        0x00000412: "ERRINFO_CB_SESSION_ONLINE_VM_SESSMON_FAILED",
        0x000010C9: "ERRINFO_UNKNOWNPDUTYPE2",
        0x000010CA: "ERRINFO_UNKNOWNPDUTYPE",
        0x000010CB: "ERRINFO_DATAPDUSEQUENCE",
        0x000010CD: "ERRINFO_CONTROLPDUSEQUENCE",
        0x000010CE: "ERRINFO_INVALIDCONTROLPDUACTION",
        0x000010CF: "ERRINFO_INVALIDINPUTPDUTYPE",
        0x000010D0: "ERRINFO_INVALIDINPUTPDUMOUSE",
        0x000010D1: "ERRINFO_INVALIDREFRESHRECTPDU",
        0x000010D2: "ERRINFO_CREATEUSERDATAFAILED",
        0x000010D3: "ERRINFO_CONNECTFAILED",
        0x000010D4: "ERRINFO_CONFIRMACTIVEWRONGSHAREID",
        0x000010D5: "ERRINFO_CONFIRMACTIVEWRONGORIGINATOR",
        0x000010DA: "ERRINFO_PERSISTENTKEYPDUBADLENGTH",
        0x000010DB: "ERRINFO_PERSISTENTKEYPDUILLEGALFIRST",
        0x000010DC: "ERRINFO_PERSISTENTKEYPDUTOOMANYTOTALKEYS",
        0x000010DD: "ERRINFO_PERSISTENTKEYPDUTOOMANYCACHEKEYS",
        0x000010DE: "ERRINFO_INPUTPDUBADLENGTH",
        0x000010DF: "ERRINFO_BITMAPCACHEERRORPDUBADLENGTH",
        0x000010E0: "ERRINFO_SECURITYDATATOOSHORT",
        0x000010E1: "ERRINFO_VCHANNELDATATOOSHORT",
        0x000010E2: "ERRINFO_SHAREDATATOOSHORT",
        0x000010E3: "ERRINFO_BADSUPRESSOUTPUTPDU",
        0x000010E5: "ERRINFO_CONFIRMACTIVEPDUTOOSHORT",
        0x000010E7: "ERRINFO_CAPABILITYSETTOOSMALL",
        0x000010E8: "ERRINFO_CAPABILITYSETTOOLARGE",
        0x000010E9: "ERRINFO_NOCURSORCACHE",
        0x000010EA: "ERRINFO_BADCAPABILITIES",
        0x000010EC: "ERRINFO_VIRTUALCHANNELDECOMPRESSIONERR",
        0x000010ED: "ERRINFO_INVALIDVCCOMPRESSIONTYPE",
        0x000010EF: "ERRINFO_INVALIDCHANNELID",
        0x000010F0: "ERRINFO_VCHANNELSTOOMANY",
        0x000010F3: "ERRINFO_REMOTEAPPSNOTENABLED",
        0x000010F4: "ERRINFO_CACHECAPNOTSET",
        0x000010F5: "ERRINFO_BITMAPCACHEERRORPDUBADLENGTH2",
        0x000010F6: "ERRINFO_OFFSCRCACHEERRORPDUBADLENGTH",
        0x000010F7: "ERRINFO_DNGCACHEERRORPDUBADLENGTH",
        0x000010F8: "ERRINFO_GDIPLUSPDUBADLENGTH",
        0x00001111: "ERRINFO_SECURITYDATATOOSHORT2",
        0x00001112: "ERRINFO_SECURITYDATATOOSHORT3",
        0x00001113: "ERRINFO_SECURITYDATATOOSHORT4",
        0x00001114: "ERRINFO_SECURITYDATATOOSHORT5",
        0x00001115: "ERRINFO_SECURITYDATATOOSHORT6",
        0x00001116: "ERRINFO_SECURITYDATATOOSHORT7",
        0x00001117: "ERRINFO_SECURITYDATATOOSHORT8",
        0x00001118: "ERRINFO_SECURITYDATATOOSHORT9",
        0x00001119: "ERRINFO_SECURITYDATATOOSHORT10",
        0x0000111A: "ERRINFO_SECURITYDATATOOSHORT11",
        0x0000111B: "ERRINFO_SECURITYDATATOOSHORT12",
        0x0000111C: "ERRINFO_SECURITYDATATOOSHORT13",
        0x0000111D: "ERRINFO_SECURITYDATATOOSHORT14",
        0x0000111E: "ERRINFO_SECURITYDATATOOSHORT15",
        0x0000111F: "ERRINFO_SECURITYDATATOOSHORT16",
        0x00001120: "ERRINFO_SECURITYDATATOOSHORT17",
        0x00001121: "ERRINFO_SECURITYDATATOOSHORT18",
        0x00001122: "ERRINFO_SECURITYDATATOOSHORT19",
        0x00001123: "ERRINFO_SECURITYDATATOOSHORT20",
        0x00001124: "ERRINFO_SECURITYDATATOOSHORT21",
        0x00001125: "ERRINFO_SECURITYDATATOOSHORT22",
        0x00001126: "ERRINFO_SECURITYDATATOOSHORT23",
        0x00001129: "ERRINFO_BADMONITORDATA",
        0x0000112A: "ERRINFO_VCDECOMPRESSEDREASSEMBLEFAILED",
        0x0000112B: "ERRINFO_VCDATATOOLONG",
        0x0000112C: "ERRINFO_BAD_FRAME_ACK_DATA",
        0x0000112D: "ERRINFO_GRAPHICSMODENOTSUPPORTED",
        0x0000112E: "ERRINFO_GRAPHICSSUBSYSTEMRESETFAILED",
        0x0000112F: "ERRINFO_GRAPHICSSUBSYSTEMFAILED",
        0x00001130: "ERRINFO_TIMEZONEKEYNAMELENGTHTOOSHORT",
        0x00001131: "ERRINFO_TIMEZONEKEYNAMELENGTHTOOLONG",
        0x00001132: "ERRINFO_DYNAMICDSTDISABLEDFIELDMISSING",
        0x00001133: "ERRINFO_VCDECODINGERROR",
        0x00001134: "ERRINFO_VIRTUALDESKTOPTOOLARGE",
        0x00001135: "ERRINFO_MONITORGEOMETRYVALIDATIONFAILED",
        0x00001136: "ERRINFO_INVALIDMONITORCOUNT",
        0x00001191: "ERRINFO_UPDATESESSIONKEYFAILED",
        0x00001192: "ERRINFO_DECRYPTFAILED",
        0x00001193: "ERRINFO_ENCRYPTFAILED",
        0x00001194: "ERRINFO_ENCPKGMISMATCH",
        0x00001195: "ERRINFO_DECRYPTFAILED2",
}

func (pdu *ErrorInfoPDUData) String() string <span class="cov0" title="0">{
        code, ok := errorInfoMap[pdu.ErrorInfo]
        if ok </span><span class="cov0" title="0">{
                return code
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("unknown code: %d", pdu.ErrorInfo)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
)

type EventCode uint8

const (
        //EventCodeScanCode FASTPATH_INPUT_EVENT_SCANCODE
        EventCodeScanCode EventCode = 0

        //EventCodeMouse FASTPATH_INPUT_EVENT_MOUSE
        EventCodeMouse EventCode = 1

        //EventCodeMouseX FASTPATH_INPUT_EVENT_MOUSEX
        EventCodeMouseX EventCode = 2

        //EventCodeSync FASTPATH_INPUT_EVENT_SYNC
        EventCodeSync EventCode = 3

        //EventCodeUnicode FASTPATH_INPUT_EVENT_UNICODE
        EventCodeUnicode EventCode = 4

        //EventCodeQoETimestamp FASTPATH_INPUT_EVENT_QOE_TIMESTAMP
        EventCodeQoETimestamp EventCode = 6
)

type InputEvent struct {
        EventFlags           uint8
        EventCode            EventCode
        keyboardEvent        *keyboardEvent
        unicodeKeyboardEvent *unicodeKeyboardEvent
        mouseEvent           *mouseEvent
        extendedMouseEvent   *extendedMouseEvent
        qualityOfExperience  *qualityOfExperience
}

func (e *InputEvent) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        // event flags in higher 5 bits
        // event code in lower 3 bits
        header := (e.EventFlags&amp;0x1f)&lt;&lt;3 | uint8(e.EventCode)&amp;0x7

        var data []byte

        switch e.EventCode </span>{
        case EventCodeScanCode:<span class="cov0" title="0">
                data = e.keyboardEvent.Serialize()</span>
        case EventCodeUnicode:<span class="cov0" title="0">
                data = e.unicodeKeyboardEvent.Serialize()</span>
        case EventCodeMouse:<span class="cov0" title="0">
                data = e.mouseEvent.Serialize()</span>
        case EventCodeMouseX:<span class="cov0" title="0">
                data = e.extendedMouseEvent.Serialize()</span>
        case EventCodeSync:<span class="cov0" title="0"></span> // do nothing
        case EventCodeQoETimestamp:<span class="cov0" title="0">
                data = e.qualityOfExperience.Serialize()</span>
        }

        <span class="cov0" title="0">binary.Write(buf, binary.LittleEndian, header)
        buf.Write(data)

        return buf.Bytes()</span>
}

type keyboardEvent struct {
        KeyCode uint8
}

const (
        // KBDFlagsRelease FASTPATH_INPUT_KBDFLAGS_RELEASE
        KBDFlagsRelease uint8 = 0x01

        // KBDFlagsExtended FASTPATH_INPUT_KBDFLAGS_EXTENDED
        KBDFlagsExtended uint8 = 0x02

        // KBDFlagsExtended1 FASTPATH_INPUT_KBDFLAGS_EXTENDED1
        KBDFlagsExtended1 uint8 = 0x04
)

func NewKeyboardEvent(flags uint8, keyCode uint8) *InputEvent <span class="cov0" title="0">{
        return &amp;InputEvent{
                EventFlags: flags,
                EventCode:  EventCodeScanCode,
                keyboardEvent: &amp;keyboardEvent{
                        KeyCode: keyCode,
                },
        }
}</span>

func (e *keyboardEvent) Serialize() []byte <span class="cov0" title="0">{
        return []byte{e.KeyCode}
}</span>

type unicodeKeyboardEvent struct {
        UnicodeCode uint16
}

func NewUnicodeKeyboardEvent(unicodeCode uint16) *InputEvent <span class="cov0" title="0">{
        return &amp;InputEvent{
                EventFlags: KBDFlagsRelease,
                EventCode:  EventCodeUnicode,
                unicodeKeyboardEvent: &amp;unicodeKeyboardEvent{
                        UnicodeCode: unicodeCode,
                },
        }
}</span>

func (e *unicodeKeyboardEvent) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, e.UnicodeCode)

        return buf.Bytes()
}</span>

const (
        PTRFlagsHWheel        uint16 = 0x0400
        PTRFlagsWheel         uint16 = 0x0200
        PTRFlagsWheelNegative uint16 = 0x0100
        PTRFlagsMove          uint16 = 0x0800
        PTRFlagsDown          uint16 = 0x8000
        PTRFlagsButton1       uint16 = 0x1000
        PTRFlagsButton2       uint16 = 0x2000
        PTRFlagsButton3       uint16 = 0x3000
)

type mouseEvent struct {
        pointerFlags uint16
        xPos         uint16
        yPos         uint16
}

func NewMouseEvent(pointerFlags, xPos, yPos uint16) *InputEvent <span class="cov0" title="0">{
        return &amp;InputEvent{
                EventCode: EventCodeMouse,
                mouseEvent: &amp;mouseEvent{
                        pointerFlags: pointerFlags,
                        xPos:         xPos,
                        yPos:         yPos,
                },
        }
}</span>

func (e *mouseEvent) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, e.pointerFlags)
        binary.Write(buf, binary.LittleEndian, e.xPos)
        binary.Write(buf, binary.LittleEndian, e.yPos)

        return buf.Bytes()
}</span>

const (
        PTRXFlagsDown    uint16 = 0x8000
        PTRXFlagsButton1 uint16 = 0x0001
        PTRXFlagsButton2 uint16 = 0x0002
)

type extendedMouseEvent struct {
        pointerFlags uint16
        xPos         uint16
        yPos         uint16
}

func NewExtendedMouseEvent(pointerFlags, xPos, yPos uint16) *InputEvent <span class="cov0" title="0">{
        return &amp;InputEvent{
                EventCode: EventCodeMouseX,
                extendedMouseEvent: &amp;extendedMouseEvent{
                        pointerFlags: pointerFlags,
                        xPos:         xPos,
                        yPos:         yPos,
                },
        }
}</span>

func (e *extendedMouseEvent) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, e.pointerFlags)
        binary.Write(buf, binary.LittleEndian, e.xPos)
        binary.Write(buf, binary.LittleEndian, e.yPos)

        return buf.Bytes()
}</span>

const (
        SyncScrollLock uint8 = 0x01
        SyncNumLock    uint8 = 0x02
        SyncCapsLock   uint8 = 0x04
        SyncKanaLock   uint8 = 0x08
)

func NewSynchronizeEvent(eventFlags uint8) *InputEvent <span class="cov0" title="0">{
        return &amp;InputEvent{
                EventFlags: eventFlags,
                EventCode:  EventCodeSync,
        }
}</span>

type qualityOfExperience struct {
        timestamp uint32
}

func NewQualityOfExperienceEvent(timestamp uint32) *InputEvent <span class="cov0" title="0">{
        return &amp;InputEvent{
                EventCode: EventCodeQoETimestamp,
                qualityOfExperience: &amp;qualityOfExperience{
                        timestamp: timestamp,
                },
        }
}</span>

func (e *qualityOfExperience) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, e.timestamp)

        return buf.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package pdu

import (
        "encoding/binary"
        "errors"
        "io"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/headers"
)

type LicensingBinaryBlob struct {
        BlobType uint16
        BlobLen  uint16
        BlobData []byte
}

func (b *LicensingBinaryBlob) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        binary.Read(wire, binary.LittleEndian, &amp;b.BlobType)
        binary.Read(wire, binary.LittleEndian, &amp;b.BlobLen)

        if b.BlobLen == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">b.BlobData = make([]byte, b.BlobLen)

        if _, err := wire.Read(b.BlobData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type LicensingErrorMessage struct {
        ErrorCode       uint32
        StateTransition uint32
        ErrorInfo       LicensingBinaryBlob
}

func (m *LicensingErrorMessage) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        binary.Read(wire, binary.LittleEndian, &amp;m.ErrorCode)
        binary.Read(wire, binary.LittleEndian, &amp;m.StateTransition)

        return m.ErrorInfo.Deserialize(wire)
}</span>

type LicensingPreamble struct {
        MsgType uint8
        Flags   uint8
        MsgSize uint16
}

func (p *LicensingPreamble) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        binary.Read(wire, binary.LittleEndian, &amp;p.MsgType)
        binary.Read(wire, binary.LittleEndian, &amp;p.Flags)
        binary.Read(wire, binary.LittleEndian, &amp;p.MsgSize)

        return nil
}</span>

type ServerLicenseError struct {
        Preamble           LicensingPreamble
        ValidClientMessage LicensingErrorMessage
}

func (pdu *ServerLicenseError) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        securityFlag, err := headers.UnwrapSecurityFlag(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if securityFlag != 0x0080 </span><span class="cov0" title="0">{ // SEC_LICENSE_PKT
                return errors.New("bad license header")
        }</span>

        <span class="cov0" title="0">err = pdu.Preamble.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = pdu.ValidClientMessage.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "strings"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/headers"
        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/utf16"
)

type SystemTime struct {
        Year         uint16
        Month        uint16
        DayOfWeek    uint16
        Day          uint16
        Hour         uint16
        Minute       uint16
        Second       uint16
        Milliseconds uint16
}

func (t *SystemTime) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, t.Year)
        binary.Write(buf, binary.LittleEndian, t.Month)
        binary.Write(buf, binary.LittleEndian, t.DayOfWeek)
        binary.Write(buf, binary.LittleEndian, t.Day)
        binary.Write(buf, binary.LittleEndian, t.Hour)
        binary.Write(buf, binary.LittleEndian, t.Minute)
        binary.Write(buf, binary.LittleEndian, t.Second)
        binary.Write(buf, binary.LittleEndian, t.Milliseconds)

        return buf.Bytes()
}</span>

type TimeZoneInformation struct {
        Bias         uint32
        StandardName [64]byte
        StandardDate SystemTime
        StandardBias uint32
        DaylightName [64]byte
        DaylightDate SystemTime
        DaylightBias uint32
}

func (i *TimeZoneInformation) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, i.Bias)
        binary.Write(buf, binary.LittleEndian, i.StandardName)

        buf.Write(i.StandardDate.Serialize())

        binary.Write(buf, binary.LittleEndian, i.StandardBias)
        binary.Write(buf, binary.LittleEndian, i.DaylightName)

        buf.Write(i.DaylightDate.Serialize())

        binary.Write(buf, binary.LittleEndian, i.DaylightBias)

        return buf.Bytes()
}</span>

type AddressFamily uint16

const (
        // AddressFamilyINET AF_INET IPv4
        AddressFamilyINET AddressFamily = 0x00002

        // AddressFamilyINET6 AF_INET6 IPv6
        AddressFamilyINET6 AddressFamily = 0x0017
)

type ExtendedInfoPacket struct {
        PerformanceFlags uint32
}

func (p *ExtendedInfoPacket) Serialize() []byte <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, uint16(0x0002)) // ClientAddressFamily = AF_INET
        binary.Write(buf, binary.LittleEndian, uint16(2))      // cbClientAddress
        buf.Write([]byte{0, 0})                                // ClientAddress
        binary.Write(buf, binary.LittleEndian, uint16(2))      // cbClientDir
        buf.Write([]byte{0, 0})                                // ClientDir
        buf.Write(make([]byte, 172))                           // ClientTimeZone
        binary.Write(buf, binary.LittleEndian, uint32(0))      // ClientSessionId
        binary.Write(buf, binary.LittleEndian, p.PerformanceFlags)

        return buf.Bytes()
}</span>

type ClientInfoPacket struct {
        CodePage       uint32
        Flags          InfoFlag
        Domain         string
        Username       string
        Password       string
        AlternateShell string
        WorkingDir     string
        ExtraInfo      ExtendedInfoPacket
}

func (p *ClientInfoPacket) Serialize() []byte <span class="cov8" title="1">{
        cbDomain := uint16(0)
        cbUserName := uint16(0)
        cbPassword := uint16(0)
        cbAlternateShell := uint16(0)
        cbWorkingDir := uint16(0)

        domain := []byte{0x00, 0x00}
        username := []byte{0x00, 0x00}
        password := []byte{0x00, 0x00}
        alternateShell := []byte{0x00, 0x00}
        workingDir := []byte{0x00, 0x00}

        if len(p.Domain) &gt; 0 </span><span class="cov8" title="1">{
                domain = utf16.Encode(strings.Trim(p.Domain, " ") + "\x00")
                cbDomain = uint16(len(domain) - 2)
        }</span>

        <span class="cov8" title="1">if len(p.Username) &gt; 0 </span><span class="cov8" title="1">{
                username = utf16.Encode(strings.Trim(p.Username, " ") + "\x00")
                cbUserName = uint16(len(username) - 2)
        }</span>

        <span class="cov8" title="1">if len(p.Password) &gt; 0 </span><span class="cov8" title="1">{
                password = utf16.Encode(strings.Trim(p.Password, " ") + "\x00")
                cbPassword = uint16(len(password) - 2)
        }</span>

        <span class="cov8" title="1">if len(p.AlternateShell) &gt; 0 </span><span class="cov0" title="0">{
                alternateShell = utf16.Encode(strings.Trim(p.AlternateShell, " ") + "\x00")
                cbAlternateShell = uint16(len(alternateShell) - 2)
        }</span>

        <span class="cov8" title="1">if len(p.WorkingDir) &gt; 0 </span><span class="cov0" title="0">{
                workingDir = utf16.Encode(strings.Trim(p.WorkingDir, " ") + "\x00")
                cbWorkingDir = uint16(len(workingDir) - 2)
        }</span>

        <span class="cov8" title="1">buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, p.CodePage)
        binary.Write(buf, binary.LittleEndian, uint32(p.Flags))
        binary.Write(buf, binary.LittleEndian, cbDomain)
        binary.Write(buf, binary.LittleEndian, cbUserName)
        binary.Write(buf, binary.LittleEndian, cbPassword)
        binary.Write(buf, binary.LittleEndian, cbAlternateShell)
        binary.Write(buf, binary.LittleEndian, cbWorkingDir)

        buf.Write(domain)
        buf.Write(username)
        buf.Write(password)
        buf.Write(alternateShell)
        buf.Write(workingDir)

        buf.Write(p.ExtraInfo.Serialize())

        return buf.Bytes()</span>
}

type ClientInfo struct {
        InfoPacket ClientInfoPacket
}

type InfoFlag uint32

const (
        // InfoFlagMouse INFO_MOUSE
        InfoFlagMouse InfoFlag = 0x00000001

        // InfoFlagDisableCtrlAltDel INFO_DISABLECTRLALTDEL
        InfoFlagDisableCtrlAltDel InfoFlag = 0x00000002

        // InfoFlagAutoLogon INFO_AUTOLOGON
        InfoFlagAutoLogon InfoFlag = 0x00000008

        // InfoFlagUnicode INFO_UNICODE
        InfoFlagUnicode InfoFlag = 0x00000010

        // InfoFlagMaximizeShell INFO_MAXIMIZESHELL
        InfoFlagMaximizeShell InfoFlag = 0x00000020

        // InfoFlagLogonNotify INFO_LOGONNOTIFY
        InfoFlagLogonNotify InfoFlag = 0x00000040

        // InfoFlagCompression INFO_COMPRESSION
        InfoFlagCompression InfoFlag = 0x00000080

        // InfoFlagEnableWindowsKey INFO_ENABLEWINDOWSKEY
        InfoFlagEnableWindowsKey InfoFlag = 0x00000100

        // InfoFlagRemoteConsoleAudio INFO_REMOTECONSOLEAUDIO
        InfoFlagRemoteConsoleAudio InfoFlag = 0x00002000

        // InfoFlagForceEncryptedCSPDU INFO_FORCE_ENCRYPTED_CS_PDU
        InfoFlagForceEncryptedCSPDU InfoFlag = 0x00004000

        // InfoFlagRail INFO_RAIL
        InfoFlagRail InfoFlag = 0x00008000

        // InfoFlagLogonErrors INFO_LOGONERRORS
        InfoFlagLogonErrors InfoFlag = 0x00010000

        // InfoFlagMouseHasWheel INFO_MOUSE_HAS_WHEEL
        InfoFlagMouseHasWheel InfoFlag = 0x00020000

        // InfoFlagPasswordIsSCPIN INFO_PASSWORD_IS_SC_PIN
        InfoFlagPasswordIsSCPIN InfoFlag = 0x00040000

        // InfoFlagNoAudioPlayback INFO_NOAUDIOPLAYBACK
        InfoFlagNoAudioPlayback InfoFlag = 0x00080000

        // InfoFlagUsingSavedCreds INFO_USING_SAVED_CREDS
        InfoFlagUsingSavedCreds InfoFlag = 0x00100000

        // InfoFlagAudioCapture INFO_AUDIOCAPTURE
        InfoFlagAudioCapture InfoFlag = 0x00200000

        // InfoFlagVideoDisable INFO_VIDEO_DISABLE
        InfoFlagVideoDisable InfoFlag = 0x00400000

        // InfoFlagHiDefRailSupported INFO_HIDEF_RAIL_SUPPORTED
        InfoFlagHiDefRailSupported InfoFlag = 0x02000000
)

const (
        CompressionTypeMask  uint32 = 0x00001E00
        CompressionType8K    uint32 = 0x0
        CompressionType64K   uint32 = 0x1
        CompressionTypeRDP6  uint32 = 0x2
        CompressionTypeRDP61 uint32 = 0x3
)

func NewClientInfo(domain, username, password string) *ClientInfo <span class="cov8" title="1">{
        return &amp;ClientInfo{
                InfoPacket: ClientInfoPacket{
                        Flags:     InfoFlagMouse | InfoFlagUnicode | InfoFlagAutoLogon | InfoFlagDisableCtrlAltDel | InfoFlagEnableWindowsKey,
                        Domain:    domain,
                        Username:  username,
                        Password:  password,
                        ExtraInfo: ExtendedInfoPacket{
                                //// PERF_DISABLE_WALLPAPER, PERF_DISABLE_FULLWINDOWDRAG, PERF_DISABLE_MENUANIMATIONS,
                                //// PERF_DISABLE_THEMING, PERF_DISABLE_CURSOR_SHADOW, PERF_DISABLE_CURSORSETTINGS
                                //PerformanceFlags: 0x00000001 | 0x00000002 | 0x00000004 | 0x00000008 | 0x00000020 | 0x00000040,
                        },
                },
        }
}</span>

func (pdu *ClientInfo) Serialize() []byte <span class="cov8" title="1">{
        return headers.WrapSecurityFlag(
                0x0040, // SEC_INFO_PKT
                pdu.InfoPacket.Serialize(),
        )
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package per

import (
        "encoding/binary"
        "errors"
        "io"
)

func ReadChoice(r io.Reader) (uint8, error) <span class="cov0" title="0">{
        var choice uint8

        return choice, binary.Read(r, binary.BigEndian, &amp;choice)
}</span>

func ReadLength(r io.Reader) (int, error) <span class="cov0" title="0">{
        var (
                octet uint8
                size  int
                err   error
        )

        if err = binary.Read(r, binary.BigEndian, &amp;octet); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if octet&amp;0x80 != 0x80 </span><span class="cov0" title="0">{
                return int(octet), nil
        }</span>

        <span class="cov0" title="0">octet &amp;^= 0x80
        size = int(octet) &lt;&lt; 8

        if err = binary.Read(r, binary.BigEndian, &amp;octet); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">size += int(octet)

        return size, nil</span>
}

func ReadObjectIdentifier(oid [6]byte, r io.Reader) (bool, error) <span class="cov0" title="0">{
        size, err := ReadLength(r)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if size != 5 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">var t12 uint8
        err = binary.Read(r, binary.BigEndian, &amp;t12)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">aOid := make([]byte, 6)
        aOid[0] = t12 &gt;&gt; 4
        aOid[1] = t12 &amp; 0x0f

        for i := 2; i &lt;= 5; i++ </span><span class="cov0" title="0">{
                err = binary.Read(r, binary.BigEndian, &amp;aOid[i])
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov0" title="0">for i := 0; i &lt; len(aOid); i++ </span><span class="cov0" title="0">{
                if oid[i] != aOid[i] </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

func ReadInteger16(minimum uint16, r io.Reader) (uint16, error) <span class="cov0" title="0">{
        var num uint16

        if err := binary.Read(r, binary.BigEndian, &amp;num); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">num += minimum

        return num, nil</span>
}

func ReadInteger(r io.Reader) (int, error) <span class="cov0" title="0">{
        size, err := ReadLength(r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">switch size </span>{
        case 1:<span class="cov0" title="0">
                var num uint8

                return int(num), binary.Read(r, binary.BigEndian, &amp;num)</span>
        case 2:<span class="cov0" title="0">
                var num uint16

                return int(num), binary.Read(r, binary.BigEndian, &amp;num)</span>
        case 4:<span class="cov0" title="0">
                var num uint32

                return int(num), binary.Read(r, binary.BigEndian, &amp;num)</span>
        default:<span class="cov0" title="0">
                return 0, errors.New("bad integer length")</span>
        }
}

func ReadEnumerates(r io.Reader) (uint8, error) <span class="cov0" title="0">{
        var num uint8

        return num, binary.Read(r, binary.BigEndian, &amp;num)
}</span>

func ReadNumberOfSet(r io.Reader) (uint8, error) <span class="cov0" title="0">{
        var num uint8

        return num, binary.Read(r, binary.BigEndian, &amp;num)
}</span>

func ReadOctetStream(octetStream []byte, minValue int, r io.Reader) (bool, error) <span class="cov0" title="0">{
        length, err := ReadLength(r)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">size := length + minValue
        if size != len(octetStream) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">var c uint8

        for i := 0; i &lt; size; i++ </span><span class="cov0" title="0">{
                if err = binary.Read(r, binary.BigEndian, &amp;c); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">if octetStream[i] != c </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package per

import (
        "encoding/binary"
        "io"
)

func WriteChoice(choice uint8, w io.Writer) <span class="cov0" title="0">{
        _, _ = w.Write([]byte{
                choice,
        })
}</span>

func WriteObjectIdentifier(oid [6]byte, w io.Writer) <span class="cov0" title="0">{
        WriteLength(5, w)

        _, _ = w.Write([]byte{
                (oid[0] &lt;&lt; 4) &amp; (oid[1] &amp; 0x0f),
                oid[2],
                oid[3],
                oid[4],
                oid[5],
        })
}</span>

func WriteLength(value uint16, w io.Writer) <span class="cov0" title="0">{
        if value &gt; 0x7f </span><span class="cov0" title="0">{
                _ = binary.Write(w, binary.BigEndian, value|0x8000)
                return
        }</span>

        <span class="cov0" title="0">_, _ = w.Write([]byte{uint8(value)})</span>
}

func WriteSelection(selection uint8, w io.Writer) <span class="cov0" title="0">{
        _, _ = w.Write([]byte{
                selection,
        })
}</span>

func WriteNumericString(nStr string, minValue int, w io.Writer) <span class="cov0" title="0">{
        length := len(nStr)
        mLength := minValue

        if length-minValue &gt;= 0 </span><span class="cov0" title="0">{
                mLength = length - minValue
        }</span>

        <span class="cov0" title="0">result := make([]byte, 0, mLength)

        for i := 0; i &lt; length; i += 2 </span><span class="cov0" title="0">{
                c1 := nStr[i]
                c2 := byte(0x30)

                if i+1 &lt; length </span><span class="cov0" title="0">{
                        c2 = nStr[i+1]
                }</span>

                <span class="cov0" title="0">c1 = (c1 - 0x30) % 10
                c2 = (c2 - 0x30) % 10

                result = append(result, (c1&lt;&lt;4)|c2)</span>
        }

        <span class="cov0" title="0">WriteLength(uint16(mLength), w)
        _, _ = w.Write(result)</span>
}

func WritePadding(length int, w io.Writer) <span class="cov0" title="0">{
        _, _ = w.Write(make([]byte, length))
}</span>

func WriteNumberOfSet(numberOfSet uint8, w io.Writer) <span class="cov0" title="0">{
        _, _ = w.Write([]byte{numberOfSet})
}</span>

func WriteOctetStream(oStr string, minValue int, w io.Writer) <span class="cov0" title="0">{
        length := len(oStr)
        mLength := minValue

        if length-minValue &gt;= 0 </span><span class="cov0" title="0">{
                mLength = length - minValue
        }</span>

        <span class="cov0" title="0">result := make([]byte, 0, mLength)
        for i := 0; i &lt; length; i++ </span><span class="cov0" title="0">{
                result = append(result, oStr[i])
        }</span>

        <span class="cov0" title="0">WriteLength(uint16(mLength), w)
        _, _ = w.Write(result)</span>
}

func WriteInteger(value int, w io.Writer) <span class="cov0" title="0">{
        if value &lt;= 0xff </span><span class="cov0" title="0">{
                WriteLength(1, w)
                w.Write([]byte{uint8(value)})

                return
        }</span>

        <span class="cov0" title="0">if value &lt; 0xffff </span><span class="cov0" title="0">{
                WriteLength(2, w)
                binary.Write(w, binary.BigEndian, uint16(value))

                return
        }</span>

        <span class="cov0" title="0">WriteLength(4, w)
        binary.Write(w, binary.BigEndian, uint32(value))</span>
}

func WriteInteger16(value, minimum uint16, w io.Writer) <span class="cov0" title="0">{
        value -= minimum

        binary.Write(w, binary.BigEndian, value)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package rdp

import (
        "bytes"
        "encoding/binary"
        "io"

        "github.com/kulaginds/rdp-html5/internal/pkg/rdp/utf16"
)

type RailState uint8

// State machine described in [MS-RDPERP] 3.1.1.1.

const (
        RailStateUninitialized RailState = iota
        RailStateInitializing
        RailStateSyncDesktop
        RailStateWaitForData
        RailStateExecuteApp
)

func (c *client) handleRail(wire io.Reader) error <span class="cov0" title="0">{
        if c.remoteApp == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var (
                input RailPDU
                err   error
        )

        if err = input.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if input.header.OrderType == RailOrderSysParam </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch c.railState </span>{
        case RailStateInitializing:<span class="cov0" title="0">
                return c.railHandshake(&amp;input)</span>
        case RailStateExecuteApp:<span class="cov0" title="0">
                return c.railReceiveRemoteAppStatus(&amp;input)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type RailOrder uint16

const (
        // RailOrderExec TS_RAIL_ORDER_EXEC
        RailOrderExec RailOrder = 0x0001

        // RailOrderActivate TS_RAIL_ORDER_ACTIVATE
        RailOrderActivate RailOrder = 0x0002

        // RailOrderSysParam TS_RAIL_ORDER_SYSPARAM
        RailOrderSysParam RailOrder = 0x0003

        // RailOrderSysCommand TS_RAIL_ORDER_SYSCOMMAND
        RailOrderSysCommand RailOrder = 0x0004

        // RailOrderHandshake TS_RAIL_ORDER_HANDSHAKE
        RailOrderHandshake RailOrder = 0x0005

        // RailOrderNotifyEvent TS_RAIL_ORDER_NOTIFY_EVENT
        RailOrderNotifyEvent RailOrder = 0x0006

        // RailOrderWindowMove TS_RAIL_ORDER_WINDOWMOVE
        RailOrderWindowMove RailOrder = 0x0008

        // RailOrderLocalMoveSize TS_RAIL_ORDER_LOCALMOVESIZE
        RailOrderLocalMoveSize RailOrder = 0x0009

        // RailOrderMinMaxInfo TS_RAIL_ORDER_MINMAXINFO
        RailOrderMinMaxInfo RailOrder = 0x000a

        // RailOrderClientStatus TS_RAIL_ORDER_CLIENTSTATUS
        RailOrderClientStatus RailOrder = 0x000b

        // RailOrderSysMenu TS_RAIL_ORDER_SYSMENU
        RailOrderSysMenu RailOrder = 0x000c

        // RailOrderLangBarInfo TS_RAIL_ORDER_LANGBARINFO
        RailOrderLangBarInfo RailOrder = 0x000d

        // RailOrderExecResult TS_RAIL_ORDER_EXEC_RESULT
        RailOrderExecResult RailOrder = 0x0080

        // RailOrderGetAppIDReq TS_RAIL_ORDER_GET_APPID_REQ
        RailOrderGetAppIDReq RailOrder = 0x000E

        // RailOrderAppIDResp TS_RAIL_ORDER_GET_APPID_RESP
        RailOrderAppIDResp RailOrder = 0x000F

        // RailOrderTaskBarInfo TS_RAIL_ORDER_TASKBARINFO
        RailOrderTaskBarInfo RailOrder = 0x0010

        // RailOrderLanguageIMEInfo TS_RAIL_ORDER_LANGUAGEIMEINFO
        RailOrderLanguageIMEInfo RailOrder = 0x0011

        // RailOrderCompartmentInfo TS_RAIL_ORDER_COMPARTMENTINFO
        RailOrderCompartmentInfo RailOrder = 0x0012

        // RailOrderHandshakeEx TS_RAIL_ORDER_HANDSHAKE_EX
        RailOrderHandshakeEx RailOrder = 0x0013

        // RailOrderZOrderSync TS_RAIL_ORDER_ZORDER_SYNC
        RailOrderZOrderSync RailOrder = 0x0014

        // RailOrderCloak TS_RAIL_ORDER_CLOAK
        RailOrderCloak RailOrder = 0x0015

        // RailOrderPowerDisplayRequest TS_RAIL_ORDER_POWER_DISPLAY_REQUEST
        RailOrderPowerDisplayRequest RailOrder = 0x0016

        // RailOrderSnapArrange TS_RAIL_ORDER_SNAP_ARRANGE
        RailOrderSnapArrange RailOrder = 0x0017

        // RailOrderGetAppIDRespEx TS_RAIL_ORDER_GET_APPID_RESP_EX
        RailOrderGetAppIDRespEx RailOrder = 0x0018

        // RailOrderTextScaleInfo TS_RAIL_ORDER_TEXTSCALEINFO
        RailOrderTextScaleInfo RailOrder = 0x0019

        // RailOrderCaretBlinkInfo TS_RAIL_ORDER_CARETBLINKINFO
        RailOrderCaretBlinkInfo RailOrder = 0x001A
)

type RailPDU struct {
        channelHeader                  ChannelPDUHeader
        header                         RailPDUHeader
        RailPDUHandshake               *RailPDUHandshake
        RailPDUClientInfo              *RailPDUClientInfo
        RailPDUClientExecute           *RailPDUClientExecute
        RailPDUSystemParameters        *RailPDUSystemParameters
        RailPDUExecResult              *RailPDUExecResult
        RailPDUClientSystemParamUpdate *RailPDUClientSystemParamUpdate
}

func (pdu *RailPDU) Serialize() []byte <span class="cov0" title="0">{
        var data []byte

        switch pdu.header.OrderType </span>{
        case RailOrderHandshake:<span class="cov0" title="0">
                data = pdu.RailPDUHandshake.Serialize()</span>
        case RailOrderExec:<span class="cov0" title="0">
                data = pdu.RailPDUClientExecute.Serialize()</span>
        case RailOrderSysParam:<span class="cov0" title="0">
                data = pdu.RailPDUClientSystemParamUpdate.Serialize()</span>
        }

        <span class="cov0" title="0">pdu.header.OrderLength = uint16(8 + 4 + len(data))

        buf := new(bytes.Buffer)

        buf.Write(pdu.channelHeader.Serialize())
        buf.Write(pdu.header.Serialize())
        buf.Write(data)

        return buf.Bytes()</span>
}

func (pdu *RailPDU) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = pdu.channelHeader.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = pdu.header.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch pdu.header.OrderType </span>{
        case RailOrderHandshake:<span class="cov0" title="0">
                pdu.RailPDUHandshake = &amp;RailPDUHandshake{}

                return pdu.RailPDUHandshake.Deserialize(wire)</span>
        case RailOrderSysParam:<span class="cov0" title="0">
                pdu.RailPDUSystemParameters = &amp;RailPDUSystemParameters{}

                return pdu.RailPDUSystemParameters.Deserialize(wire)</span>
        case RailOrderExecResult:<span class="cov0" title="0">
                pdu.RailPDUExecResult = &amp;RailPDUExecResult{}

                return pdu.RailPDUExecResult.Deserialize(wire)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type RailPDUHeader struct {
        OrderType   RailOrder
        OrderLength uint16
}

func (h *RailPDUHeader) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, uint16(h.OrderType))
        binary.Write(buf, binary.LittleEndian, h.OrderLength)

        return buf.Bytes()
}</span>

func (h *RailPDUHeader) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        var orderType uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;orderType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">h.OrderType = RailOrder(orderType)

        err = binary.Read(wire, binary.LittleEndian, &amp;h.OrderLength)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type RailPDUHandshake struct {
        buildNumber uint32
}

func NewRailHandshakePDU() *RailPDU <span class="cov0" title="0">{
        return &amp;RailPDU{
                channelHeader: ChannelPDUHeader{
                        Flags: ChannelFlagFirst | ChannelFlagLast,
                },
                header: RailPDUHeader{
                        OrderType: RailOrderHandshake,
                },
                RailPDUHandshake: &amp;RailPDUHandshake{
                        buildNumber: 0x00001DB0,
                },
        }
}</span>

func (pdu *RailPDUHandshake) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, pdu.buildNumber)

        return buf.Bytes()
}</span>

func (pdu *RailPDUHandshake) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;pdu.buildNumber)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type RailPDUClientInfo struct {
        Flags uint32
}

func NewRailClientInfoPDU() *RailPDU <span class="cov0" title="0">{
        return &amp;RailPDU{
                channelHeader: ChannelPDUHeader{
                        Flags: ChannelFlagFirst | ChannelFlagLast,
                },
                header: RailPDUHeader{
                        OrderType: RailOrderClientStatus,
                },
                RailPDUClientInfo: &amp;RailPDUClientInfo{
                        Flags: 0, // none of the features are supported
                },
        }
}</span>

func (pdu *RailPDUClientInfo) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, pdu.Flags)

        return buf.Bytes()
}</span>

type RailPDUClientSystemParamUpdate struct {
        SystemParam uint32
        Body        uint8
}

func NewRailPDUClientSystemParamUpdate(systemParam uint32, body uint8) *RailPDU <span class="cov0" title="0">{
        return &amp;RailPDU{
                channelHeader: ChannelPDUHeader{
                        Flags: ChannelFlagFirst | ChannelFlagLast,
                },
                header: RailPDUHeader{
                        OrderType: RailOrderSysParam,
                },
                RailPDUClientSystemParamUpdate: &amp;RailPDUClientSystemParamUpdate{
                        SystemParam: systemParam,
                        Body:        body,
                },
        }
}</span>

func (pdu *RailPDUClientSystemParamUpdate) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, pdu.SystemParam)
        binary.Write(buf, binary.LittleEndian, pdu.Body)

        return buf.Bytes()
}</span>

func (c *client) railHandshake(*RailPDU) error <span class="cov0" title="0">{
        var (
                err error
        )

        clientHandshake := NewRailHandshakePDU()
        err = c.mcsLayer.Send(c.userID, c.channelIDMap["rail"], clientHandshake.Serialize())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">clientInfo := NewRailClientInfoPDU()
        err = c.mcsLayer.Send(c.userID, c.channelIDMap["rail"], clientInfo.Serialize())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.railState = RailStateWaitForData

        return c.railStartRemoteApp()</span>
}

type RailPDUSystemParameters struct {
        SystemParameter uint32
        Body            uint8
}

func (pdu *RailPDUSystemParameters) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;pdu.SystemParameter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type RailPDUClientExecute struct {
        Flags      uint16
        ExeOrFile  string
        WorkingDir string
        Arguments  string
}

func NewRailClientExecutePDU(app, workDir, args string) *RailPDU <span class="cov0" title="0">{
        return &amp;RailPDU{
                channelHeader: ChannelPDUHeader{
                        Flags: ChannelFlagFirst | ChannelFlagLast,
                },
                header: RailPDUHeader{
                        OrderType: RailOrderExec,
                },
                RailPDUClientExecute: &amp;RailPDUClientExecute{
                        ExeOrFile:  app,
                        WorkingDir: workDir,
                        Arguments:  args,
                },
        }
}</span>

func (pdu *RailPDUClientExecute) Serialize() []byte <span class="cov0" title="0">{
        exeOrFile := utf16.Encode(pdu.ExeOrFile)
        exeOrFileLength := uint16(len(exeOrFile))

        workingDir := utf16.Encode(pdu.WorkingDir)
        workingDirLength := uint16(len(workingDir))

        arguments := utf16.Encode(pdu.Arguments)
        argumentsLen := uint16(len(arguments))

        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, pdu.Flags)
        binary.Write(buf, binary.LittleEndian, exeOrFileLength)
        binary.Write(buf, binary.LittleEndian, workingDirLength)
        binary.Write(buf, binary.LittleEndian, argumentsLen)
        binary.Write(buf, binary.LittleEndian, exeOrFile)
        binary.Write(buf, binary.LittleEndian, workingDir)
        binary.Write(buf, binary.LittleEndian, arguments)

        return buf.Bytes()
}</span>

func (c *client) railStartRemoteApp() error <span class="cov0" title="0">{
        c.railState = RailStateExecuteApp

        clientExecute := NewRailClientExecutePDU(c.remoteApp.App, c.remoteApp.WorkingDir, c.remoteApp.Args)

        return c.mcsLayer.Send(c.userID, c.channelIDMap["rail"], clientExecute.Serialize())
}</span>

type RailPDUExecResult struct {
        Flags      uint16
        ExecResult uint16
        RawResult  uint32
        ExeOrFile  string
}

func (pdu *RailPDUExecResult) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;pdu.Flags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.ExecResult)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.RawResult)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var exeOrFileLength uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;exeOrFileLength)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">exeOrFile := make([]byte, exeOrFileLength)
        _, err = wire.Read(exeOrFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">pdu.ExeOrFile = string(exeOrFile)

        return nil</span>
}

func (c *client) railReceiveRemoteAppStatus(*RailPDU) error <span class="cov0" title="0">{
        c.railState = RailStateWaitForData

        // TODO: implement

        return nil
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package rdp

func (c *client) Read(b []byte) (int, error) <span class="cov0" title="0">{
        return c.buffReader.Read(b)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package rdp

func (c *client) SetRemoteApp(app, args, workingDir string) <span class="cov0" title="0">{
        c.remoteApp = &amp;RemoteApp{
                App:        app,
                WorkingDir: workingDir,
                Args:       args,
        }
        c.channels = append(c.channels, "rail")
        c.railState = RailStateUninitialized
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package rle

type decompressor16 struct {
        // source bytes of compressed picture
        pbSrcBuffer []byte

        // destination bytes of decompressed rgb picture
        pbDestBuffer []byte

        // rowDelta one pixels row (width * 2 byte per pixel)
        rowDelta int
}

func newDecompressor16(pbSrcBuffer []byte, pbDestBuffer []byte, rowDelta int) *decompressor16 <span class="cov0" title="0">{
        return &amp;decompressor16{
                pbSrcBuffer:  pbSrcBuffer,
                pbDestBuffer: pbDestBuffer,
                rowDelta:     rowDelta,
        }
}</span>

func (d *decompressor16) Decompress() bool <span class="cov0" title="0">{
        // TODO: implement

        return false
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package rle

func Decompress(pbSrcBuffer []byte, pbDestBuffer []byte, rowDelta int) bool <span class="cov0" title="0">{
        d := newDecompressor16(pbSrcBuffer, pbDestBuffer, rowDelta)

        return d.Decompress()
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package rdp

import "github.com/kulaginds/rdp-html5/internal/pkg/rdp/fastpath"

func (c *client) SendInputEvent(data []byte) error <span class="cov0" title="0">{
        return c.fastPath.Send(fastpath.NewInputEventPDU(data))
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package rdp

import (
        "bufio"
        "crypto/tls"
        "fmt"
        "log"
        "net"
        "strings"
        "time"

        "github.com/kulaginds/rdp-html5/internal/pkg/config"
)

func (c *client) StartTLS() error <span class="cov0" title="0">{
        // Use client-specific TLS configuration if set, otherwise fall back to global config
        insecureSkipVerify := c.skipTLSValidation
        serverName := c.tlsServerName
        minTLSVersion := "1.2" // default

        // Pull server-wide config when available so flag/env overrides are honored
        cfg := config.GetGlobalConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                var err error
                cfg, err = config.Load()
                if err != nil </span><span class="cov0" title="0">{
                        cfg = &amp;config.Config{}
                }</span>
        }

        <span class="cov0" title="0">if cfg != nil </span><span class="cov0" title="0">{
                if !insecureSkipVerify </span><span class="cov0" title="0">{
                        insecureSkipVerify = cfg.Security.SkipTLSValidation
                }</span>
                <span class="cov0" title="0">if serverName == "" </span><span class="cov0" title="0">{
                        serverName = cfg.Security.TLSServerName
                }</span>
                <span class="cov0" title="0">if cfg.Security.MinTLSVersion != "" </span><span class="cov0" title="0">{
                        minTLSVersion = cfg.Security.MinTLSVersion
                }</span>
        }

        <span class="cov0" title="0">if serverName == "" </span><span class="cov0" title="0">{
                serverName = c.getServerName()
        }</span>

        // Debug logging to trace TLS configuration
        <span class="cov0" title="0">log.Printf("TLS Configuration: InsecureSkipVerify=%t, ServerName='%s', ClientSkipValidation=%t, ClientServerName='%s'",
                insecureSkipVerify, serverName, c.skipTLSValidation, c.tlsServerName)

        // When explicitly skipping verification, allow legacy TLS for compatibility with older servers
        if insecureSkipVerify </span><span class="cov0" title="0">{
                minTLSVersion = "1.0"
        }</span>

        // Log warning if TLS validation is disabled
        <span class="cov0" title="0">if insecureSkipVerify </span><span class="cov0" title="0">{
                log.Printf("WARNING: TLS certificate validation is disabled. This is not secure for production.")
        }</span>

        // Create TLS configuration with improved error handling
        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{
                InsecureSkipVerify: insecureSkipVerify,
                MinVersion:         c.getMinTLSVersion(minTLSVersion),
                MaxVersion:         tls.VersionTLS13,
                ServerName:         serverName,
        }

        // When skipping TLS validation, ensure we have a ServerName
        // If no ServerName is provided and we're skipping validation, use a fallback
        if tlsConfig.InsecureSkipVerify &amp;&amp; tlsConfig.ServerName == "" </span><span class="cov0" title="0">{
                // Try to extract hostname from the connection address
                if c.conn != nil </span><span class="cov0" title="0">{
                        remoteAddr := c.conn.RemoteAddr().String()
                        host, _, err := net.SplitHostPort(remoteAddr)
                        if err == nil &amp;&amp; host != "" </span><span class="cov0" title="0">{
                                tlsConfig.ServerName = host
                        }</span>
                }
                // If still no ServerName, use a generic one to satisfy TLS requirements
                <span class="cov0" title="0">if tlsConfig.ServerName == "" </span><span class="cov0" title="0">{
                        tlsConfig.ServerName = "rdp-server"
                }</span>
        }

        // When skipping validation, still try to verify if possible
        <span class="cov0" title="0">if insecureSkipVerify </span><span class="cov0" title="0">{
                // Set up fallback verification for basic connectivity
                tlsConfig.InsecureSkipVerify = true
                // Allow any cipher suite when skipping verification for maximum compatibility
                tlsConfig.CipherSuites = nil
        }</span> else<span class="cov0" title="0"> {
                // Enforce secure cipher suites when verification is enabled
                tlsConfig.CipherSuites = []uint16{
                        tls.TLS_AES_128_GCM_SHA256,
                        tls.TLS_AES_256_GCM_SHA384,
                        tls.TLS_CHACHA20_POLY1305_SHA256,
                        tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
                        tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
                        tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
                        tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                }
        }</span>

        <span class="cov0" title="0">log.Println("TPKT: StartTLS")

        tlsConn := tls.Client(c.conn, tlsConfig)

        // Set handshake timeout to prevent hanging
        if tcpConn, ok := c.conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                tcpConn.SetReadDeadline(time.Now().Add(30 * time.Second))
                tcpConn.SetWriteDeadline(time.Now().Add(30 * time.Second))
        }</span>

        <span class="cov0" title="0">if err := tlsConn.Handshake(); err != nil </span><span class="cov0" title="0">{
                // Provide more specific error messages
                if insecureSkipVerify </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS handshake failed even with validation skipped: %w", err)
                }</span>

                // Suggest skipping validation for common certificate issues
                <span class="cov0" title="0">if strings.Contains(err.Error(), "certificate") || strings.Contains(err.Error(), "x509") </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS certificate verification failed: %w. Consider using --skip-tls-validation for development environments", err)
                }</span>

                // Handle the specific case where ServerName is missing
                <span class="cov0" title="0">if strings.Contains(err.Error(), "either ServerName or InsecureSkipVerify") </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS configuration error: %w. When using IP addresses, either specify --tls-server-name or use --skip-tls-validation", err)
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("TLS handshake failed: %w", err)</span>
        }

        // Clear any deadlines set for the handshake
        <span class="cov0" title="0">if tcpConn, ok := c.conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                tcpConn.SetReadDeadline(time.Time{})
                tcpConn.SetWriteDeadline(time.Time{})
        }</span>

        <span class="cov0" title="0">c.conn = tlsConn
        c.buffReader = bufio.NewReaderSize(c.conn, readBufferSize)

        return nil</span>
}

func (c *client) getServerName() string <span class="cov10" title="2">{
        if c.conn == nil </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov1" title="1">remoteAddr := c.conn.RemoteAddr().String()
        if remoteAddr == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov1" title="1">host, _, err := net.SplitHostPort(remoteAddr)
        if err != nil </span><span class="cov1" title="1">{
                // Fallback to extracting from hostname if available
                parts := strings.Split(remoteAddr, ":")
                if len(parts) &gt; 0 </span><span class="cov1" title="1">{
                        host = parts[0]
                }</span> else<span class="cov0" title="0"> {
                        return ""
                }</span>
        }

        // Clean up the hostname
        <span class="cov1" title="1">host = strings.TrimSpace(host)
        if host == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // For IP addresses, we might not want to verify the hostname anyway
        // Return empty to let Go use the IP directly
        <span class="cov1" title="1">if net.ParseIP(host) != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Validate hostname format
        <span class="cov1" title="1">if len(host) &gt; 253 </span><span class="cov0" title="0">{ // Maximum hostname length
                return ""
        }</span>

        <span class="cov1" title="1">return host</span>
}

func (c *client) getMinTLSVersion(version string) uint16 <span class="cov0" title="0">{
        switch version </span>{
        case "1.0":<span class="cov0" title="0">
                return tls.VersionTLS10</span>
        case "1.1":<span class="cov0" title="0">
                return tls.VersionTLS11</span>
        case "1.2":<span class="cov0" title="0">
                return tls.VersionTLS12</span>
        case "1.3":<span class="cov0" title="0">
                return tls.VersionTLS13</span>
        default:<span class="cov0" title="0">
                return tls.VersionTLS12</span> // Safe default
        }
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package tpkt

import (
        "io"
)

type Protocol struct {
        conn io.ReadWriteCloser
}

func New(conn io.ReadWriteCloser) *Protocol <span class="cov0" title="0">{
        return &amp;Protocol{
                conn: conn,
        }
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package tpkt

import (
        "bytes"
        "encoding/binary"
        "io"
)

func (p *Protocol) Receive() (io.Reader, error) <span class="cov0" title="0">{
        tpktPacket := make([]byte, headerLen)

        if _, err := p.conn.Read(tpktPacket); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tpktPacket = tpktPacket[2:4]

        dataLen := binary.BigEndian.Uint16(tpktPacket)
        dataLen -= uint16(headerLen)

        data := make([]byte, dataLen)

        if _, err := p.conn.Read(data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return bytes.NewBuffer(data), nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package tpkt

import (
        "bytes"
        "encoding/binary"
)

func (p *Protocol) Send(pduData []byte) error <span class="cov0" title="0">{
        buf := bytes.NewBuffer(make([]byte, 0, headerLen+len(pduData)))
        dataLen := uint16(headerLen + len(pduData))

        buf.Write([]byte{
                0x03, // TPKT version number
                0x00, // reserved for further study
        })

        // TPKT length
        _ = binary.Write(buf, binary.BigEndian, dataLen)

        buf.Write(pduData)

        if _, err := p.conn.Write(buf.Bytes()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package rdp

import (
        "bufio"
)

type ProtocolCode uint8

func (a ProtocolCode) IsFastpath() bool <span class="cov0" title="0">{
        return a&amp;0x3 == 0
}</span>

func (a ProtocolCode) IsX224() bool <span class="cov0" title="0">{
        return a == 3
}</span>

func receiveProtocol(bufReader *bufio.Reader) (ProtocolCode, error) <span class="cov0" title="0">{
        action, err := bufReader.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">err = bufReader.UnreadByte()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return ProtocolCode(action), nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package utf16

import (
        "bytes"
        "encoding/binary"
        "unicode/utf16"
)

func Encode(s string) []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        for _, ch := range utf16.Encode([]rune(s)) </span><span class="cov0" title="0">{
                binary.Write(buf, binary.LittleEndian, ch)
        }</span>

        <span class="cov0" title="0">return buf.Bytes()</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package rdp

import (
        "bytes"
        "encoding/binary"
        "io"
)

type ChannelFlag uint32

const (
        // ChannelFlagFirst CHANNEL_FLAG_FIRST
        ChannelFlagFirst ChannelFlag = 0x00000001

        // ChannelFlagLast CHANNEL_FLAG_LAST
        ChannelFlagLast ChannelFlag = 0x00000002

        // ChannelFlagShowProtocol CHANNEL_FLAG_SHOW_PROTOCOL
        ChannelFlagShowProtocol ChannelFlag = 0x00000010

        // ChannelFlagSuspend CHANNEL_FLAG_SUSPEND
        ChannelFlagSuspend ChannelFlag = 0x00000020

        // ChannelFlagResume CHANNEL_FLAG_RESUME
        ChannelFlagResume ChannelFlag = 0x00000040

        // ChannelFlagShadowPersistent CHANNEL_FLAG_SHADOW_PERSISTENT
        ChannelFlagShadowPersistent ChannelFlag = 0x00000080

        // ChannelFlagCompressed CHANNEL_PACKET_COMPRESSED
        ChannelFlagCompressed ChannelFlag = 0x00200000

        // ChannelFlagAtFront CHANNEL_PACKET_AT_FRONT
        ChannelFlagAtFront ChannelFlag = 0x00400000

        // ChannelFlagFlushed CHANNEL_PACKET_FLUSHED
        ChannelFlagFlushed ChannelFlag = 0x00800000
)

// ChannelPDUHeader CHANNEL_PDU_HEADER
type ChannelPDUHeader struct {
        Flags ChannelFlag
}

func (h *ChannelPDUHeader) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.LittleEndian, uint32(8))
        binary.Write(buf, binary.LittleEndian, uint32(h.Flags))

        return buf.Bytes()
}</span>

func (h *ChannelPDUHeader) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        var (
                err    error
                length uint32
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;length)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.LittleEndian, &amp;h.Flags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package rdp

func (c *client) Write(b []byte) (int, error) <span class="cov0" title="0">{
        return c.conn.Write(b)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package x224

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
        "log"
)

type ConnectionRequest struct {
        li           uint8
        CRCDT        uint8
        DSTREF       uint16
        SRCREF       uint16
        ClassOption  uint8
        VariablePart []byte // unsupported
        UserData     []byte
}

func (pdu *ConnectionRequest) Serialize() []byte <span class="cov8" title="1">{
        const x224FixedPartLen = 6 // without length indicator (LI)

        pdu.li = uint8(x224FixedPartLen + len(pdu.UserData))

        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.BigEndian, pdu.li)
        _ = binary.Write(buf, binary.BigEndian, pdu.CRCDT)
        _ = binary.Write(buf, binary.BigEndian, pdu.DSTREF)
        _ = binary.Write(buf, binary.BigEndian, pdu.SRCREF)
        _ = binary.Write(buf, binary.BigEndian, pdu.ClassOption)

        buf.Write(pdu.UserData)

        return buf.Bytes()
}</span>

type ConnectionConfirm struct {
        LI          uint8
        CCCDT       uint8
        DSTREF      uint16
        SRCREF      uint16
        ClassOption uint8
}

func (pdu *ConnectionConfirm) Deserialize(wire io.Reader) error <span class="cov8" title="1">{
        const (
                fixedPartLen    uint8 = 0x06
                variablePartLen uint8 = 0x08
                packetLen             = fixedPartLen + variablePartLen
        )

        err := binary.Read(wire, binary.BigEndian, &amp;pdu.LI)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if pdu.LI != packetLen </span><span class="cov0" title="0">{
                return ErrSmallConnectionConfirmLength
        }</span>

        <span class="cov8" title="1">err = binary.Read(wire, binary.BigEndian, &amp;pdu.CCCDT)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if pdu.CCCDT&amp;0xf0 != 0xd0 </span><span class="cov0" title="0">{ // connection confirm code
                return ErrWrongConnectionConfirmCode
        }</span>

        <span class="cov8" title="1">err = binary.Read(wire, binary.BigEndian, &amp;pdu.DSTREF)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = binary.Read(wire, binary.BigEndian, &amp;pdu.SRCREF)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = binary.Read(wire, binary.BigEndian, &amp;pdu.ClassOption)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (p *Protocol) Connect(userData []byte) (io.Reader, error) <span class="cov0" title="0">{
        var (
                wire io.Reader
                err  error
        )

        req := ConnectionRequest{
                CRCDT:        0xE0, // TPDU_CONNECTION_REQUEST
                DSTREF:       0,
                SRCREF:       0,
                ClassOption:  0,
                VariablePart: nil,
                UserData:     userData,
        }

        log.Println("X224: Client Connection Request")

        if err = p.tpktConn.Send(req.Serialize()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("client connection request: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("X224: Server Connection Confirm")

        wire, err = p.tpktConn.Receive()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("recieve connection response: %w", err)
        }</span>

        <span class="cov0" title="0">var resp ConnectionConfirm
        if err = resp.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("server connection confirm: %w", err)
        }</span>

        <span class="cov0" title="0">return wire, nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package x224

import "github.com/kulaginds/rdp-html5/internal/pkg/rdp/tpkt"

type Protocol struct {
        tpktConn *tpkt.Protocol
}

func New(tpktConn *tpkt.Protocol) *Protocol <span class="cov0" title="0">{
        return &amp;Protocol{
                tpktConn: tpktConn,
        }
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package x224

import (
        "io"
)

func (p *Protocol) Receive() (io.Reader, error) <span class="cov0" title="0">{
        wire, err := p.tpktConn.Receive()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var resp Data

        if err = resp.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return wire, nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package x224

import (
        "bytes"
        "encoding/binary"
        "io"
)

type Data struct {
        LI       uint8
        DTROA    uint8
        NREOT    uint8
        UserData []byte
}

func (pdu *Data) Serialize() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        binary.Write(buf, binary.BigEndian, pdu.LI)
        binary.Write(buf, binary.BigEndian, pdu.DTROA)
        binary.Write(buf, binary.BigEndian, pdu.NREOT)

        buf.Write(pdu.UserData)

        return buf.Bytes()
}</span>

func (pdu *Data) Deserialize(wire io.Reader) error <span class="cov0" title="0">{
        err := binary.Read(wire, binary.BigEndian, &amp;pdu.LI)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if pdu.LI != dataFixedPartLen </span><span class="cov0" title="0">{
                return ErrWrongDataLength
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.BigEndian, &amp;pdu.DTROA)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Read(wire, binary.BigEndian, &amp;pdu.NREOT)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

const dataFixedPartLen uint8 = 0x02

func (p *Protocol) Send(userData []byte) error <span class="cov0" title="0">{

        req := Data{
                LI:       dataFixedPartLen,
                DTROA:    0xF0, // message type TPDU_DATA
                NREOT:    0x80, // EOT flag is up, which indicates that current TPDU is the last data unit of a complete TPDU sequence
                UserData: userData,
        }

        return p.tpktConn.Send(req.Serialize())
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package main

import (
        "fmt"
        "github.com/kulaginds/rdp-html5/internal/pkg/config"
)

func main() <span class="cov0" title="0">{
        opts := config.LoadOptions{
                Host:              "localhost",
                Port:              "8080",
                LogLevel:          "info",
                ConfigFile:        "",
                SkipTLSValidation: false,
                TLSServerName:     "",
        }
        cfg, err := config.LoadWithOverrides(opts)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Success: Host=%s, Port=%s\n", cfg.Server.Host, cfg.Server.Port)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
