
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rcarmo/rdp-html5/cmd/server/main.go (91.5%)</option>
				
				<option value="file1">github.com/rcarmo/rdp-html5/internal/auth/credssp.go (95.7%)</option>
				
				<option value="file2">github.com/rcarmo/rdp-html5/internal/auth/md4.go (100.0%)</option>
				
				<option value="file3">github.com/rcarmo/rdp-html5/internal/auth/ntlm.go (94.0%)</option>
				
				<option value="file4">github.com/rcarmo/rdp-html5/internal/codec/bitmap.go (79.4%)</option>
				
				<option value="file5">github.com/rcarmo/rdp-html5/internal/codec/decoder.go (94.6%)</option>
				
				<option value="file6">github.com/rcarmo/rdp-html5/internal/codec/encode.go (100.0%)</option>
				
				<option value="file7">github.com/rcarmo/rdp-html5/internal/codec/nscodec.go (37.3%)</option>
				
				<option value="file8">github.com/rcarmo/rdp-html5/internal/codec/planar.go (62.7%)</option>
				
				<option value="file9">github.com/rcarmo/rdp-html5/internal/codec/rfx/differential.go (75.0%)</option>
				
				<option value="file10">github.com/rcarmo/rdp-html5/internal/codec/rfx/dwt.go (100.0%)</option>
				
				<option value="file11">github.com/rcarmo/rdp-html5/internal/codec/rfx/message.go (66.0%)</option>
				
				<option value="file12">github.com/rcarmo/rdp-html5/internal/codec/rfx/quant.go (94.1%)</option>
				
				<option value="file13">github.com/rcarmo/rdp-html5/internal/codec/rfx/rfx.go (100.0%)</option>
				
				<option value="file14">github.com/rcarmo/rdp-html5/internal/codec/rfx/rlgr.go (84.5%)</option>
				
				<option value="file15">github.com/rcarmo/rdp-html5/internal/codec/rfx/tile.go (93.5%)</option>
				
				<option value="file16">github.com/rcarmo/rdp-html5/internal/codec/rfx/ycbcr.go (95.2%)</option>
				
				<option value="file17">github.com/rcarmo/rdp-html5/internal/codec/rle15.go (0.0%)</option>
				
				<option value="file18">github.com/rcarmo/rdp-html5/internal/codec/rle16.go (20.0%)</option>
				
				<option value="file19">github.com/rcarmo/rdp-html5/internal/codec/rle24.go (20.6%)</option>
				
				<option value="file20">github.com/rcarmo/rdp-html5/internal/codec/rle32.go (20.7%)</option>
				
				<option value="file21">github.com/rcarmo/rdp-html5/internal/codec/rle8.go (43.4%)</option>
				
				<option value="file22">github.com/rcarmo/rdp-html5/internal/codec/rle_common.go (76.2%)</option>
				
				<option value="file23">github.com/rcarmo/rdp-html5/internal/codec/security.go (100.0%)</option>
				
				<option value="file24">github.com/rcarmo/rdp-html5/internal/config/config.go (90.8%)</option>
				
				<option value="file25">github.com/rcarmo/rdp-html5/internal/handler/connect.go (69.5%)</option>
				
				<option value="file26">github.com/rcarmo/rdp-html5/internal/logging/logging.go (88.6%)</option>
				
				<option value="file27">github.com/rcarmo/rdp-html5/internal/protocol/audio/channel.go (89.7%)</option>
				
				<option value="file28">github.com/rcarmo/rdp-html5/internal/protocol/audio/rdpsnd.go (71.5%)</option>
				
				<option value="file29">github.com/rcarmo/rdp-html5/internal/protocol/encoding/ber.go (96.1%)</option>
				
				<option value="file30">github.com/rcarmo/rdp-html5/internal/protocol/encoding/per.go (98.4%)</option>
				
				<option value="file31">github.com/rcarmo/rdp-html5/internal/protocol/fastpath/protocol.go (100.0%)</option>
				
				<option value="file32">github.com/rcarmo/rdp-html5/internal/protocol/fastpath/receive.go (91.1%)</option>
				
				<option value="file33">github.com/rcarmo/rdp-html5/internal/protocol/fastpath/send.go (95.0%)</option>
				
				<option value="file34">github.com/rcarmo/rdp-html5/internal/protocol/fastpath/surface_commands.go (95.0%)</option>
				
				<option value="file35">github.com/rcarmo/rdp-html5/internal/protocol/fastpath/update_events.go (77.9%)</option>
				
				<option value="file36">github.com/rcarmo/rdp-html5/internal/protocol/gcc/conference_create_request.go (100.0%)</option>
				
				<option value="file37">github.com/rcarmo/rdp-html5/internal/protocol/gcc/conference_create_response.go (77.5%)</option>
				
				<option value="file38">github.com/rcarmo/rdp-html5/internal/protocol/mcs/attach_user.go (100.0%)</option>
				
				<option value="file39">github.com/rcarmo/rdp-html5/internal/protocol/mcs/connect.go (91.3%)</option>
				
				<option value="file40">github.com/rcarmo/rdp-html5/internal/protocol/mcs/disconnect.go (100.0%)</option>
				
				<option value="file41">github.com/rcarmo/rdp-html5/internal/protocol/mcs/domain.go (100.0%)</option>
				
				<option value="file42">github.com/rcarmo/rdp-html5/internal/protocol/mcs/erect_domain.go (100.0%)</option>
				
				<option value="file43">github.com/rcarmo/rdp-html5/internal/protocol/mcs/join_channels.go (93.9%)</option>
				
				<option value="file44">github.com/rcarmo/rdp-html5/internal/protocol/mcs/protocol.go (50.0%)</option>
				
				<option value="file45">github.com/rcarmo/rdp-html5/internal/protocol/mcs/receive.go (88.0%)</option>
				
				<option value="file46">github.com/rcarmo/rdp-html5/internal/protocol/mcs/send.go (100.0%)</option>
				
				<option value="file47">github.com/rcarmo/rdp-html5/internal/protocol/mcs/types.go (100.0%)</option>
				
				<option value="file48">github.com/rcarmo/rdp-html5/internal/protocol/pdu/basic_settings_exchange.go (81.7%)</option>
				
				<option value="file49">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_bitmap.go (78.7%)</option>
				
				<option value="file50">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_brush.go (88.2%)</option>
				
				<option value="file51">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_cache.go (78.4%)</option>
				
				<option value="file52">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_draw.go (79.8%)</option>
				
				<option value="file53">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_general.go (80.0%)</option>
				
				<option value="file54">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_glyph.go (83.3%)</option>
				
				<option value="file55">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_input.go (79.4%)</option>
				
				<option value="file56">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_misc.go (90.7%)</option>
				
				<option value="file57">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_offscreen.go (82.4%)</option>
				
				<option value="file58">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_order.go (76.8%)</option>
				
				<option value="file59">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_pointer.go (84.2%)</option>
				
				<option value="file60">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_sound.go (85.7%)</option>
				
				<option value="file61">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_surface.go (88.6%)</option>
				
				<option value="file62">github.com/rcarmo/rdp-html5/internal/protocol/pdu/cap_virtual.go (84.6%)</option>
				
				<option value="file63">github.com/rcarmo/rdp-html5/internal/protocol/pdu/capabilities_exchange.go (84.4%)</option>
				
				<option value="file64">github.com/rcarmo/rdp-html5/internal/protocol/pdu/connection_finalization.go (94.2%)</option>
				
				<option value="file65">github.com/rcarmo/rdp-html5/internal/protocol/pdu/connection_initiation.go (87.3%)</option>
				
				<option value="file66">github.com/rcarmo/rdp-html5/internal/protocol/pdu/data.go (91.0%)</option>
				
				<option value="file67">github.com/rcarmo/rdp-html5/internal/protocol/pdu/error_info.go (100.0%)</option>
				
				<option value="file68">github.com/rcarmo/rdp-html5/internal/protocol/pdu/frame_ack.go (100.0%)</option>
				
				<option value="file69">github.com/rcarmo/rdp-html5/internal/protocol/pdu/input_events.go (100.0%)</option>
				
				<option value="file70">github.com/rcarmo/rdp-html5/internal/protocol/pdu/licensing.go (68.8%)</option>
				
				<option value="file71">github.com/rcarmo/rdp-html5/internal/protocol/pdu/secure_settings_exchange.go (94.4%)</option>
				
				<option value="file72">github.com/rcarmo/rdp-html5/internal/protocol/tpkt/protocol.go (100.0%)</option>
				
				<option value="file73">github.com/rcarmo/rdp-html5/internal/protocol/tpkt/receive.go (100.0%)</option>
				
				<option value="file74">github.com/rcarmo/rdp-html5/internal/protocol/tpkt/send.go (100.0%)</option>
				
				<option value="file75">github.com/rcarmo/rdp-html5/internal/protocol/x224/connect.go (100.0%)</option>
				
				<option value="file76">github.com/rcarmo/rdp-html5/internal/protocol/x224/protocol.go (100.0%)</option>
				
				<option value="file77">github.com/rcarmo/rdp-html5/internal/protocol/x224/receive.go (100.0%)</option>
				
				<option value="file78">github.com/rcarmo/rdp-html5/internal/protocol/x224/send.go (100.0%)</option>
				
				<option value="file79">github.com/rcarmo/rdp-html5/internal/rdp/audio.go (45.6%)</option>
				
				<option value="file80">github.com/rcarmo/rdp-html5/internal/rdp/capabilities_exchange.go (90.0%)</option>
				
				<option value="file81">github.com/rcarmo/rdp-html5/internal/rdp/client.go (86.4%)</option>
				
				<option value="file82">github.com/rcarmo/rdp-html5/internal/rdp/close.go (100.0%)</option>
				
				<option value="file83">github.com/rcarmo/rdp-html5/internal/rdp/connect.go (38.5%)</option>
				
				<option value="file84">github.com/rcarmo/rdp-html5/internal/rdp/connection_finalization.go (77.1%)</option>
				
				<option value="file85">github.com/rcarmo/rdp-html5/internal/rdp/frame_ack.go (0.0%)</option>
				
				<option value="file86">github.com/rcarmo/rdp-html5/internal/rdp/get_update.go (20.0%)</option>
				
				<option value="file87">github.com/rcarmo/rdp-html5/internal/rdp/nla.go (9.5%)</option>
				
				<option value="file88">github.com/rcarmo/rdp-html5/internal/rdp/rail.go (85.6%)</option>
				
				<option value="file89">github.com/rcarmo/rdp-html5/internal/rdp/read.go (100.0%)</option>
				
				<option value="file90">github.com/rcarmo/rdp-html5/internal/rdp/refresh_rect.go (100.0%)</option>
				
				<option value="file91">github.com/rcarmo/rdp-html5/internal/rdp/remote_app.go (100.0%)</option>
				
				<option value="file92">github.com/rcarmo/rdp-html5/internal/rdp/send_input_event.go (100.0%)</option>
				
				<option value="file93">github.com/rcarmo/rdp-html5/internal/rdp/tls.go (30.3%)</option>
				
				<option value="file94">github.com/rcarmo/rdp-html5/internal/rdp/types.go (88.9%)</option>
				
				<option value="file95">github.com/rcarmo/rdp-html5/internal/rdp/virtual_channels.go (100.0%)</option>
				
				<option value="file96">github.com/rcarmo/rdp-html5/internal/rdp/write.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "errors"
        "flag"
        "fmt"
        "log"
        "net/http"
        _ "net/http/pprof"
        "os"
        "strings"
        "time"

        "github.com/rcarmo/rdp-html5/internal/config"
        "github.com/rcarmo/rdp-html5/internal/handler"
        "github.com/rcarmo/rdp-html5/internal/logging"
)

const (
        appName    = "RDP HTML5 Client"
        appVersion = "1.0.0"
)

func main() <span class="cov0" title="0">{
        args, action := parseFlags()
        if action != "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if err := run(args); err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
}

// parsedArgs holds the parsed command line arguments
type parsedArgs struct {
        host          string
        port          string
        logLevel      string
        skipTLS       bool
        tlsServerName string
        useNLA        bool
        enableRFX     *bool // nil = use default, non-nil = override
}

// parseFlags parses command line flags and returns the parsed args.
// Returns action string if help/version was shown (caller should return early).
func parseFlags() (parsedArgs, string) <span class="cov0" title="0">{
        return parseFlagsWithArgs(os.Args[1:])
}</span>

// parseFlagsWithArgs parses the given arguments and returns the parsed args.
func parseFlagsWithArgs(args []string) (parsedArgs, string) <span class="cov6" title="6">{
        fs := flag.NewFlagSet("server", flag.ContinueOnError)
        hostFlag := fs.String("host", "", "RDP HTML5 server host")
        portFlag := fs.String("port", "", "RDP HTML5 server port")
        logLevelFlag := fs.String("log-level", "", "log level (debug, info, warn, error)")
        skipTLS := fs.Bool("skip-tls-verify", false, "skip TLS certificate validation")
        tlsServerName := fs.String("tls-server-name", "", "override TLS server name")
        useNLA := fs.Bool("nla", false, "enable Network Level Authentication (NLA/CredSSP)")
        noRFX := fs.Bool("no-rfx", false, "disable RemoteFX codec support")
        helpFlag := fs.Bool("help", false, "show help")
        versionFlag := fs.Bool("version", false, "show version")

        _ = fs.Parse(args)

        if *helpFlag </span><span class="cov1" title="1">{
                showHelp()
                return parsedArgs{}, "help"
        }</span>

        <span class="cov6" title="5">if *versionFlag </span><span class="cov1" title="1">{
                showVersion()
                return parsedArgs{}, "version"
        }</span>

        // Handle RFX flag - only set if explicitly disabled
        <span class="cov5" title="4">var enableRFX *bool
        if *noRFX </span><span class="cov1" title="1">{
                rfxValue := false
                enableRFX = &amp;rfxValue
        }</span>

        <span class="cov5" title="4">return parsedArgs{
                host:          strings.TrimSpace(*hostFlag),
                port:          strings.TrimSpace(*portFlag),
                logLevel:      strings.TrimSpace(*logLevelFlag),
                skipTLS:       *skipTLS,
                tlsServerName: strings.TrimSpace(*tlsServerName),
                useNLA:        *useNLA,
                enableRFX:     enableRFX,
        }, ""</span>
}

// run starts the server with the given arguments
func run(args parsedArgs) error <span class="cov3" title="2">{
        opts := config.LoadOptions{
                Host:              args.host,
                Port:              args.port,
                LogLevel:          args.logLevel,
                SkipTLSValidation: args.skipTLS,
                TLSServerName:     args.tlsServerName,
                UseNLA:            args.useNLA,
                EnableRFX:         args.enableRFX,
        }

        cfg, err := config.LoadWithOverrides(opts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov3" title="2">setupLogging(cfg.Logging)

        server := createServer(cfg)
        rfxStatus := "enabled"
        if !cfg.RDP.EnableRFX </span><span class="cov0" title="0">{
                rfxStatus = "disabled"
        }</span>
        <span class="cov3" title="2">logging.Info("Starting server on %s:%s (TLS=%t, RFX=%s)", cfg.Server.Host, cfg.Server.Port, cfg.Security.EnableTLS, rfxStatus)

        if err := startServer(server, cfg); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func createServer(cfg *config.Config) *http.Server <span class="cov5" title="4">{
        addr := fmt.Sprintf("%s:%s", cfg.Server.Host, cfg.Server.Port)

        mux := http.NewServeMux()
        mux.Handle("/", http.FileServer(http.Dir("./web")))
        mux.HandleFunc("/connect", handler.Connect)

        h := applySecurityMiddleware(mux, cfg)
        h = requestLoggingMiddleware(h)

        return &amp;http.Server{
                Addr:         addr,
                Handler:      h,
                ReadTimeout:  cfg.Server.ReadTimeout,
                WriteTimeout: cfg.Server.WriteTimeout,
                IdleTimeout:  cfg.Server.IdleTimeout,
        }
}</span>

func applySecurityMiddleware(next http.Handler, cfg *config.Config) http.Handler <span class="cov7" title="7">{
        if cfg == nil </span><span class="cov1" title="1">{
                return securityHeadersMiddleware(corsMiddleware(next, nil))
        }</span>

        <span class="cov6" title="6">h := next
        if cfg.Security.EnableRateLimit </span><span class="cov5" title="4">{
                h = rateLimitMiddleware(h, cfg.Security.RateLimitPerMinute)
        }</span>
        <span class="cov6" title="6">h = corsMiddleware(h, cfg.Security.AllowedOrigins)
        h = securityHeadersMiddleware(h)

        return h</span>
}

func securityHeadersMiddleware(next http.Handler) http.Handler <span class="cov7" title="8">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov5" title="4">{
                w.Header().Set("X-Content-Type-Options", "nosniff")
                w.Header().Set("X-Frame-Options", "DENY")
                w.Header().Set("X-XSS-Protection", "1; mode=block")
                w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
                w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")
                // Allow inline scripts/styles and WASM for the single-page UI
                // Allow data: URIs for img-src to support custom cursor images
                w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self' 'unsafe-inline' 'wasm-unsafe-eval'; style-src 'self' 'unsafe-inline'; connect-src 'self' ws: wss:; img-src 'self' data:")

                next.ServeHTTP(w, r)
        }</span>)
}

func corsMiddleware(next http.Handler, allowedOrigins []string) http.Handler <span class="cov9" title="14">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="10">{
                origin := r.Header.Get("Origin")
                if isOriginAllowed(origin, allowedOrigins, r.Host) </span><span class="cov7" title="8">{
                        w.Header().Set("Access-Control-Allow-Origin", origin)
                        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
                        w.Header().Set("Access-Control-Allow-Credentials", "true")
                }</span>

                <span class="cov8" title="10">if r.Method == http.MethodOptions </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov8" title="9">next.ServeHTTP(w, r)</span>
        })
}

func isOriginAllowed(origin string, allowedOrigins []string, host string) bool <span class="cov10" title="15">{
        if origin == "" </span><span class="cov3" title="2">{
                return false
        }</span>

        <span class="cov9" title="13">for _, allowed := range allowedOrigins </span><span class="cov8" title="9">{
                if strings.TrimSpace(allowed) == origin </span><span class="cov7" title="7">{
                        return true
                }</span>
        }

        // When no ALLOWED_ORIGINS configured, allow all origins (development mode)
        // For production, explicitly set ALLOWED_ORIGINS
        <span class="cov6" title="6">if len(allowedOrigins) == 0 </span><span class="cov5" title="4">{
                return true
        }</span>

        <span class="cov3" title="2">return false</span>
}

func rateLimitMiddleware(next http.Handler, _ int) http.Handler <span class="cov6" title="5">{
        // Simplified placeholder: production implementation should enforce rate limits
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov3" title="2">{
                next.ServeHTTP(w, r)
        }</span>)
}

func setupLogging(cfg config.LoggingConfig) <span class="cov6" title="6">{
        log.SetFlags(log.LstdFlags | log.LUTC)
        log.SetOutput(log.Writer())
        
        // Set leveled logging level - default to "info" if not configured
        level := cfg.Level
        if level == "" </span><span class="cov0" title="0">{
                level = "info"
        }</span>
        <span class="cov6" title="6">logging.SetLevelFromString(level)</span>
}

func requestLoggingMiddleware(next http.Handler) http.Handler <span class="cov6" title="5">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov1" title="1">{
                start := time.Now()
                next.ServeHTTP(w, r)
                logging.Debug("%s %s %s %s", r.RemoteAddr, r.Method, r.URL.Path, time.Since(start))
        }</span>)
}

func startServer(server *http.Server, _ *config.Config) error <span class="cov6" title="6">{
        if server == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("server is nil")
        }</span>

        <span class="cov6" title="5">err := server.ListenAndServe()
        if errors.Is(err, http.ErrServerClosed) </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov4" title="3">return err</span>
}

func showHelp() <span class="cov3" title="2">{
        fmt.Println(appName)
        fmt.Println("USAGE: rdp-html5 [options]")
        fmt.Println("OPTIONS:")
        fmt.Println("  -host               Set server listen host (default 0.0.0.0)")
        fmt.Println("  -port               Set server listen port (default 8080)")
        fmt.Println("  -log-level          Set log level (debug, info, warn, error)")
        fmt.Println("  -skip-tls-verify    Skip TLS certificate validation")
        fmt.Println("  -tls-server-name    Override TLS server name")
        fmt.Println("  -nla                Enable Network Level Authentication")
        fmt.Println("  -no-rfx             Disable RemoteFX codec support")
        fmt.Println("  -version            Show version information")
        fmt.Println("  -help               Show this help message")
        fmt.Println("ENVIRONMENT VARIABLES: SERVER_HOST, SERVER_PORT, LOG_LEVEL, SKIP_TLS_VALIDATION, TLS_SERVER_NAME, RDP_ENABLE_RFX")
        fmt.Println("EXAMPLES: rdp-html5 -host 0.0.0.0 -port 8080")
}</span>

func showVersion() <span class="cov3" title="2">{
        fmt.Printf("%s %s\n", appName, appVersion)
        fmt.Println("Built with Go", time.Now().Year())
        fmt.Println("Protocol: RDP 10.x")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "bytes"
        "crypto/sha256"
)

// TSRequest represents a decoded CredSSP request
type TSRequest struct {
        Version      int
        NegoTokens   []NegoToken
        AuthInfo     []byte
        PubKeyAuth   []byte
        ClientNonce  []byte // For version 5+
        ErrorCode    uint32 // For version 3+
        ServerNonce  []byte // Received from server in version 5+
}

// Magic strings for CredSSP version 5+ public key hashing (includes null terminator)
var (
        ClientServerHashMagic = []byte("CredSSP Client-To-Server Binding Hash\x00")
        ServerClientHashMagic = []byte("CredSSP Server-To-Client Binding Hash\x00")
)

// ComputeClientPubKeyAuth computes the pubKeyAuth for the client
// For version 2-4: just encrypt the public key
// For version 5+: compute SHA256(magic || nonce || pubKey) and encrypt
func ComputeClientPubKeyAuth(version int, pubKey, nonce []byte) []byte <span class="cov3" title="4">{
        if version &gt;= 5 &amp;&amp; len(nonce) &gt; 0 </span><span class="cov2" title="2">{
                // Version 5+: Hash-based binding
                // Per FreeRDP: SHA256(ClientServerHashMagic || ClientNonce || SubjectPublicKey)
                h := sha256.New()
                h.Write(ClientServerHashMagic)
                h.Write(nonce)
                h.Write(pubKey)
                return h.Sum(nil)
        }</span>
        // Version 2-4: Direct public key (will be encrypted by caller)
        <span class="cov2" title="2">return pubKey</span>
}

// VerifyServerPubKeyAuth verifies the server's pubKeyAuth response
// For version 2-4: server sends pubKey with first byte incremented by 1
// For version 5+: server sends SHA256(ServerClientHashMagic || nonce || pubKey)
func VerifyServerPubKeyAuth(version int, serverPubKeyAuth, clientPubKey, nonce []byte) bool <span class="cov3" title="4">{
        if version &gt;= 5 &amp;&amp; len(nonce) &gt; 0 </span><span class="cov1" title="1">{
                // Version 5+: Hash-based verification
                h := sha256.New()
                h.Write(ServerClientHashMagic)
                h.Write(nonce)
                h.Write(clientPubKey)
                expected := h.Sum(nil)
                return bytes.Equal(serverPubKeyAuth, expected)
        }</span>
        // Version 2-4: Server sends pubKey with first byte + 1
        <span class="cov3" title="3">if len(serverPubKeyAuth) != len(clientPubKey) </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov2" title="2">expected := make([]byte, len(clientPubKey))
        copy(expected, clientPubKey)
        expected[0]++
        return bytes.Equal(serverPubKeyAuth, expected)</span>
}

// NegoToken wraps an NTLM message
type NegoToken struct {
        Data []byte
}

// EncodeTSRequest encodes a TSRequest with NTLM messages, auth info, and/or public key auth
// Per MS-CSSP, TSRequest is:
//
//        TSRequest ::= SEQUENCE {
//           version    [0] INTEGER,
//           negoTokens [1] NegoData OPTIONAL,
//           authInfo   [2] OCTET STRING OPTIONAL,
//           pubKeyAuth [3] OCTET STRING OPTIONAL,
//           errorCode  [4] INTEGER OPTIONAL,       -- version 3+
//           clientNonce [5] OCTET STRING OPTIONAL, -- version 5+
//        }
//        NegoData ::= SEQUENCE OF NegoDataItem
//        NegoDataItem ::= SEQUENCE {
//           negoToken [0] OCTET STRING
//        }
func EncodeTSRequest(ntlmMessages [][]byte, authInfo []byte, pubKeyAuth []byte) []byte <span class="cov5" title="12">{
        return EncodeTSRequestWithNonce(ntlmMessages, authInfo, pubKeyAuth, nil)
}</span>

// EncodeTSRequestWithNonce encodes a TSRequest with optional client nonce (version 5+)
// The version parameter should be set by the caller to match the negotiated version
func EncodeTSRequestWithNonce(ntlmMessages [][]byte, authInfo []byte, pubKeyAuth []byte, clientNonce []byte) []byte <span class="cov5" title="12">{
        return EncodeTSRequestWithVersion(6, ntlmMessages, authInfo, pubKeyAuth, clientNonce)
}</span>

// EncodeTSRequestWithVersion encodes a TSRequest with explicit version control
func EncodeTSRequestWithVersion(version int, ntlmMessages [][]byte, authInfo []byte, pubKeyAuth []byte, clientNonce []byte) []byte <span class="cov5" title="12">{
        buf := &amp;bytes.Buffer{}

        // Build the inner content first
        inner := &amp;bytes.Buffer{}

        // [0] version INTEGER
        versionBytes := encodeContextTag(0, encodeInteger(version))
        inner.Write(versionBytes)

        // [1] negoTokens NegoData OPTIONAL
        if len(ntlmMessages) &gt; 0 </span><span class="cov4" title="5">{
                negoData := &amp;bytes.Buffer{}
                for _, msg := range ntlmMessages </span><span class="cov4" title="6">{
                        // NegoDataItem ::= SEQUENCE { negoToken [0] OCTET STRING }
                        item := encodeSequence(encodeContextTag(0, encodeOctetString(msg)))
                        negoData.Write(item)
                }</span>
                // NegoData ::= SEQUENCE OF NegoDataItem
                <span class="cov4" title="5">negoTokens := encodeContextTag(1, encodeSequence(negoData.Bytes()))
                inner.Write(negoTokens)</span>
        }

        // [2] authInfo OCTET STRING OPTIONAL
        <span class="cov5" title="12">if len(authInfo) &gt; 0 </span><span class="cov3" title="4">{
                authInfoBytes := encodeContextTag(2, encodeOctetString(authInfo))
                inner.Write(authInfoBytes)
        }</span>

        // [3] pubKeyAuth OCTET STRING OPTIONAL
        <span class="cov5" title="12">if len(pubKeyAuth) &gt; 0 </span><span class="cov3" title="4">{
                pubKeyAuthBytes := encodeContextTag(3, encodeOctetString(pubKeyAuth))
                inner.Write(pubKeyAuthBytes)
        }</span>

        // [5] clientNonce OCTET STRING OPTIONAL (version 5+)
        <span class="cov5" title="12">if len(clientNonce) &gt; 0 </span><span class="cov0" title="0">{
                clientNonceBytes := encodeContextTag(5, encodeOctetString(clientNonce))
                inner.Write(clientNonceBytes)
        }</span>

        // Wrap in SEQUENCE
        <span class="cov5" title="12">buf.Write(encodeSequence(inner.Bytes()))
        return buf.Bytes()</span>
}

// DecodeTSRequest decodes a TSRequest from DER bytes
func DecodeTSRequest(data []byte) (*TSRequest, error) <span class="cov6" title="16">{
        req := &amp;TSRequest{}

        // Parse outer SEQUENCE
        _, content, err := parseTag(data)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        // Parse fields
        <span class="cov6" title="14">offset := 0
        for offset &lt; len(content) </span><span class="cov7" title="26">{
                tag, value, err := parseTag(content[offset:])
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov7" title="26">ctxTag := tag &amp; 0x1F

                switch ctxTag </span>{
                case 0:<span class="cov5" title="13"> // version
                        req.Version = parseInteger(value)</span>
                case 1:<span class="cov4" title="5"> // negoTokens
                        req.NegoTokens = parseNegoTokens(value)</span>
                case 2:<span class="cov3" title="4"> // authInfo
                        _, inner, _ := parseTag(value)
                        req.AuthInfo = inner</span>
                case 3:<span class="cov3" title="4"> // pubKeyAuth
                        _, inner, _ := parseTag(value)
                        req.PubKeyAuth = inner</span>
                case 4:<span class="cov0" title="0"> // errorCode (version 3+)
                        req.ErrorCode = uint32(parseInteger(value))</span>
                case 5:<span class="cov0" title="0"> // clientNonce/serverNonce (version 5+)
                        _, inner, _ := parseTag(value)
                        req.ServerNonce = inner</span>
                }

                <span class="cov7" title="26">offset += tagLen(content[offset:])</span>
        }

        <span class="cov6" title="14">return req, nil</span>
}

// EncodeCredentials encodes TSCredentials with password authentication
//
//        TSCredentials ::= SEQUENCE {
//           credType    [0] INTEGER,
//           credentials [1] OCTET STRING
//        }
//        TSPasswordCreds ::= SEQUENCE {
//           domainName [0] OCTET STRING,
//           userName   [1] OCTET STRING,
//           password   [2] OCTET STRING
//        }
func EncodeCredentials(domain, username, password []byte) []byte <span class="cov1" title="1">{
        // Encode TSPasswordCreds
        passCreds := &amp;bytes.Buffer{}
        passCreds.Write(encodeContextTag(0, encodeOctetString(domain)))
        passCreds.Write(encodeContextTag(1, encodeOctetString(username)))
        passCreds.Write(encodeContextTag(2, encodeOctetString(password)))
        passCredsSeq := encodeSequence(passCreds.Bytes())

        // Encode TSCredentials
        creds := &amp;bytes.Buffer{}
        creds.Write(encodeContextTag(0, encodeInteger(1))) // credType = 1 (password)
        creds.Write(encodeContextTag(1, encodeOctetString(passCredsSeq)))

        return encodeSequence(creds.Bytes())
}</span>

// ASN.1 DER encoding helpers

func encodeLength(length int) []byte <span class="cov9" title="97">{
        if length &lt; 128 </span><span class="cov9" title="92">{
                return []byte{byte(length)}
        }</span>
        <span class="cov4" title="5">if length &lt; 256 </span><span class="cov2" title="2">{
                return []byte{0x81, byte(length)}
        }</span>
        <span class="cov3" title="3">if length &lt; 65536 </span><span class="cov2" title="2">{
                return []byte{0x82, byte(length &gt;&gt; 8), byte(length)}
        }</span>
        <span class="cov1" title="1">return []byte{0x83, byte(length &gt;&gt; 16), byte(length &gt;&gt; 8), byte(length)}</span>
}

func encodeSequence(data []byte) []byte <span class="cov7" title="29">{
        buf := &amp;bytes.Buffer{}
        buf.WriteByte(0x30) // SEQUENCE tag
        buf.Write(encodeLength(len(data)))
        buf.Write(data)
        return buf.Bytes()
}</span>

func encodeContextTag(tag int, data []byte) []byte <span class="cov8" title="40">{
        buf := &amp;bytes.Buffer{}
        buf.WriteByte(0xA0 | byte(tag)) // Context-specific constructed tag
        buf.Write(encodeLength(len(data)))
        buf.Write(data)
        return buf.Bytes()
}</span>

func encodeOctetString(data []byte) []byte <span class="cov6" title="21">{
        buf := &amp;bytes.Buffer{}
        buf.WriteByte(0x04) // OCTET STRING tag
        buf.Write(encodeLength(len(data)))
        buf.Write(data)
        return buf.Bytes()
}</span>

func encodeInteger(val int) []byte <span class="cov6" title="19">{
        buf := &amp;bytes.Buffer{}
        buf.WriteByte(0x02) // INTEGER tag
        if val &lt; 128 </span><span class="cov6" title="16">{
                buf.WriteByte(1)
                buf.WriteByte(byte(val))
        }</span> else<span class="cov3" title="3"> if val &lt; 256 </span><span class="cov2" title="2">{
                buf.WriteByte(2)
                buf.WriteByte(0)
                buf.WriteByte(byte(val))
        }</span> else<span class="cov1" title="1"> {
                buf.WriteByte(2)
                buf.WriteByte(byte(val &gt;&gt; 8))
                buf.WriteByte(byte(val))
        }</span>
        <span class="cov6" title="19">return buf.Bytes()</span>
}

// DER parsing helpers

func parseTag(data []byte) (byte, []byte, error) <span class="cov10" title="103">{
        if len(data) &lt; 2 </span><span class="cov4" title="5">{
                return 0, nil, bytes.ErrTooLarge
        }</span>
        <span class="cov9" title="98">tag := data[0]
        lenByte := data[1]
        offset := 2
        var length int

        if lenByte &lt; 128 </span><span class="cov9" title="94">{
                length = int(lenByte)
        }</span> else<span class="cov3" title="4"> {
                numBytes := int(lenByte &amp; 0x7F)
                if offset+numBytes &gt; len(data) </span><span class="cov1" title="1">{
                        return 0, nil, bytes.ErrTooLarge
                }</span>
                <span class="cov3" title="3">for i := 0; i &lt; numBytes; i++ </span><span class="cov3" title="4">{
                        length = (length &lt;&lt; 8) | int(data[offset])
                        offset++
                }</span>
        }

        <span class="cov9" title="97">if offset+length &gt; len(data) </span><span class="cov2" title="2">{
                return 0, nil, bytes.ErrTooLarge
        }</span>
        <span class="cov9" title="95">return tag, data[offset : offset+length], nil</span>
}

func tagLen(data []byte) int <span class="cov8" title="37">{
        if len(data) &lt; 2 </span><span class="cov2" title="2">{
                return len(data)
        }</span>
        <span class="cov7" title="35">lenByte := data[1]
        offset := 2
        var length int

        if lenByte &lt; 128 </span><span class="cov7" title="34">{
                length = int(lenByte)
        }</span> else<span class="cov1" title="1"> {
                numBytes := int(lenByte &amp; 0x7F)
                offset += numBytes
                for i := 0; i &lt; numBytes &amp;&amp; 2+i &lt; len(data); i++ </span><span class="cov1" title="1">{
                        length = (length &lt;&lt; 8) | int(data[2+i])
                }</span>
        }
        <span class="cov7" title="35">return offset + length</span>
}

func parseInteger(data []byte) int <span class="cov6" title="17">{
        _, value, err := parseTag(data)
        if err != nil || len(value) == 0 </span><span class="cov3" title="3">{
                return 0
        }</span>
        <span class="cov6" title="14">result := 0
        for _, b := range value </span><span class="cov6" title="15">{
                result = (result &lt;&lt; 8) | int(b)
        }</span>
        <span class="cov6" title="14">return result</span>
}

func parseNegoTokens(data []byte) []NegoToken <span class="cov4" title="7">{
        var tokens []NegoToken

        // Parse outer SEQUENCE
        _, content, err := parseTag(data)
        if err != nil </span><span class="cov1" title="1">{
                return tokens
        }</span>

        // Parse each NegoDataItem
        <span class="cov4" title="6">offset := 0
        for offset &lt; len(content) </span><span class="cov4" title="7">{
                // SEQUENCE (NegoDataItem)
                _, item, err := parseTag(content[offset:])
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }

                // [0] negoToken
                <span class="cov4" title="7">_, tokenData, err := parseTag(item)
                if err == nil </span><span class="cov4" title="7">{
                        _, octetStr, err := parseTag(tokenData)
                        if err == nil </span><span class="cov4" title="7">{
                                tokens = append(tokens, NegoToken{Data: octetStr})
                        }</span>
                }

                <span class="cov4" title="7">offset += tagLen(content[offset:])</span>
        }

        <span class="cov4" title="6">return tokens</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "encoding/binary"
)

func md4(data []byte) []byte <span class="cov4" title="44">{
        var a, b, c, d uint32 = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476

        // Padding
        origLen := uint64(len(data))
        data = append(data, 0x80)
        for (len(data)+8)%64 != 0 </span><span class="cov8" title="1901">{
                data = append(data, 0x00)
        }</span>
        // Append original length in bits as 64-bit little-endian
        <span class="cov4" title="44">lenBits := origLen * 8
        lenBytes := make([]byte, 8)
        binary.LittleEndian.PutUint64(lenBytes, lenBits)
        data = append(data, lenBytes...)

        // Process each 64-byte block
        for i := 0; i &lt; len(data); i += 64 </span><span class="cov6" title="210">{
                block := data[i : i+64]
                var x [16]uint32
                for j := 0; j &lt; 16; j++ </span><span class="cov8" title="3360">{
                        x[j] = binary.LittleEndian.Uint32(block[j*4:])
                }</span>

                <span class="cov6" title="210">aa, bb, cc, dd := a, b, c, d

                // Round 1
                a = md4Round1(a, b, c, d, x[0], 3)
                d = md4Round1(d, a, b, c, x[1], 7)
                c = md4Round1(c, d, a, b, x[2], 11)
                b = md4Round1(b, c, d, a, x[3], 19)
                a = md4Round1(a, b, c, d, x[4], 3)
                d = md4Round1(d, a, b, c, x[5], 7)
                c = md4Round1(c, d, a, b, x[6], 11)
                b = md4Round1(b, c, d, a, x[7], 19)
                a = md4Round1(a, b, c, d, x[8], 3)
                d = md4Round1(d, a, b, c, x[9], 7)
                c = md4Round1(c, d, a, b, x[10], 11)
                b = md4Round1(b, c, d, a, x[11], 19)
                a = md4Round1(a, b, c, d, x[12], 3)
                d = md4Round1(d, a, b, c, x[13], 7)
                c = md4Round1(c, d, a, b, x[14], 11)
                b = md4Round1(b, c, d, a, x[15], 19)

                // Round 2
                a = md4Round2(a, b, c, d, x[0], 3)
                d = md4Round2(d, a, b, c, x[4], 5)
                c = md4Round2(c, d, a, b, x[8], 9)
                b = md4Round2(b, c, d, a, x[12], 13)
                a = md4Round2(a, b, c, d, x[1], 3)
                d = md4Round2(d, a, b, c, x[5], 5)
                c = md4Round2(c, d, a, b, x[9], 9)
                b = md4Round2(b, c, d, a, x[13], 13)
                a = md4Round2(a, b, c, d, x[2], 3)
                d = md4Round2(d, a, b, c, x[6], 5)
                c = md4Round2(c, d, a, b, x[10], 9)
                b = md4Round2(b, c, d, a, x[14], 13)
                a = md4Round2(a, b, c, d, x[3], 3)
                d = md4Round2(d, a, b, c, x[7], 5)
                c = md4Round2(c, d, a, b, x[11], 9)
                b = md4Round2(b, c, d, a, x[15], 13)

                // Round 3
                a = md4Round3(a, b, c, d, x[0], 3)
                d = md4Round3(d, a, b, c, x[8], 9)
                c = md4Round3(c, d, a, b, x[4], 11)
                b = md4Round3(b, c, d, a, x[12], 15)
                a = md4Round3(a, b, c, d, x[2], 3)
                d = md4Round3(d, a, b, c, x[10], 9)
                c = md4Round3(c, d, a, b, x[6], 11)
                b = md4Round3(b, c, d, a, x[14], 15)
                a = md4Round3(a, b, c, d, x[1], 3)
                d = md4Round3(d, a, b, c, x[9], 9)
                c = md4Round3(c, d, a, b, x[5], 11)
                b = md4Round3(b, c, d, a, x[13], 15)
                a = md4Round3(a, b, c, d, x[3], 3)
                d = md4Round3(d, a, b, c, x[11], 9)
                c = md4Round3(c, d, a, b, x[7], 11)
                b = md4Round3(b, c, d, a, x[15], 15)

                a += aa
                b += bb
                c += cc
                d += dd</span>
        }

        // Output
        <span class="cov4" title="44">result := make([]byte, 16)
        binary.LittleEndian.PutUint32(result[0:], a)
        binary.LittleEndian.PutUint32(result[4:], b)
        binary.LittleEndian.PutUint32(result[8:], c)
        binary.LittleEndian.PutUint32(result[12:], d)
        return result</span>
}

func md4F(x, y, z uint32) uint32 <span class="cov8" title="3360">{ return (x &amp; y) | (^x &amp; z) }</span>
func md4G(x, y, z uint32) uint32 <span class="cov8" title="3360">{ return (x &amp; y) | (x &amp; z) | (y &amp; z) }</span>
func md4H(x, y, z uint32) uint32 <span class="cov8" title="3360">{ return x ^ y ^ z }</span>

func rotl(x uint32, n uint) uint32 <span class="cov10" title="10080">{ return (x &lt;&lt; n) | (x &gt;&gt; (32 - n)) }</span>

func md4Round1(a, b, c, d, x uint32, s uint) uint32 <span class="cov8" title="3360">{
        return rotl(a+md4F(b, c, d)+x, s)
}</span>

func md4Round2(a, b, c, d, x uint32, s uint) uint32 <span class="cov8" title="3360">{
        return rotl(a+md4G(b, c, d)+x+0x5A827999, s)
}</span>

func md4Round3(a, b, c, d, x uint32, s uint) uint32 <span class="cov8" title="3360">{
        return rotl(a+md4H(b, c, d)+x+0x6ED9EBA1, s)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package auth implements authentication for RDP NLA (NTLMv2 + CredSSP)
package auth

import (
        "bytes"
        "crypto/hmac"
        "crypto/md5"
        "crypto/rand"
        "crypto/rc4"
        "encoding/binary"
        "time"
        "unicode/utf16"
)

// NTLM negotiate flags
const (
        NTLMSSP_NEGOTIATE_56                       = 0x80000000
        NTLMSSP_NEGOTIATE_KEY_EXCH                 = 0x40000000
        NTLMSSP_NEGOTIATE_128                      = 0x20000000
        NTLMSSP_NEGOTIATE_VERSION                  = 0x02000000
        NTLMSSP_NEGOTIATE_TARGET_INFO              = 0x00800000
        NTLMSSP_REQUEST_NON_NT_SESSION_KEY         = 0x00400000
        NTLMSSP_NEGOTIATE_IDENTIFY                 = 0x00100000
        NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY = 0x00080000
        NTLMSSP_TARGET_TYPE_SERVER                 = 0x00020000
        NTLMSSP_TARGET_TYPE_DOMAIN                 = 0x00010000
        NTLMSSP_NEGOTIATE_ALWAYS_SIGN              = 0x00008000
        NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED = 0x00002000
        NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED      = 0x00001000
        NTLMSSP_NEGOTIATE_NTLM                     = 0x00000200
        NTLMSSP_NEGOTIATE_LM_KEY                   = 0x00000080
        NTLMSSP_NEGOTIATE_DATAGRAM                 = 0x00000040
        NTLMSSP_NEGOTIATE_SEAL                     = 0x00000020
        NTLMSSP_NEGOTIATE_SIGN                     = 0x00000010
        NTLMSSP_REQUEST_TARGET                     = 0x00000004
        NTLM_NEGOTIATE_OEM                         = 0x00000002
        NTLMSSP_NEGOTIATE_UNICODE                  = 0x00000001
)

// AV Pair IDs
const (
        MsvAvEOL             = 0x0000
        MsvAvNbComputerName  = 0x0001
        MsvAvNbDomainName    = 0x0002
        MsvAvDnsComputerName = 0x0003
        MsvAvDnsDomainName   = 0x0004
        MsvAvDnsTreeName     = 0x0005
        MsvAvFlags           = 0x0006
        MsvAvTimestamp       = 0x0007
)

var ntlmSignature = []byte{'N', 'T', 'L', 'M', 'S', 'S', 'P', 0x00}

// NTLMv2 handles NTLMv2 authentication
type NTLMv2 struct {
        domain        string
        user          string
        password      string
        respKeyNT     []byte
        respKeyLM     []byte
        enableUnicode bool
        negotiateMsg  []byte
        challengeMsg  *ChallengeMessage
        authMsg       []byte
}

// NewNTLMv2 creates a new NTLMv2 authentication context
func NewNTLMv2(domain, user, password string) *NTLMv2 <span class="cov4" title="10">{
        n := &amp;NTLMv2{
                domain:   domain,
                user:     user,
                password: password,
        }
        n.respKeyNT = ntowfv2(password, user, domain)
        n.respKeyLM = lmowfv2(password, user, domain)
        return n
}</span>

// GetNegotiateMessage returns the NTLM Type 1 (Negotiate) message
func (n *NTLMv2) GetNegotiateMessage() []byte <span class="cov3" title="4">{
        flags := uint32(
                NTLMSSP_NEGOTIATE_KEY_EXCH |
                        NTLMSSP_NEGOTIATE_128 |
                        NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY |
                        NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                        NTLMSSP_NEGOTIATE_NTLM |
                        NTLMSSP_NEGOTIATE_SEAL |
                        NTLMSSP_NEGOTIATE_SIGN |
                        NTLMSSP_REQUEST_TARGET |
                        NTLMSSP_NEGOTIATE_UNICODE |
                        NTLMSSP_NEGOTIATE_VERSION)

        buf := &amp;bytes.Buffer{}
        buf.Write(ntlmSignature)
        _ = binary.Write(buf, binary.LittleEndian, uint32(1)) // MessageType
        _ = binary.Write(buf, binary.LittleEndian, flags)
        // DomainNameFields (8 bytes - all zeros)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // DomainNameLen
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // DomainNameMaxLen
        _ = binary.Write(buf, binary.LittleEndian, uint32(0)) // DomainNameBufferOffset
        // WorkstationFields (8 bytes - all zeros)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // WorkstationLen
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // WorkstationMaxLen
        _ = binary.Write(buf, binary.LittleEndian, uint32(0)) // WorkstationBufferOffset
        // Version (8 bytes)
        buf.Write([]byte{0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F}) // Windows Vista, NTLMSSP_REVISION_W2K3

        n.negotiateMsg = buf.Bytes()
        return n.negotiateMsg
}</span>

// ChallengeMessage represents NTLM Type 2 message
type ChallengeMessage struct {
        NegotiateFlags  uint32
        ServerChallenge [8]byte
        TargetInfo      []byte
        Timestamp       []byte
        RawData         []byte // Original raw data for MIC computation
}

// ParseChallengeMessage parses an NTLM Type 2 (Challenge) message
func ParseChallengeMessage(data []byte) (*ChallengeMessage, error) <span class="cov3" title="6">{
        if len(data) &lt; 56 </span><span class="cov2" title="2">{
                return nil, bytes.ErrTooLarge
        }</span>

        // Store raw data for MIC computation
        <span class="cov3" title="4">rawData := make([]byte, len(data))
        copy(rawData, data)

        // Skip signature (8) + messageType (4)
        offset := 12

        // TargetNameFields
        targetNameLen := binary.LittleEndian.Uint16(data[offset:])
        offset += 2
        offset += 2 // MaxLen
        targetNameOffset := binary.LittleEndian.Uint32(data[offset:])
        offset += 4
        _ = targetNameLen
        _ = targetNameOffset

        // NegotiateFlags
        flags := binary.LittleEndian.Uint32(data[offset:])
        offset += 4

        // ServerChallenge
        var challenge [8]byte
        copy(challenge[:], data[offset:offset+8])
        offset += 8

        // Reserved (8 bytes)
        offset += 8

        // TargetInfoFields
        targetInfoLen := binary.LittleEndian.Uint16(data[offset:])
        offset += 2
        offset += 2 // MaxLen
        targetInfoOffset := binary.LittleEndian.Uint32(data[offset:])

        msg := &amp;ChallengeMessage{
                NegotiateFlags:  flags,
                ServerChallenge: challenge,
                RawData:         rawData,
        }

        // Extract target info if present
        if targetInfoLen &gt; 0 &amp;&amp; int(targetInfoOffset)+int(targetInfoLen) &lt;= len(data) </span><span class="cov2" title="2">{
                msg.TargetInfo = data[targetInfoOffset : targetInfoOffset+uint32(targetInfoLen)]
                msg.Timestamp = extractTimestamp(msg.TargetInfo)
        }</span>

        <span class="cov3" title="4">return msg, nil</span>
}

func extractTimestamp(targetInfo []byte) []byte <span class="cov3" title="6">{
        offset := 0
        for offset+4 &lt;= len(targetInfo) </span><span class="cov3" title="6">{
                avID := binary.LittleEndian.Uint16(targetInfo[offset:])
                avLen := binary.LittleEndian.Uint16(targetInfo[offset+2:])
                offset += 4

                if avID == MsvAvEOL </span><span class="cov1" title="1">{
                        break</span>
                }
                <span class="cov3" title="5">if avID == MsvAvTimestamp &amp;&amp; avLen == 8 &amp;&amp; offset+8 &lt;= len(targetInfo) </span><span class="cov3" title="4">{
                        return targetInfo[offset : offset+8]
                }</span>
                <span class="cov1" title="1">offset += int(avLen)</span>
        }
        <span class="cov2" title="2">return nil</span>
}

// modifyTargetInfoForMIC modifies TargetInfo to add MsvAvFlags with MIC_PROVIDED flag
// Per MS-NLMP 3.1.5.1.2: When MIC is present, MsvAvFlags MUST have MIC_PROVIDED (0x02)
func modifyTargetInfoForMIC(targetInfo []byte) []byte <span class="cov1" title="1">{
        if len(targetInfo) == 0 </span><span class="cov0" title="0">{
                return targetInfo
        }</span>

        // Find MsvAvFlags and MsvAvEOL positions
        <span class="cov1" title="1">flagsOffset := -1
        eolOffset := -1
        offset := 0

        for offset+4 &lt;= len(targetInfo) </span><span class="cov2" title="2">{
                avID := binary.LittleEndian.Uint16(targetInfo[offset:])
                avLen := binary.LittleEndian.Uint16(targetInfo[offset+2:])

                if avID == MsvAvFlags </span><span class="cov0" title="0">{
                        flagsOffset = offset
                }</span>
                <span class="cov2" title="2">if avID == MsvAvEOL </span><span class="cov1" title="1">{
                        eolOffset = offset
                        break</span>
                }
                <span class="cov1" title="1">offset += 4 + int(avLen)</span>
        }

        <span class="cov1" title="1">result := make([]byte, len(targetInfo))
        copy(result, targetInfo)

        if flagsOffset &gt;= 0 </span><span class="cov0" title="0">{
                // Update existing flags to include MIC_PROVIDED (0x02)
                existingFlags := binary.LittleEndian.Uint32(result[flagsOffset+4:])
                existingFlags |= 0x02 // MIC_PROVIDED
                binary.LittleEndian.PutUint32(result[flagsOffset+4:], existingFlags)
        }</span> else<span class="cov1" title="1"> if eolOffset &gt;= 0 </span><span class="cov1" title="1">{
                // Insert MsvAvFlags before MsvAvEOL
                newPair := make([]byte, 8)
                binary.LittleEndian.PutUint16(newPair[0:], MsvAvFlags) // AvId
                binary.LittleEndian.PutUint16(newPair[2:], 4)          // AvLen
                binary.LittleEndian.PutUint32(newPair[4:], 0x02)       // MIC_PROVIDED

                result = append(result[:eolOffset], append(newPair, result[eolOffset:]...)...)
        }</span>

        <span class="cov1" title="1">return result</span>
}

// Security handles NTLM message encryption/decryption
type Security struct {
        encryptRC4 *rc4.Cipher
        decryptRC4 *rc4.Cipher
        signingKey []byte
        verifyKey  []byte
        seqNum     uint32
}

// GetAuthenticateMessage processes challenge and returns Type 3 message and security context
func (n *NTLMv2) GetAuthenticateMessage(challengeData []byte) ([]byte, *Security) <span class="cov2" title="3">{
        challenge, err := ParseChallengeMessage(challengeData)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil
        }</span>
        <span class="cov2" title="2">n.challengeMsg = challenge

        if challenge.NegotiateFlags&amp;NTLMSSP_NEGOTIATE_UNICODE != 0 </span><span class="cov2" title="2">{
                n.enableUnicode = true
        }</span>

        // Get timestamp (use server's if available, else generate)
        <span class="cov2" title="2">var timestamp []byte
        computeMIC := false
        if challenge.Timestamp != nil </span><span class="cov1" title="1">{
                timestamp = challenge.Timestamp
                computeMIC = true
        }</span> else<span class="cov1" title="1"> {
                timestamp = makeTimestamp()
        }</span>

        // Generate client challenge
        <span class="cov2" title="2">clientChallenge := make([]byte, 8)
        if _, err := rand.Read(clientChallenge); err != nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Modify TargetInfo to include MIC_PROVIDED flag when MIC will be computed
        <span class="cov2" title="2">targetInfo := challenge.TargetInfo
        if computeMIC </span><span class="cov1" title="1">{
                targetInfo = modifyTargetInfoForMIC(challenge.TargetInfo)
        }</span>

        // Compute responses
        <span class="cov2" title="2">ntChallengeResponse, lmChallengeResponse, sessionBaseKey := n.computeResponseV2(
                challenge.ServerChallenge[:], clientChallenge, timestamp, targetInfo)

        // Key exchange
        exportedSessionKey := make([]byte, 16)
        if _, err := rand.Read(exportedSessionKey); err != nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov2" title="2">encryptedRandomSessionKey := make([]byte, 16)
        rc, _ := rc4.NewCipher(sessionBaseKey)
        rc.XORKeyStream(encryptedRandomSessionKey, exportedSessionKey)

        // Build authenticate message
        domain, user, _ := n.GetEncodedCredentials()
        workstation := []byte{}

        authMsg := n.buildAuthenticateMessage(
                challenge.NegotiateFlags,
                domain, user, workstation,
                lmChallengeResponse, ntChallengeResponse,
                encryptedRandomSessionKey, computeMIC)

        // Compute MIC if needed
        if computeMIC </span><span class="cov1" title="1">{
                mic := n.computeMIC(exportedSessionKey, authMsg)
                // MIC is at offset 72 in the authenticate message
                copy(authMsg[72:88], mic)
        }</span>

        <span class="cov2" title="2">n.authMsg = authMsg

        // Create security context
        // Per MS-NLMP, with Extended Session Security, keys are derived using MD5
        // SignKey = MD5(SessionBaseKey || MagicConstant)
        // SealKey = MD5(SessionBaseKey || MagicConstant)
        clientSigningKey := md5Hash(append(exportedSessionKey, append([]byte("session key to client-to-server signing key magic constant"), 0x00)...))
        serverSigningKey := md5Hash(append(exportedSessionKey, append([]byte("session key to server-to-client signing key magic constant"), 0x00)...))
        clientSealingKey := md5Hash(append(exportedSessionKey, append([]byte("session key to client-to-server sealing key magic constant"), 0x00)...))
        serverSealingKey := md5Hash(append(exportedSessionKey, append([]byte("session key to server-to-client sealing key magic constant"), 0x00)...))

        encryptRC4, _ := rc4.NewCipher(clientSealingKey)
        decryptRC4, _ := rc4.NewCipher(serverSealingKey)

        return authMsg, &amp;Security{
                encryptRC4: encryptRC4,
                decryptRC4: decryptRC4,
                signingKey: clientSigningKey,
                verifyKey:  serverSigningKey,
                seqNum:     0,
        }</span>
}

func (n *NTLMv2) computeResponseV2(serverChallenge, clientChallenge, timestamp, targetInfo []byte) ([]byte, []byte, []byte) <span class="cov2" title="2">{
        // Build temp
        temp := &amp;bytes.Buffer{}
        temp.Write([]byte{0x01, 0x01})                         // RespType, HiRespType
        temp.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}) // Reserved
        temp.Write(timestamp)                                  // TimeStamp
        temp.Write(clientChallenge)                            // ClientChallenge
        temp.Write([]byte{0x00, 0x00, 0x00, 0x00})             // Reserved
        temp.Write(targetInfo)                                 // AvPairs
        temp.Write([]byte{0x00, 0x00, 0x00, 0x00})             // Reserved

        // NTProofStr = HMAC_MD5(ResponseKeyNT, ServerChallenge || temp)
        ntBuf := append(serverChallenge, temp.Bytes()...)
        ntProofStr := hmacMD5(n.respKeyNT, ntBuf)

        // NtChallengeResponse = NTProofStr || temp
        ntChallengeResponse := append(ntProofStr, temp.Bytes()...)

        // LmChallengeResponse = HMAC_MD5(ResponseKeyLM, ServerChallenge || ClientChallenge) || ClientChallenge
        lmBuf := append(serverChallenge, clientChallenge...)
        lmChallengeResponse := append(hmacMD5(n.respKeyLM, lmBuf), clientChallenge...)

        // SessionBaseKey = HMAC_MD5(ResponseKeyNT, NTProofStr)
        sessionBaseKey := hmacMD5(n.respKeyNT, ntProofStr)

        return ntChallengeResponse, lmChallengeResponse, sessionBaseKey
}</span>

func (n *NTLMv2) buildAuthenticateMessage(flags uint32, domain, user, workstation, lmResponse, ntResponse, encryptedKey []byte, includeMIC bool) []byte <span class="cov2" title="2">{
        // Calculate payload offset
        payloadOffset := uint32(88) // Fixed header size including MIC

        buf := &amp;bytes.Buffer{}
        buf.Write(ntlmSignature)
        _ = binary.Write(buf, binary.LittleEndian, uint32(3)) // MessageType

        currentOffset := payloadOffset

        // LmChallengeResponseFields
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(lmResponse)))
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(lmResponse)))
        _ = binary.Write(buf, binary.LittleEndian, currentOffset)
        currentOffset += uint32(len(lmResponse))

        // NtChallengeResponseFields
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(ntResponse)))
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(ntResponse)))
        _ = binary.Write(buf, binary.LittleEndian, currentOffset)
        currentOffset += uint32(len(ntResponse))

        // DomainNameFields
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(domain)))
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(domain)))
        _ = binary.Write(buf, binary.LittleEndian, currentOffset)
        currentOffset += uint32(len(domain))

        // UserNameFields
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(user)))
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(user)))
        _ = binary.Write(buf, binary.LittleEndian, currentOffset)
        currentOffset += uint32(len(user))

        // WorkstationFields
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(workstation)))
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(workstation)))
        _ = binary.Write(buf, binary.LittleEndian, currentOffset)
        currentOffset += uint32(len(workstation))

        // EncryptedRandomSessionKeyFields
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(encryptedKey)))
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(encryptedKey)))
        _ = binary.Write(buf, binary.LittleEndian, currentOffset)

        // NegotiateFlags
        _ = binary.Write(buf, binary.LittleEndian, flags)

        // Version (8 bytes)
        buf.Write([]byte{0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F})

        // MIC (16 bytes - zeros for now, filled in later if needed)
        buf.Write(make([]byte, 16))

        // Payload
        buf.Write(lmResponse)
        buf.Write(ntResponse)
        buf.Write(domain)
        buf.Write(user)
        buf.Write(workstation)
        buf.Write(encryptedKey)

        return buf.Bytes()
}</span>

func (n *NTLMv2) computeMIC(exportedSessionKey, authMsg []byte) []byte <span class="cov1" title="1">{
        buf := &amp;bytes.Buffer{}
        buf.Write(n.negotiateMsg)
        // Use raw challenge data for MIC computation
        buf.Write(n.challengeMsg.RawData)
        // Write authMsg with zeroed MIC field
        micZeroed := make([]byte, len(authMsg))
        copy(micZeroed, authMsg)
        for i := 72; i &lt; 88 &amp;&amp; i &lt; len(micZeroed); i++ </span><span class="cov5" title="16">{
                micZeroed[i] = 0
        }</span>
        <span class="cov1" title="1">buf.Write(micZeroed)
        return hmacMD5(exportedSessionKey, buf.Bytes())[:16]</span>
}

// GetEncodedCredentials returns domain, user, password encoded appropriately for NTLM
func (n *NTLMv2) GetEncodedCredentials() ([]byte, []byte, []byte) <span class="cov3" title="4">{
        if n.enableUnicode </span><span class="cov2" title="3">{
                return unicodeEncode(n.domain), unicodeEncode(n.user), unicodeEncode(n.password)
        }</span>
        <span class="cov1" title="1">return []byte(n.domain), []byte(n.user), []byte(n.password)</span>
}

// GetCredSSPCredentials returns domain, user, password as UTF-16LE for CredSSP TSCredentials
// Per MS-CSSP, TSPasswordCreds MUST always use UTF-16LE encoding
func (n *NTLMv2) GetCredSSPCredentials() ([]byte, []byte, []byte) <span class="cov0" title="0">{
        return unicodeEncode(n.domain), unicodeEncode(n.user), unicodeEncode(n.password)
}</span>

// GssEncrypt encrypts data using NTLM seal
// Per MS-NLMP: First encrypt data, THEN compute and encrypt signature
func (s *Security) GssEncrypt(data []byte) []byte <span class="cov2" title="2">{
        // Step 1: Encrypt the data FIRST
        encrypted := make([]byte, len(data))
        s.encryptRC4.XORKeyStream(encrypted, data)

        // Step 2: Compute signature over ORIGINAL plaintext (not encrypted)
        seqBuf := make([]byte, 4)
        binary.LittleEndian.PutUint32(seqBuf, s.seqNum)

        signBuf := &amp;bytes.Buffer{}
        signBuf.Write(seqBuf)
        signBuf.Write(data) // Use original plaintext for signature
        sig := hmacMD5(s.signingKey, signBuf.Bytes())[:8]

        // Step 3: Encrypt the signature checksum (RC4 state continues from data encryption)
        checksum := make([]byte, 8)
        s.encryptRC4.XORKeyStream(checksum, sig)

        // Build GSS token: Version(4) + Checksum(8) + SeqNum(4) + EncryptedData
        result := &amp;bytes.Buffer{}
        _ = binary.Write(result, binary.LittleEndian, uint32(0x00000001)) // Version
        result.Write(checksum)
        _ = binary.Write(result, binary.LittleEndian, s.seqNum)
        result.Write(encrypted)

        s.seqNum++
        return result.Bytes()
}</span>

// GssDecrypt decrypts data using NTLM unseal
// Input format: Version(4) + Checksum(8) + SeqNum(4) + EncryptedData
func (s *Security) GssDecrypt(data []byte) []byte <span class="cov0" title="0">{
        if len(data) &lt; 16 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Parse signature
        // version := binary.LittleEndian.Uint32(data[0:4])  // Should be 1
        // checksum := data[4:12]
        // seqNum := binary.LittleEndian.Uint32(data[12:16])
        <span class="cov0" title="0">encrypted := data[16:]

        // Decrypt the data
        decrypted := make([]byte, len(encrypted))
        s.decryptRC4.XORKeyStream(decrypted, encrypted)

        // Skip checksum verification for now - just return decrypted data
        // TODO: Verify checksum using verifyKey and sequence number

        return decrypted</span>
}

// Helper functions

func unicodeEncode(s string) []byte <span class="cov7" title="73">{
        runes := utf16.Encode([]rune(s))
        result := make([]byte, len(runes)*2)
        for i, r := range runes </span><span class="cov10" title="474">{
                binary.LittleEndian.PutUint16(result[i*2:], r)
        }</span>
        <span class="cov7" title="73">return result</span>
}

func ntowfv2(password, user, domain string) []byte <span class="cov5" title="28">{
        // NTOWFv2 = HMAC_MD5(MD4(UNICODE(Password)), UNICODE(ConcatenationOf(Uppercase(User), Domain)))
        passHash := md4(unicodeEncode(password))
        concat := unicodeEncode(toUpper(user) + domain)
        return hmacMD5(passHash, concat)
}</span>

func lmowfv2(password, user, domain string) []byte <span class="cov4" title="11">{
        // LMOWFv2 = NTOWFv2 (same computation)
        return ntowfv2(password, user, domain)
}</span>

func hmacMD5(key, data []byte) []byte <span class="cov6" title="40">{
        h := hmac.New(md5.New, key)
        h.Write(data)
        return h.Sum(nil)
}</span>

func md5Hash(data []byte) []byte <span class="cov4" title="8">{
        h := md5.Sum(data)
        return h[:]
}</span>

func makeTimestamp() []byte <span class="cov2" title="3">{
        // Windows FILETIME: 100-nanosecond intervals since January 1, 1601
        ft := uint64(time.Now().UnixNano())/100 + 116444736000000000
        buf := make([]byte, 8)
        binary.LittleEndian.PutUint64(buf, ft)
        return buf
}</span>

func toUpper(s string) string <span class="cov6" title="33">{
        result := make([]rune, len(s))
        for i, r := range s </span><span class="cov8" title="130">{
                if r &gt;= 'a' &amp;&amp; r &lt;= 'z' </span><span class="cov7" title="99">{
                        result[i] = r - 32
                }</span> else<span class="cov6" title="31"> {
                        result[i] = r
                }</span>
        }
        <span class="cov6" title="33">return string(result)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package codec

// FlipVertical flips bitmap data vertically (in-place).
// RDP sends bitmaps bottom-up, this flips them to top-down.
func FlipVertical(data []byte, width, height, bytesPerPixel int) <span class="cov5" title="13">{
        if height &lt;= 1 </span><span class="cov4" title="8">{
                return
        }</span>

        <span class="cov3" title="5">rowDelta := width * bytesPerPixel
        if rowDelta &lt;= 0 || len(data) &lt; height*rowDelta </span><span class="cov2" title="2">{
                return
        }</span>

        <span class="cov2" title="3">tmp := make([]byte, rowDelta)
        half := height / 2

        for i := 0; i &lt; half; i++ </span><span class="cov2" title="3">{
                topLine := i * rowDelta
                bottomLine := (height - 1 - i) * rowDelta

                copy(tmp, data[topLine:topLine+rowDelta])
                copy(data[topLine:topLine+rowDelta], data[bottomLine:bottomLine+rowDelta])
                copy(data[bottomLine:bottomLine+rowDelta], tmp)
        }</span>
}

// currentPalette holds the active 256-color palette (set by server via palette update)
var currentPalette [256][4]byte // RGBA format

// SetPalette updates the current palette from server data
// RDP palette format: array of RGB entries (R, G, B - 3 bytes each)
func SetPalette(data []byte, numColors int) <span class="cov2" title="3">{
        if numColors &gt; 256 </span><span class="cov1" title="1">{
                numColors = 256
        }</span>
        <span class="cov2" title="3">for i := 0; i &lt; numColors &amp;&amp; i*3+2 &lt; len(data); i++ </span><span class="cov10" title="261">{
                // RDP sends RGB format (3 bytes per entry)
                currentPalette[i][0] = data[i*3+0] // R
                currentPalette[i][1] = data[i*3+1] // G
                currentPalette[i][2] = data[i*3+2] // B
                currentPalette[i][3] = 255         // A
        }</span>
}

// Palette8ToRGBA converts 8-bit paletted data to 32-bit RGBA using current palette
func Palette8ToRGBA(src []byte, dst []byte) <span class="cov2" title="3">{
        for i := 0; i &lt; len(src) &amp;&amp; i*4+3 &lt; len(dst); i++ </span><span class="cov4" title="7">{
                idx := src[i]
                dst[i*4] = currentPalette[idx][0]
                dst[i*4+1] = currentPalette[idx][1]
                dst[i*4+2] = currentPalette[idx][2]
                dst[i*4+3] = currentPalette[idx][3]
        }</span>
}

// init initializes the palette with default Windows system colors
func init() <span class="cov1" title="1">{
        // Initialize with default Windows system palette
        for i := 0; i &lt; 256; i++ </span><span class="cov9" title="256">{
                currentPalette[i][0] = defaultPalette[i][0]
                currentPalette[i][1] = defaultPalette[i][1]
                currentPalette[i][2] = defaultPalette[i][2]
                currentPalette[i][3] = 255
        }</span>
}

// defaultPalette is the Windows default 256-color system palette
var defaultPalette = [256][3]byte{
        // First 10: Windows system colors
        {0x00, 0x00, 0x00}, // 0: Black
        {0x80, 0x00, 0x00}, // 1: Dark Red
        {0x00, 0x80, 0x00}, // 2: Dark Green
        {0x80, 0x80, 0x00}, // 3: Dark Yellow
        {0x00, 0x00, 0x80}, // 4: Dark Blue
        {0x80, 0x00, 0x80}, // 5: Dark Magenta
        {0x00, 0x80, 0x80}, // 6: Dark Cyan
        {0xC0, 0xC0, 0xC0}, // 7: Light Gray
        {0xC0, 0xDC, 0xC0}, // 8: Money Green
        {0xA6, 0xCA, 0xF0}, // 9: Sky Blue
        // 10-245: Color cube (6x6x6 = 216 colors)
        {0x00, 0x00, 0x00}, {0x00, 0x00, 0x33}, {0x00, 0x00, 0x66}, {0x00, 0x00, 0x99}, {0x00, 0x00, 0xCC}, {0x00, 0x00, 0xFF},
        {0x00, 0x33, 0x00}, {0x00, 0x33, 0x33}, {0x00, 0x33, 0x66}, {0x00, 0x33, 0x99}, {0x00, 0x33, 0xCC}, {0x00, 0x33, 0xFF},
        {0x00, 0x66, 0x00}, {0x00, 0x66, 0x33}, {0x00, 0x66, 0x66}, {0x00, 0x66, 0x99}, {0x00, 0x66, 0xCC}, {0x00, 0x66, 0xFF},
        {0x00, 0x99, 0x00}, {0x00, 0x99, 0x33}, {0x00, 0x99, 0x66}, {0x00, 0x99, 0x99}, {0x00, 0x99, 0xCC}, {0x00, 0x99, 0xFF},
        {0x00, 0xCC, 0x00}, {0x00, 0xCC, 0x33}, {0x00, 0xCC, 0x66}, {0x00, 0xCC, 0x99}, {0x00, 0xCC, 0xCC}, {0x00, 0xCC, 0xFF},
        {0x00, 0xFF, 0x00}, {0x00, 0xFF, 0x33}, {0x00, 0xFF, 0x66}, {0x00, 0xFF, 0x99}, {0x00, 0xFF, 0xCC}, {0x00, 0xFF, 0xFF},
        {0x33, 0x00, 0x00}, {0x33, 0x00, 0x33}, {0x33, 0x00, 0x66}, {0x33, 0x00, 0x99}, {0x33, 0x00, 0xCC}, {0x33, 0x00, 0xFF},
        {0x33, 0x33, 0x00}, {0x33, 0x33, 0x33}, {0x33, 0x33, 0x66}, {0x33, 0x33, 0x99}, {0x33, 0x33, 0xCC}, {0x33, 0x33, 0xFF},
        {0x33, 0x66, 0x00}, {0x33, 0x66, 0x33}, {0x33, 0x66, 0x66}, {0x33, 0x66, 0x99}, {0x33, 0x66, 0xCC}, {0x33, 0x66, 0xFF},
        {0x33, 0x99, 0x00}, {0x33, 0x99, 0x33}, {0x33, 0x99, 0x66}, {0x33, 0x99, 0x99}, {0x33, 0x99, 0xCC}, {0x33, 0x99, 0xFF},
        {0x33, 0xCC, 0x00}, {0x33, 0xCC, 0x33}, {0x33, 0xCC, 0x66}, {0x33, 0xCC, 0x99}, {0x33, 0xCC, 0xCC}, {0x33, 0xCC, 0xFF},
        {0x33, 0xFF, 0x00}, {0x33, 0xFF, 0x33}, {0x33, 0xFF, 0x66}, {0x33, 0xFF, 0x99}, {0x33, 0xFF, 0xCC}, {0x33, 0xFF, 0xFF},
        {0x66, 0x00, 0x00}, {0x66, 0x00, 0x33}, {0x66, 0x00, 0x66}, {0x66, 0x00, 0x99}, {0x66, 0x00, 0xCC}, {0x66, 0x00, 0xFF},
        {0x66, 0x33, 0x00}, {0x66, 0x33, 0x33}, {0x66, 0x33, 0x66}, {0x66, 0x33, 0x99}, {0x66, 0x33, 0xCC}, {0x66, 0x33, 0xFF},
        {0x66, 0x66, 0x00}, {0x66, 0x66, 0x33}, {0x66, 0x66, 0x66}, {0x66, 0x66, 0x99}, {0x66, 0x66, 0xCC}, {0x66, 0x66, 0xFF},
        {0x66, 0x99, 0x00}, {0x66, 0x99, 0x33}, {0x66, 0x99, 0x66}, {0x66, 0x99, 0x99}, {0x66, 0x99, 0xCC}, {0x66, 0x99, 0xFF},
        {0x66, 0xCC, 0x00}, {0x66, 0xCC, 0x33}, {0x66, 0xCC, 0x66}, {0x66, 0xCC, 0x99}, {0x66, 0xCC, 0xCC}, {0x66, 0xCC, 0xFF},
        {0x66, 0xFF, 0x00}, {0x66, 0xFF, 0x33}, {0x66, 0xFF, 0x66}, {0x66, 0xFF, 0x99}, {0x66, 0xFF, 0xCC}, {0x66, 0xFF, 0xFF},
        {0x99, 0x00, 0x00}, {0x99, 0x00, 0x33}, {0x99, 0x00, 0x66}, {0x99, 0x00, 0x99}, {0x99, 0x00, 0xCC}, {0x99, 0x00, 0xFF},
        {0x99, 0x33, 0x00}, {0x99, 0x33, 0x33}, {0x99, 0x33, 0x66}, {0x99, 0x33, 0x99}, {0x99, 0x33, 0xCC}, {0x99, 0x33, 0xFF},
        {0x99, 0x66, 0x00}, {0x99, 0x66, 0x33}, {0x99, 0x66, 0x66}, {0x99, 0x66, 0x99}, {0x99, 0x66, 0xCC}, {0x99, 0x66, 0xFF},
        {0x99, 0x99, 0x00}, {0x99, 0x99, 0x33}, {0x99, 0x99, 0x66}, {0x99, 0x99, 0x99}, {0x99, 0x99, 0xCC}, {0x99, 0x99, 0xFF},
        {0x99, 0xCC, 0x00}, {0x99, 0xCC, 0x33}, {0x99, 0xCC, 0x66}, {0x99, 0xCC, 0x99}, {0x99, 0xCC, 0xCC}, {0x99, 0xCC, 0xFF},
        {0x99, 0xFF, 0x00}, {0x99, 0xFF, 0x33}, {0x99, 0xFF, 0x66}, {0x99, 0xFF, 0x99}, {0x99, 0xFF, 0xCC}, {0x99, 0xFF, 0xFF},
        {0xCC, 0x00, 0x00}, {0xCC, 0x00, 0x33}, {0xCC, 0x00, 0x66}, {0xCC, 0x00, 0x99}, {0xCC, 0x00, 0xCC}, {0xCC, 0x00, 0xFF},
        {0xCC, 0x33, 0x00}, {0xCC, 0x33, 0x33}, {0xCC, 0x33, 0x66}, {0xCC, 0x33, 0x99}, {0xCC, 0x33, 0xCC}, {0xCC, 0x33, 0xFF},
        {0xCC, 0x66, 0x00}, {0xCC, 0x66, 0x33}, {0xCC, 0x66, 0x66}, {0xCC, 0x66, 0x99}, {0xCC, 0x66, 0xCC}, {0xCC, 0x66, 0xFF},
        {0xCC, 0x99, 0x00}, {0xCC, 0x99, 0x33}, {0xCC, 0x99, 0x66}, {0xCC, 0x99, 0x99}, {0xCC, 0x99, 0xCC}, {0xCC, 0x99, 0xFF},
        {0xCC, 0xCC, 0x00}, {0xCC, 0xCC, 0x33}, {0xCC, 0xCC, 0x66}, {0xCC, 0xCC, 0x99}, {0xCC, 0xCC, 0xCC}, {0xCC, 0xCC, 0xFF},
        {0xCC, 0xFF, 0x00}, {0xCC, 0xFF, 0x33}, {0xCC, 0xFF, 0x66}, {0xCC, 0xFF, 0x99}, {0xCC, 0xFF, 0xCC}, {0xCC, 0xFF, 0xFF},
        {0xFF, 0x00, 0x00}, {0xFF, 0x00, 0x33}, {0xFF, 0x00, 0x66}, {0xFF, 0x00, 0x99}, {0xFF, 0x00, 0xCC}, {0xFF, 0x00, 0xFF},
        {0xFF, 0x33, 0x00}, {0xFF, 0x33, 0x33}, {0xFF, 0x33, 0x66}, {0xFF, 0x33, 0x99}, {0xFF, 0x33, 0xCC}, {0xFF, 0x33, 0xFF},
        {0xFF, 0x66, 0x00}, {0xFF, 0x66, 0x33}, {0xFF, 0x66, 0x66}, {0xFF, 0x66, 0x99}, {0xFF, 0x66, 0xCC}, {0xFF, 0x66, 0xFF},
        {0xFF, 0x99, 0x00}, {0xFF, 0x99, 0x33}, {0xFF, 0x99, 0x66}, {0xFF, 0x99, 0x99}, {0xFF, 0x99, 0xCC}, {0xFF, 0x99, 0xFF},
        {0xFF, 0xCC, 0x00}, {0xFF, 0xCC, 0x33}, {0xFF, 0xCC, 0x66}, {0xFF, 0xCC, 0x99}, {0xFF, 0xCC, 0xCC}, {0xFF, 0xCC, 0xFF},
        {0xFF, 0xFF, 0x00}, {0xFF, 0xFF, 0x33}, {0xFF, 0xFF, 0x66}, {0xFF, 0xFF, 0x99}, {0xFF, 0xFF, 0xCC}, {0xFF, 0xFF, 0xFF},
        // 226-245: Grayscale ramp
        {0x08, 0x08, 0x08}, {0x12, 0x12, 0x12}, {0x1C, 0x1C, 0x1C}, {0x26, 0x26, 0x26},
        {0x30, 0x30, 0x30}, {0x3A, 0x3A, 0x3A}, {0x44, 0x44, 0x44}, {0x4E, 0x4E, 0x4E},
        {0x58, 0x58, 0x58}, {0x62, 0x62, 0x62}, {0x6C, 0x6C, 0x6C}, {0x76, 0x76, 0x76},
        {0x80, 0x80, 0x80}, {0x8A, 0x8A, 0x8A}, {0x94, 0x94, 0x94}, {0x9E, 0x9E, 0x9E},
        {0xA8, 0xA8, 0xA8}, {0xB2, 0xB2, 0xB2}, {0xBC, 0xBC, 0xBC}, {0xE6, 0xE6, 0xE6},
        // 246-255: Windows system colors (end)
        {0xFF, 0xFB, 0xF0}, // 246: Cream
        {0xA0, 0xA0, 0xA4}, // 247: Medium Gray
        {0x80, 0x80, 0x80}, // 248: Dark Gray
        {0xFF, 0x00, 0x00}, // 249: Red
        {0x00, 0xFF, 0x00}, // 250: Green
        {0xFF, 0xFF, 0x00}, // 251: Yellow
        {0x00, 0x00, 0xFF}, // 252: Blue
        {0xFF, 0x00, 0xFF}, // 253: Magenta
        {0x00, 0xFF, 0xFF}, // 254: Cyan
        {0xFF, 0xFF, 0xFF}, // 255: White
}

// RGB555ToRGBA converts 15-bit RGB555 to 32-bit RGBA
func RGB555ToRGBA(src []byte, dst []byte) <span class="cov3" title="4">{
        srcIdx := 0
        dstIdx := 0

        for srcIdx+1 &lt; len(src) &amp;&amp; dstIdx+3 &lt; len(dst) </span><span class="cov3" title="4">{
                pel := uint16(src[srcIdx]) | (uint16(src[srcIdx+1]) &lt;&lt; 8)

                r := (pel &amp; 0x7C00) &gt;&gt; 10
                g := (pel &amp; 0x03E0) &gt;&gt; 5
                b := pel &amp; 0x001F

                // Expand 5/5/5 to 8/8/8
                r = (r &lt;&lt; 3) | (r &gt;&gt; 2)
                g = (g &lt;&lt; 3) | (g &gt;&gt; 2)
                b = (b &lt;&lt; 3) | (b &gt;&gt; 2)

                dst[dstIdx] = byte(r)
                dst[dstIdx+1] = byte(g)
                dst[dstIdx+2] = byte(b)
                dst[dstIdx+3] = 255

                srcIdx += 2
                dstIdx += 4
        }</span>
}

// RGB565ToRGBA converts 16-bit RGB565 to 32-bit RGBA
func RGB565ToRGBA(src []byte, dst []byte) <span class="cov3" title="4">{
        srcIdx := 0
        dstIdx := 0

        for srcIdx+1 &lt; len(src) &amp;&amp; dstIdx+3 &lt; len(dst) </span><span class="cov3" title="4">{
                pel := uint16(src[srcIdx]) | (uint16(src[srcIdx+1]) &lt;&lt; 8)

                r := (pel &amp; 0xF800) &gt;&gt; 11
                g := (pel &amp; 0x07E0) &gt;&gt; 5
                b := pel &amp; 0x001F

                // Expand 5/6/5 to 8/8/8
                r = (r &lt;&lt; 3) | (r &gt;&gt; 2)
                g = (g &lt;&lt; 2) | (g &gt;&gt; 4)
                b = (b &lt;&lt; 3) | (b &gt;&gt; 2)

                dst[dstIdx] = byte(r)
                dst[dstIdx+1] = byte(g)
                dst[dstIdx+2] = byte(b)
                dst[dstIdx+3] = 255

                srcIdx += 2
                dstIdx += 4
        }</span>
}

// BGR24ToRGBA converts 24-bit BGR to 32-bit RGBA
func BGR24ToRGBA(src []byte, dst []byte) <span class="cov2" title="2">{
        srcIdx := 0
        dstIdx := 0

        for srcIdx+2 &lt; len(src) &amp;&amp; dstIdx+3 &lt; len(dst) </span><span class="cov2" title="2">{
                dst[dstIdx] = src[srcIdx+2]   // R
                dst[dstIdx+1] = src[srcIdx+1] // G
                dst[dstIdx+2] = src[srcIdx]   // B
                dst[dstIdx+3] = 255

                srcIdx += 3
                dstIdx += 4
        }</span>
}

// BGRA32ToRGBA converts 32-bit BGRA to 32-bit RGBA
func BGRA32ToRGBA(src []byte, dst []byte) <span class="cov2" title="2">{
        for i := 0; i+3 &lt; len(src) &amp;&amp; i+3 &lt; len(dst); i += 4 </span><span class="cov2" title="2">{
                dst[i] = src[i+2]   // R
                dst[i+1] = src[i+1] // G
                dst[i+2] = src[i]   // B
                dst[i+3] = 255
        }</span>
}

// ProcessBitmap handles decompression, flip, and color conversion in one call.
// Returns the RGBA output buffer on success, nil on failure.
// Note: MS-RDPBCGR RLE only supports up to 24-bit. For 32-bit color depth,
// xrdp uses RDP6 Planar codec (separate color planes with RLE).
func ProcessBitmap(src []byte, width, height, bpp int, isCompressed bool, rowDelta int) []byte <span class="cov3" title="6">{
        pixelCount := width * height

        // For 32-bit compressed, check if it's planar codec (first byte has format header)
        if isCompressed &amp;&amp; bpp == 32 &amp;&amp; len(src) &gt; 0 </span><span class="cov0" title="0">{
                // Check for planar codec format header
                formatHeader := src[0]
                if formatHeader&amp;0xC0 == 0 </span><span class="cov0" title="0">{ // Reserved bits should be 0 for planar
                        rgba := DecompressPlanar(src, width, height)
                        if rgba != nil </span><span class="cov0" title="0">{
                                return rgba
                        }</span>
                }
        }

        <span class="cov3" title="6">var raw []byte
        var rawBytesPerPixel int

        if isCompressed </span><span class="cov0" title="0">{
                switch bpp </span>{
                case 8:<span class="cov0" title="0">
                        rawBytesPerPixel = 1
                        rawSize := width * height * rawBytesPerPixel
                        raw = make([]byte, rawSize)
                        if !RLEDecompress8(src, raw, width*rawBytesPerPixel) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                case 15:<span class="cov0" title="0">
                        rawBytesPerPixel = 2
                        rawSize := width * height * rawBytesPerPixel
                        raw = make([]byte, rawSize)
                        if !RLEDecompress15(src, raw, width*rawBytesPerPixel) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                case 16:<span class="cov0" title="0">
                        rawBytesPerPixel = 2
                        rawSize := width * height * rawBytesPerPixel
                        raw = make([]byte, rawSize)
                        if !RLEDecompress16(src, raw, width*rawBytesPerPixel) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                case 24, 32:<span class="cov0" title="0">
                        // MS-RDPBCGR: RLE only supports up to 24-bit (3 bytes per pixel)
                        // 32-bit color depth uses 24-bit encoding in compressed stream
                        rawBytesPerPixel = 3
                        rawSize := width * height * rawBytesPerPixel
                        raw = make([]byte, rawSize)
                        if !RLEDecompress24(src, raw, width*rawBytesPerPixel) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                default:<span class="cov0" title="0">
                        return nil</span>
                }
        } else<span class="cov3" title="6"> {
                // Uncompressed data
                switch bpp </span>{
                case 8:<span class="cov1" title="1">
                        rawBytesPerPixel = 1</span>
                case 15, 16:<span class="cov2" title="2">
                        rawBytesPerPixel = 2</span>
                case 24:<span class="cov1" title="1">
                        rawBytesPerPixel = 3</span>
                case 32:<span class="cov1" title="1">
                        rawBytesPerPixel = 4</span>
                default:<span class="cov1" title="1">
                        rawBytesPerPixel = bpp / 8</span>
                }
                <span class="cov3" title="6">rawSize := width * height * rawBytesPerPixel
                raw = make([]byte, rawSize)
                copyLen := len(src)
                if copyLen &gt; rawSize </span><span class="cov1" title="1">{
                        copyLen = rawSize
                }</span>
                <span class="cov3" title="6">copy(raw, src[:copyLen])</span>
        }

        // Flip vertically (RDP sends bottom-up)
        <span class="cov3" title="6">FlipVertical(raw, width, height, rawBytesPerPixel)

        // Convert to RGBA
        rgba := make([]byte, pixelCount*4)
        switch bpp </span>{
        case 8:<span class="cov1" title="1">
                Palette8ToRGBA(raw, rgba)</span>
        case 15:<span class="cov1" title="1">
                RGB555ToRGBA(raw, rgba)</span>
        case 16:<span class="cov1" title="1">
                RGB565ToRGBA(raw, rgba)</span>
        case 24:<span class="cov1" title="1">
                BGR24ToRGBA(raw, rgba)</span>
        case 32:<span class="cov1" title="1">
                BGRA32ToRGBA(raw, rgba)</span>
        default:<span class="cov1" title="1">
                return nil</span>
        }

        <span class="cov3" title="5">return rgba</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package nscodec implements the NSCodec bitmap codec decoder as specified in MS-RDPNSC.
// NSCodec compresses 24/32 bpp images using AYCoCg color space conversion and RLE compression.
package codec

import (
        "encoding/binary"
        "errors"
        "fmt"
)

var (
        ErrInvalidStream     = errors.New("nscodec: invalid bitmap stream")
        ErrInvalidPlaneSize  = errors.New("nscodec: invalid plane size")
        ErrInvalidColorLoss  = errors.New("nscodec: invalid color loss level")
        ErrDecompressionFail = errors.New("nscodec: RLE decompression failed")
)

// NSCodec GUID: CA8D1BB9-000F-154F-589F-AE2D1A87E2D6
var NSCodecGUID = [16]byte{
        0xB9, 0x1B, 0x8D, 0xCA, 0x0F, 0x00, 0x4F, 0x15,
        0x58, 0x9F, 0xAE, 0x2D, 0x1A, 0x87, 0xE2, 0xD6,
}

// BitmapStream represents the NSCODEC_BITMAP_STREAM structure
type BitmapStream struct {
        LumaPlaneByteCount         uint32
        OrangeChromaPlaneByteCount uint32
        GreenChromaPlaneByteCount  uint32
        AlphaPlaneByteCount        uint32
        ColorLossLevel             uint8
        ChromaSubsamplingLevel     uint8
        LumaPlane                  []byte
        OrangeChromaPlane          []byte
        GreenChromaPlane           []byte
        AlphaPlane                 []byte
}

// ParseBitmapStream parses an NSCODEC_BITMAP_STREAM from raw bytes
func ParseBitmapStream(data []byte) (*BitmapStream, error) <span class="cov5" title="13">{
        if len(data) &lt; 18 </span><span class="cov2" title="2">{ // Minimum header size
                return nil, ErrInvalidStream
        }</span>

        <span class="cov4" title="11">stream := &amp;BitmapStream{
                LumaPlaneByteCount:         binary.LittleEndian.Uint32(data[0:4]),
                OrangeChromaPlaneByteCount: binary.LittleEndian.Uint32(data[4:8]),
                GreenChromaPlaneByteCount:  binary.LittleEndian.Uint32(data[8:12]),
                AlphaPlaneByteCount:        binary.LittleEndian.Uint32(data[12:16]),
                ColorLossLevel:             data[16],
                ChromaSubsamplingLevel:     data[17],
                // Reserved: data[18:20]
        }

        if stream.ColorLossLevel &lt; 1 || stream.ColorLossLevel &gt; 7 </span><span class="cov2" title="2">{
                return nil, ErrInvalidColorLoss
        }</span>

        <span class="cov4" title="9">offset := uint32(20) // Header size

        // Parse luma plane
        if stream.LumaPlaneByteCount &gt; 0 </span><span class="cov4" title="9">{
                if uint32(len(data)) &lt; offset+stream.LumaPlaneByteCount </span><span class="cov1" title="1">{
                        return nil, ErrInvalidPlaneSize
                }</span>
                <span class="cov4" title="8">stream.LumaPlane = data[offset : offset+stream.LumaPlaneByteCount]
                offset += stream.LumaPlaneByteCount</span>
        }

        // Parse orange chroma plane
        <span class="cov4" title="8">if stream.OrangeChromaPlaneByteCount &gt; 0 </span><span class="cov4" title="8">{
                if uint32(len(data)) &lt; offset+stream.OrangeChromaPlaneByteCount </span><span class="cov1" title="1">{
                        return nil, ErrInvalidPlaneSize
                }</span>
                <span class="cov4" title="7">stream.OrangeChromaPlane = data[offset : offset+stream.OrangeChromaPlaneByteCount]
                offset += stream.OrangeChromaPlaneByteCount</span>
        }

        // Parse green chroma plane
        <span class="cov4" title="7">if stream.GreenChromaPlaneByteCount &gt; 0 </span><span class="cov4" title="7">{
                if uint32(len(data)) &lt; offset+stream.GreenChromaPlaneByteCount </span><span class="cov1" title="1">{
                        return nil, ErrInvalidPlaneSize
                }</span>
                <span class="cov3" title="6">stream.GreenChromaPlane = data[offset : offset+stream.GreenChromaPlaneByteCount]
                offset += stream.GreenChromaPlaneByteCount</span>
        }

        // Parse alpha plane (optional)
        <span class="cov3" title="6">if stream.AlphaPlaneByteCount &gt; 0 </span><span class="cov2" title="2">{
                if uint32(len(data)) &lt; offset+stream.AlphaPlaneByteCount </span><span class="cov1" title="1">{
                        return nil, ErrInvalidPlaneSize
                }</span>
                <span class="cov1" title="1">stream.AlphaPlane = data[offset : offset+stream.AlphaPlaneByteCount]</span>
        }

        <span class="cov3" title="5">return stream, nil</span>
}

// Decode decodes an NSCodec bitmap stream to RGBA pixels
// width and height are the dimensions of the original image
// Returns RGBA pixel data (4 bytes per pixel)
func Decode(data []byte, width, height int) ([]byte, error) <span class="cov3" title="6">{
        stream, err := ParseBitmapStream(data)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov3" title="4">return stream.Decode(width, height)</span>
}

// Decode decodes the bitmap stream to RGBA pixels
func (s *BitmapStream) Decode(width, height int) ([]byte, error) <span class="cov3" title="5">{
        chromaSubsampling := s.ChromaSubsamplingLevel != 0

        // Calculate expected plane sizes
        var lumaWidth, lumaHeight int
        var chromaWidth, chromaHeight int

        if chromaSubsampling </span><span class="cov1" title="1">{
                lumaWidth = roundUpToMultiple(width, 8)
                lumaHeight = height
                chromaWidth = lumaWidth / 2
                chromaHeight = roundUpToMultiple(height, 2) / 2
        }</span> else<span class="cov3" title="4"> {
                lumaWidth = width
                lumaHeight = height
                chromaWidth = width
                chromaHeight = height
        }</span>

        <span class="cov3" title="5">lumaExpectedSize := lumaWidth * lumaHeight
        chromaExpectedSize := chromaWidth * chromaHeight

        // Decompress or use raw luma plane
        lumaPlane, err := decompressPlane(s.LumaPlane, lumaExpectedSize)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("luma plane: %w", err)
        }</span>

        // Decompress or use raw orange chroma plane
        <span class="cov3" title="4">orangePlane, err := decompressPlane(s.OrangeChromaPlane, chromaExpectedSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("orange chroma plane: %w", err)
        }</span>

        // Decompress or use raw green chroma plane
        <span class="cov3" title="4">greenPlane, err := decompressPlane(s.GreenChromaPlane, chromaExpectedSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("green chroma plane: %w", err)
        }</span>

        // Decompress or use raw alpha plane (if present)
        <span class="cov3" title="4">var alphaPlane []byte
        if s.AlphaPlaneByteCount &gt; 0 </span><span class="cov1" title="1">{
                alphaExpectedSize := width * height
                alphaPlane, err = decompressPlane(s.AlphaPlane, alphaExpectedSize)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("alpha plane: %w", err)
                }</span>
        }

        // Apply chroma super-sampling if needed
        <span class="cov3" title="4">if chromaSubsampling </span><span class="cov1" title="1">{
                orangePlane = chromaSuperSample(orangePlane, chromaWidth, chromaHeight, lumaWidth, lumaHeight)
                greenPlane = chromaSuperSample(greenPlane, chromaWidth, chromaHeight, lumaWidth, lumaHeight)
        }</span>

        // Apply color loss restoration
        <span class="cov3" title="4">if s.ColorLossLevel &gt; 1 </span><span class="cov1" title="1">{
                orangePlane = restoreColorLoss(orangePlane, s.ColorLossLevel)
                greenPlane = restoreColorLoss(greenPlane, s.ColorLossLevel)
        }</span>

        // Convert AYCoCg to RGBA
        <span class="cov3" title="4">return aycoCgToRGBA(lumaPlane, orangePlane, greenPlane, alphaPlane, lumaWidth, lumaHeight, width, height)</span>
}

// decompressPlane decompresses an RLE-compressed plane or returns raw data
func decompressPlane(data []byte, expectedSize int) ([]byte, error) <span class="cov5" title="17">{
        if len(data) == expectedSize </span><span class="cov5" title="14">{
                // Raw data, no decompression needed
                return data, nil
        }</span>

        <span class="cov2" title="3">if len(data) &gt; expectedSize </span><span class="cov2" title="2">{
                return nil, ErrInvalidPlaneSize
        }</span>

        // RLE compressed - decompress
        <span class="cov1" title="1">return rleDecompress(data, expectedSize)</span>
}

// rleDecompress decompresses NSCodec RLE data
// NSCodec RLE format: segments followed by 4-byte EndData (last 4 raw bytes)
func rleDecompress(data []byte, expectedSize int) ([]byte, error) <span class="cov4" title="10">{
        if len(data) &lt; 4 </span><span class="cov1" title="1">{
                return nil, ErrDecompressionFail
        }</span>

        <span class="cov4" title="9">result := make([]byte, 0, expectedSize)
        offset := 0
        dataLen := len(data) - 4 // Exclude EndData

        for offset &lt; dataLen &amp;&amp; len(result) &lt; expectedSize-4 </span><span class="cov4" title="10">{
                if offset &gt;= dataLen </span><span class="cov0" title="0">{
                        break</span>
                }

                // Read segment header
                <span class="cov4" title="10">header := data[offset]
                offset++

                if header&amp;0x80 != 0 </span><span class="cov3" title="6">{
                        // Run segment: repeat single byte
                        runLength := int(header &amp; 0x7F)
                        if runLength == 0 </span><span class="cov2" title="2">{
                                // Extended run length
                                if offset &gt;= dataLen </span><span class="cov0" title="0">{
                                        return nil, ErrDecompressionFail
                                }</span>
                                <span class="cov2" title="2">runLength = int(data[offset]) + 128
                                offset++</span>
                        }
                        <span class="cov3" title="6">if offset &gt;= dataLen </span><span class="cov0" title="0">{
                                return nil, ErrDecompressionFail
                        }</span>
                        <span class="cov3" title="6">runValue := data[offset]
                        offset++

                        for i := 0; i &lt; runLength &amp;&amp; len(result) &lt; expectedSize-4; i++ </span><span class="cov10" title="270">{
                                result = append(result, runValue)
                        }</span>
                } else<span class="cov3" title="4"> {
                        // Literal segment: copy raw bytes
                        literalLength := int(header)
                        if literalLength == 0 </span><span class="cov2" title="2">{
                                // Extended literal length
                                if offset &gt;= dataLen </span><span class="cov0" title="0">{
                                        return nil, ErrDecompressionFail
                                }</span>
                                <span class="cov2" title="2">literalLength = int(data[offset]) + 128
                                offset++</span>
                        }

                        <span class="cov3" title="4">if offset+literalLength &gt; dataLen </span><span class="cov1" title="1">{
                                return nil, ErrDecompressionFail
                        }</span>

                        <span class="cov2" title="3">result = append(result, data[offset:offset+literalLength]...)
                        offset += literalLength</span>
                }
        }

        // Append EndData (last 4 bytes of original plane)
        <span class="cov4" title="8">if len(data) &gt;= 4 </span><span class="cov4" title="8">{
                endData := data[len(data)-4:]
                for _, b := range endData </span><span class="cov6" title="32">{
                        if len(result) &lt; expectedSize </span><span class="cov6" title="32">{
                                result = append(result, b)
                        }</span>
                }
        }

        // Pad with zeros if needed
        <span class="cov4" title="8">for len(result) &lt; expectedSize </span><span class="cov3" title="5">{
                result = append(result, 0)
        }</span>

        <span class="cov4" title="8">return result[:expectedSize], nil</span>
}

// chromaSuperSample upsamples chroma planes from subsampled to full resolution
func chromaSuperSample(plane []byte, srcWidth, srcHeight, dstWidth, dstHeight int) []byte <span class="cov3" title="6">{
        result := make([]byte, dstWidth*dstHeight)

        for y := 0; y &lt; dstHeight; y++ </span><span class="cov5" title="14">{
                srcY := y / 2
                if srcY &gt;= srcHeight </span><span class="cov0" title="0">{
                        srcY = srcHeight - 1
                }</span>

                <span class="cov5" title="14">for x := 0; x &lt; dstWidth; x++ </span><span class="cov7" title="68">{
                        srcX := x / 2
                        if srcX &gt;= srcWidth </span><span class="cov0" title="0">{
                                srcX = srcWidth - 1
                        }</span>

                        <span class="cov7" title="68">srcIdx := srcY*srcWidth + srcX
                        dstIdx := y*dstWidth + x

                        if srcIdx &lt; len(plane) </span><span class="cov7" title="68">{
                                result[dstIdx] = plane[srcIdx]
                        }</span>
                }
        }

        <span class="cov3" title="6">return result</span>
}

// restoreColorLoss restores color values that were quantized during compression
func restoreColorLoss(plane []byte, colorLossLevel uint8) []byte <span class="cov5" title="14">{
        if colorLossLevel &lt;= 1 </span><span class="cov2" title="2">{
                return plane
        }</span>

        // Color loss shifts values, we need to restore them
        <span class="cov4" title="12">shift := colorLossLevel - 1
        result := make([]byte, len(plane))

        for i, v := range plane </span><span class="cov5" title="15">{
                // Restore by left-shifting and adding mid-value
                restored := int(v) &lt;&lt; shift
                if restored &gt; 255 </span><span class="cov2" title="3">{
                        restored = 255
                }</span>
                <span class="cov5" title="15">result[i] = byte(restored)</span>
        }

        <span class="cov4" title="12">return result</span>
}

// aycoCgToRGBA converts AYCoCg color space to RGBA
// Y = Luma, Co = Orange Chroma, Cg = Green Chroma
func aycoCgToRGBA(luma, co, cg, alpha []byte, planeWidth, planeHeight, imgWidth, imgHeight int) ([]byte, error) <span class="cov4" title="11">{
        rgba := make([]byte, imgWidth*imgHeight*4)

        for y := 0; y &lt; imgHeight; y++ </span><span class="cov4" title="12">{
                for x := 0; x &lt; imgWidth; x++ </span><span class="cov5" title="16">{
                        planeIdx := y*planeWidth + x
                        rgbaIdx := (y*imgWidth + x) * 4

                        if planeIdx &gt;= len(luma) || planeIdx &gt;= len(co) || planeIdx &gt;= len(cg) </span><span class="cov2" title="3">{
                                continue</span>
                        }

                        // Get YCoCg values (shifted to signed range)
                        <span class="cov5" title="13">yVal := int(luma[planeIdx])
                        coVal := int(co[planeIdx]) - 128
                        cgVal := int(cg[planeIdx]) - 128

                        // YCoCg to RGB conversion
                        // t = Y - Cg
                        // R = t + Co
                        // G = Y + Cg
                        // B = t - Co
                        t := yVal - cgVal
                        r := clamp(t + coVal)
                        g := clamp(yVal + cgVal)
                        b := clamp(t - coVal)

                        rgba[rgbaIdx+0] = byte(r)
                        rgba[rgbaIdx+1] = byte(g)
                        rgba[rgbaIdx+2] = byte(b)

                        // Alpha
                        if alpha != nil &amp;&amp; planeIdx &lt; len(alpha) </span><span class="cov3" title="4">{
                                rgba[rgbaIdx+3] = alpha[planeIdx]
                        }</span> else<span class="cov4" title="9"> {
                                rgba[rgbaIdx+3] = 255
                        }</span>
                }
        }

        <span class="cov4" title="11">return rgba, nil</span>
}

// clamp clamps a value to 0-255 range
func clamp(v int) int <span class="cov7" title="44">{
        if v &lt; 0 </span><span class="cov2" title="3">{
                return 0
        }</span>
        <span class="cov6" title="41">if v &gt; 255 </span><span class="cov3" title="4">{
                return 255
        }</span>
        <span class="cov6" title="37">return v</span>
}

// roundUpToMultiple rounds n up to the nearest multiple of m
func roundUpToMultiple(n, m int) int <span class="cov4" title="11">{
        if m == 0 </span><span class="cov1" title="1">{
                return n
        }</span>
        <span class="cov4" title="10">remainder := n % m
        if remainder == 0 </span><span class="cov3" title="4">{
                return n
        }</span>
        <span class="cov3" title="6">return n + m - remainder</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package codec

import (
        "bytes"
        "encoding/binary"
        "unicode/utf16"
)

func Encode(s string) []byte <span class="cov7" title="5">{
        buf := new(bytes.Buffer)

        for _, ch := range utf16.Encode([]rune(s)) </span><span class="cov10" title="9">{
                _ = binary.Write(buf, binary.LittleEndian, ch)
        }</span>

        <span class="cov7" title="5">return buf.Bytes()</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package codec

// NSCodecRLEDecompress decompresses NSCodec RLE data for a single plane.
// This is different from bitmap RLE - NSCodec uses a simpler format with
// run segments and literal segments.
func NSCodecRLEDecompress(data []byte, expectedSize int) []byte <span class="cov7" title="5">{
        if len(data) == expectedSize </span><span class="cov4" title="2">{
                // Raw data, no decompression needed
                return data
        }</span>

        <span class="cov5" title="3">if len(data) &gt; expectedSize || len(data) &lt; 4 </span><span class="cov4" title="2">{
                return nil
        }</span>

        <span class="cov1" title="1">result := make([]byte, 0, expectedSize)
        offset := 0
        dataLen := len(data) - 4 // Exclude EndData

        for offset &lt; dataLen &amp;&amp; len(result) &lt; expectedSize-4 </span><span class="cov1" title="1">{
                header := data[offset]
                offset++

                if header&amp;0x80 != 0 </span><span class="cov1" title="1">{
                        // Run segment: repeat single byte
                        runLength := int(header &amp; 0x7F)
                        if runLength == 0 </span><span class="cov0" title="0">{
                                if offset &gt;= dataLen </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">runLength = int(data[offset]) + 128
                                offset++</span>
                        }
                        <span class="cov1" title="1">if offset &gt;= dataLen </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov1" title="1">runValue := data[offset]
                        offset++

                        for i := 0; i &lt; runLength &amp;&amp; len(result) &lt; expectedSize-4; i++ </span><span class="cov5" title="3">{
                                result = append(result, runValue)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Literal segment: copy raw bytes
                        literalLength := int(header)
                        if literalLength == 0 </span><span class="cov0" title="0">{
                                if offset &gt;= dataLen </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">literalLength = int(data[offset]) + 128
                                offset++</span>
                        }

                        <span class="cov0" title="0">if offset+literalLength &gt; dataLen </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">result = append(result, data[offset:offset+literalLength]...)
                        offset += literalLength</span>
                }
        }

        // Append EndData (last 4 bytes)
        <span class="cov1" title="1">if len(data) &gt;= 4 </span><span class="cov1" title="1">{
                endData := data[len(data)-4:]
                for _, b := range endData </span><span class="cov7" title="4">{
                        if len(result) &lt; expectedSize </span><span class="cov7" title="4">{
                                result = append(result, b)
                        }</span>
                }
        }

        // Pad with zeros if needed
        <span class="cov1" title="1">for len(result) &lt; expectedSize </span><span class="cov0" title="0">{
                result = append(result, 0)
        }</span>

        <span class="cov1" title="1">return result[:expectedSize]</span>
}

// ChromaSuperSample upsamples chroma planes from subsampled to full resolution
func ChromaSuperSample(plane []byte, srcWidth, srcHeight, dstWidth, dstHeight int) []byte <span class="cov0" title="0">{
        result := make([]byte, dstWidth*dstHeight)

        for y := 0; y &lt; dstHeight; y++ </span><span class="cov0" title="0">{
                srcY := y / 2
                if srcY &gt;= srcHeight </span><span class="cov0" title="0">{
                        srcY = srcHeight - 1
                }</span>

                <span class="cov0" title="0">for x := 0; x &lt; dstWidth; x++ </span><span class="cov0" title="0">{
                        srcX := x / 2
                        if srcX &gt;= srcWidth </span><span class="cov0" title="0">{
                                srcX = srcWidth - 1
                        }</span>

                        <span class="cov0" title="0">srcIdx := srcY*srcWidth + srcX
                        dstIdx := y*dstWidth + x

                        if srcIdx &lt; len(plane) </span><span class="cov0" title="0">{
                                result[dstIdx] = plane[srcIdx]
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// RestoreColorLoss restores color values that were quantized during compression
func RestoreColorLoss(plane []byte, colorLossLevel uint8) []byte <span class="cov0" title="0">{
        if colorLossLevel &lt;= 1 </span><span class="cov0" title="0">{
                return plane
        }</span>

        <span class="cov0" title="0">shift := colorLossLevel - 1
        result := make([]byte, len(plane))

        for i, v := range plane </span><span class="cov0" title="0">{
                restored := int(v) &lt;&lt; shift
                if restored &gt; 255 </span><span class="cov0" title="0">{
                        restored = 255
                }</span>
                <span class="cov0" title="0">result[i] = byte(restored)</span>
        }

        <span class="cov0" title="0">return result</span>
}

// clampByteNS clamps a value to 0-255 range (used by NSCodec)
func clampByteNS(v int) byte <span class="cov10" title="8">{
        if v &lt; 0 </span><span class="cov1" title="1">{
                return 0
        }</span>
        <span class="cov9" title="7">if v &gt; 255 </span><span class="cov1" title="1">{
                return 255
        }</span>
        <span class="cov8" title="6">return byte(v)</span>
}

// AYCoCgToRGBA converts AYCoCg color space to RGBA
func AYCoCgToRGBA(luma, co, cg, alpha []byte, planeWidth, planeHeight, imgWidth, imgHeight int) []byte <span class="cov1" title="1">{
        rgba := make([]byte, imgWidth*imgHeight*4)

        for y := 0; y &lt; imgHeight; y++ </span><span class="cov1" title="1">{
                for x := 0; x &lt; imgWidth; x++ </span><span class="cov1" title="1">{
                        planeIdx := y*planeWidth + x
                        rgbaIdx := (y*imgWidth + x) * 4

                        if planeIdx &gt;= len(luma) || planeIdx &gt;= len(co) || planeIdx &gt;= len(cg) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Get YCoCg values (shifted to signed range)
                        <span class="cov1" title="1">yVal := int(luma[planeIdx])
                        coVal := int(co[planeIdx]) - 128
                        cgVal := int(cg[planeIdx]) - 128

                        // YCoCg to RGB conversion
                        t := yVal - cgVal
                        r := clampByteNS(t + coVal)
                        g := clampByteNS(yVal + cgVal)
                        b := clampByteNS(t - coVal)

                        rgba[rgbaIdx+0] = r
                        rgba[rgbaIdx+1] = g
                        rgba[rgbaIdx+2] = b

                        // Alpha
                        if alpha != nil &amp;&amp; planeIdx &lt; len(alpha) </span><span class="cov0" title="0">{
                                rgba[rgbaIdx+3] = alpha[planeIdx]
                        }</span> else<span class="cov1" title="1"> {
                                rgba[rgbaIdx+3] = 255
                        }</span>
                }
        }

        <span class="cov1" title="1">return rgba</span>
}

// DecodeNSCodecToRGBA decodes an NSCodec bitmap stream to RGBA pixels
func DecodeNSCodecToRGBA(data []byte, width, height int) []byte <span class="cov5" title="3">{
        if len(data) &lt; 20 </span><span class="cov1" title="1">{ // Minimum header size
                return nil
        }</span>

        // Parse header
        <span class="cov4" title="2">lumaPlaneByteCount := int(uint32(data[0]) | uint32(data[1])&lt;&lt;8 | uint32(data[2])&lt;&lt;16 | uint32(data[3])&lt;&lt;24)
        orangeChromaPlaneByteCount := int(uint32(data[4]) | uint32(data[5])&lt;&lt;8 | uint32(data[6])&lt;&lt;16 | uint32(data[7])&lt;&lt;24)
        greenChromaPlaneByteCount := int(uint32(data[8]) | uint32(data[9])&lt;&lt;8 | uint32(data[10])&lt;&lt;16 | uint32(data[11])&lt;&lt;24)
        alphaPlaneByteCount := int(uint32(data[12]) | uint32(data[13])&lt;&lt;8 | uint32(data[14])&lt;&lt;16 | uint32(data[15])&lt;&lt;24)
        colorLossLevel := data[16]
        chromaSubsamplingLevel := data[17]
        // Reserved: data[18:20]

        if colorLossLevel &lt; 1 || colorLossLevel &gt; 7 </span><span class="cov4" title="2">{
                return nil
        }</span>

        <span class="cov0" title="0">chromaSubsampling := chromaSubsamplingLevel != 0

        // Calculate expected plane sizes
        var lumaWidth, lumaHeight int
        var chromaWidth, chromaHeight int

        if chromaSubsampling </span><span class="cov0" title="0">{
                lumaWidth = roundUpToMultiple(width, 8)
                lumaHeight = height
                chromaWidth = lumaWidth / 2
                chromaHeight = roundUpToMultiple(height, 2) / 2
        }</span> else<span class="cov0" title="0"> {
                lumaWidth = width
                lumaHeight = height
                chromaWidth = width
                chromaHeight = height
        }</span>

        <span class="cov0" title="0">lumaExpectedSize := lumaWidth * lumaHeight
        chromaExpectedSize := chromaWidth * chromaHeight

        // Extract planes from data
        offset := 20

        var lumaPlaneData, orangePlaneData, greenPlaneData, alphaPlaneData []byte

        if lumaPlaneByteCount &gt; 0 </span><span class="cov0" title="0">{
                if offset+lumaPlaneByteCount &gt; len(data) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">lumaPlaneData = data[offset : offset+lumaPlaneByteCount]
                offset += lumaPlaneByteCount</span>
        }

        <span class="cov0" title="0">if orangeChromaPlaneByteCount &gt; 0 </span><span class="cov0" title="0">{
                if offset+orangeChromaPlaneByteCount &gt; len(data) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">orangePlaneData = data[offset : offset+orangeChromaPlaneByteCount]
                offset += orangeChromaPlaneByteCount</span>
        }

        <span class="cov0" title="0">if greenChromaPlaneByteCount &gt; 0 </span><span class="cov0" title="0">{
                if offset+greenChromaPlaneByteCount &gt; len(data) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">greenPlaneData = data[offset : offset+greenChromaPlaneByteCount]
                offset += greenChromaPlaneByteCount</span>
        }

        <span class="cov0" title="0">if alphaPlaneByteCount &gt; 0 </span><span class="cov0" title="0">{
                if offset+alphaPlaneByteCount &gt; len(data) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">alphaPlaneData = data[offset : offset+alphaPlaneByteCount]</span>
        }

        // Decompress planes
        <span class="cov0" title="0">lumaPlane := NSCodecRLEDecompress(lumaPlaneData, lumaExpectedSize)
        if lumaPlane == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">orangePlane := NSCodecRLEDecompress(orangePlaneData, chromaExpectedSize)
        if orangePlane == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">greenPlane := NSCodecRLEDecompress(greenPlaneData, chromaExpectedSize)
        if greenPlane == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var alphaPlane []byte
        if alphaPlaneByteCount &gt; 0 </span><span class="cov0" title="0">{
                alphaExpectedSize := width * height
                alphaPlane = NSCodecRLEDecompress(alphaPlaneData, alphaExpectedSize)
                if alphaPlane == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // Apply chroma super-sampling if needed
        <span class="cov0" title="0">if chromaSubsampling </span><span class="cov0" title="0">{
                orangePlane = ChromaSuperSample(orangePlane, chromaWidth, chromaHeight, lumaWidth, lumaHeight)
                greenPlane = ChromaSuperSample(greenPlane, chromaWidth, chromaHeight, lumaWidth, lumaHeight)
        }</span>

        // Apply color loss restoration
        <span class="cov0" title="0">if colorLossLevel &gt; 1 </span><span class="cov0" title="0">{
                orangePlane = RestoreColorLoss(orangePlane, colorLossLevel)
                greenPlane = RestoreColorLoss(greenPlane, colorLossLevel)
        }</span>

        // Convert AYCoCg to RGBA
        <span class="cov0" title="0">return AYCoCgToRGBA(lumaPlane, orangePlane, greenPlane, alphaPlane, lumaWidth, lumaHeight, width, height)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package codec

// RDP6 Planar Codec decoder
// Reference: MS-RDPEGDI 2.2.2.5 and FreeRDP planar.c

const (
        // Format header flags
        PlanarFlagRLE     = 0x10 // Run Length Encoding
        PlanarFlagNoAlpha = 0x20 // No Alpha plane
)

// DecompressPlanar decompresses RDP6 Planar codec data to RGBA
func DecompressPlanar(src []byte, width, height int) []byte <span class="cov4" title="5">{
        if len(src) &lt; 1 </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov3" title="3">formatHeader := src[0]
        hasRLE := (formatHeader &amp; PlanarFlagRLE) != 0
        noAlpha := (formatHeader &amp; PlanarFlagNoAlpha) != 0

        srcIdx := 1
        planeSize := width * height

        // Allocate planes
        planeR := make([]byte, planeSize)
        planeG := make([]byte, planeSize)
        planeB := make([]byte, planeSize)
        planeA := make([]byte, planeSize)

        // Initialize alpha to 255 if no alpha plane
        if noAlpha </span><span class="cov2" title="2">{
                for i := range planeA </span><span class="cov10" title="104">{
                        planeA[i] = 255
                }</span>
        }

        <span class="cov3" title="3">if hasRLE </span><span class="cov0" title="0">{
                // RLE encoded planes: Alpha, Red, Green, Blue order
                var consumed int

                if !noAlpha </span><span class="cov0" title="0">{
                        consumed = decompressPlanarPlaneRLE(src[srcIdx:], planeA, width, height)
                        if consumed &lt; 0 </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">srcIdx += consumed</span>
                }

                <span class="cov0" title="0">consumed = decompressPlanarPlaneRLE(src[srcIdx:], planeR, width, height)
                if consumed &lt; 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">srcIdx += consumed

                consumed = decompressPlanarPlaneRLE(src[srcIdx:], planeG, width, height)
                if consumed &lt; 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">srcIdx += consumed

                consumed = decompressPlanarPlaneRLE(src[srcIdx:], planeB, width, height)
                if consumed &lt; 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
        } else<span class="cov3" title="3"> {
                // Raw planes
                if !noAlpha </span><span class="cov1" title="1">{
                        if srcIdx+planeSize &gt; len(src) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov1" title="1">copy(planeA, src[srcIdx:srcIdx+planeSize])
                        srcIdx += planeSize</span>
                }

                <span class="cov3" title="3">if srcIdx+planeSize &gt; len(src) </span><span class="cov1" title="1">{
                        return nil
                }</span>
                <span class="cov2" title="2">copy(planeR, src[srcIdx:srcIdx+planeSize])
                srcIdx += planeSize

                if srcIdx+planeSize &gt; len(src) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov2" title="2">copy(planeG, src[srcIdx:srcIdx+planeSize])
                srcIdx += planeSize

                if srcIdx+planeSize &gt; len(src) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov2" title="2">copy(planeB, src[srcIdx:srcIdx+planeSize])</span>
        }

        // Combine planes to RGBA with vertical flip (planar data is bottom-up)
        <span class="cov2" title="2">rgba := make([]byte, planeSize*4)
        for y := 0; y &lt; height; y++ </span><span class="cov3" title="4">{
                srcRow := (height - 1 - y) * width // Read from bottom
                dstRow := y * width                // Write to top
                for x := 0; x &lt; width; x++ </span><span class="cov5" title="8">{
                        srcIdx := srcRow + x
                        dstIdx := (dstRow + x) * 4
                        rgba[dstIdx] = planeR[srcIdx]
                        rgba[dstIdx+1] = planeG[srcIdx]
                        rgba[dstIdx+2] = planeB[srcIdx]
                        rgba[dstIdx+3] = planeA[srcIdx]
                }</span>
        }

        <span class="cov2" title="2">return rgba</span>
}

// decompressPlanarPlaneRLE decompresses a single RLE-encoded plane
// Returns number of bytes consumed, or -1 on error
func decompressPlanarPlaneRLE(src []byte, dst []byte, width, height int) int <span class="cov3" title="4">{
        srcIdx := 0
        dstIdx := 0
        var previousScanline []byte

        for y := 0; y &lt; height; y++ </span><span class="cov3" title="4">{
                currentScanlineStart := dstIdx
                var pixel int16 = 0 // Last pixel/delta value

                for x := 0; x &lt; width; </span><span class="cov3" title="4">{
                        if srcIdx &gt;= len(src) </span><span class="cov0" title="0">{
                                return -1
                        }</span>

                        <span class="cov3" title="4">controlByte := src[srcIdx]
                        srcIdx++

                        nRunLength := int(controlByte &amp; 0x0F)
                        cRawBytes := int((controlByte &gt;&gt; 4) &amp; 0x0F)

                        // Extended run lengths
                        switch nRunLength </span>{
                        case 1:<span class="cov1" title="1">
                                nRunLength = cRawBytes + 16
                                cRawBytes = 0</span>
                        case 2:<span class="cov0" title="0">
                                nRunLength = cRawBytes + 32
                                cRawBytes = 0</span>
                        }

                        <span class="cov3" title="4">if x+cRawBytes+nRunLength &gt; width </span><span class="cov0" title="0">{
                                return -1
                        }</span>

                        <span class="cov3" title="4">if previousScanline == nil </span><span class="cov3" title="4">{
                                // First scanline: absolute values
                                for cRawBytes &gt; 0 </span><span class="cov4" title="7">{
                                        if srcIdx &gt;= len(src) || dstIdx &gt;= len(dst) </span><span class="cov1" title="1">{
                                                return -1
                                        }</span>
                                        <span class="cov4" title="6">pixel = int16(src[srcIdx])
                                        srcIdx++
                                        dst[dstIdx] = byte(pixel)
                                        dstIdx++
                                        x++
                                        cRawBytes--</span>
                                }

                                <span class="cov3" title="3">for nRunLength &gt; 0 </span><span class="cov7" title="24">{
                                        if dstIdx &gt;= len(dst) </span><span class="cov0" title="0">{
                                                return -1
                                        }</span>
                                        <span class="cov7" title="24">dst[dstIdx] = byte(pixel)
                                        dstIdx++
                                        x++
                                        nRunLength--</span>
                                }
                        } else<span class="cov0" title="0"> {
                                // Delta values relative to previous scanline
                                for cRawBytes &gt; 0 </span><span class="cov0" title="0">{
                                        if srcIdx &gt;= len(src) || dstIdx &gt;= len(dst) </span><span class="cov0" title="0">{
                                                return -1
                                        }</span>
                                        <span class="cov0" title="0">deltaValue := src[srcIdx]
                                        srcIdx++

                                        // Decode delta (sign-magnitude encoding)
                                        if deltaValue&amp;1 != 0 </span><span class="cov0" title="0">{
                                                // Negative delta
                                                pixel = -int16((deltaValue &gt;&gt; 1) + 1)
                                        }</span> else<span class="cov0" title="0"> {
                                                // Positive delta
                                                pixel = int16(deltaValue &gt;&gt; 1)
                                        }</span>

                                        // Add delta to previous scanline value
                                        <span class="cov0" title="0">dst[dstIdx] = byte(int16(previousScanline[x]) + pixel)
                                        dstIdx++
                                        x++
                                        cRawBytes--</span>
                                }

                                // For run, add same delta to each previous scanline value
                                <span class="cov0" title="0">for nRunLength &gt; 0 </span><span class="cov0" title="0">{
                                        if dstIdx &gt;= len(dst) </span><span class="cov0" title="0">{
                                                return -1
                                        }</span>
                                        <span class="cov0" title="0">dst[dstIdx] = byte(int16(previousScanline[x]) + pixel)
                                        dstIdx++
                                        x++
                                        nRunLength--</span>
                                }
                        }
                }

                <span class="cov3" title="3">previousScanline = dst[currentScanlineStart:dstIdx]</span>
        }

        <span class="cov3" title="3">return srcIdx</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package rfx

// DifferentialDecode decodes differentially-encoded coefficients.
// In RemoteFX, the LL3 (DC) subband is differentially encoded -
// each coefficient is stored as the difference from the previous value.
// This function reverses that encoding by computing running sums.
//
// Must be called AFTER RLGR decoding on the LL3 subband (buffer[4032:4096]).
func DifferentialDecode(buffer []int16, size int) <span class="cov4" title="11">{
        if len(buffer) &lt; size </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov4" title="11">for i := 1; i &lt; size; i++ </span><span class="cov10" title="388">{
                buffer[i] += buffer[i-1]
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package rfx

// Inverse 2D DWT (Discrete Wavelet Transform) using 5/3 LeGall wavelet.
//
// The coefficient buffer uses linear/packed layout:
// - HL1 (3232) at offset 0
// - LH1 (3232) at offset 1024
// - HH1 (3232) at offset 2048
// - HL2 (1616) at offset 3072
// - LH2 (1616) at offset 3328
// - HH2 (1616) at offset 3584
// - HL3 (88)   at offset 3840
// - LH3 (88)   at offset 3904
// - HH3 (88)   at offset 3968
// - LL3 (88)   at offset 4032
//
// This implementation follows FreeRDP's rfx_dwt.c algorithm.

// dwtTempBuffer is a pre-allocated buffer for DWT intermediate results.
// This avoids allocation in the hot path for WASM.
var dwtTempBuffer [TilePixels]int16

// InverseDWT2D performs 3-level inverse 2D DWT on tile coefficients.
// Input: 4096 int16 coefficients in packed subband order
// Output: 4096 int16 spatial-domain values (in-place, returns same slice)
func InverseDWT2D(buffer []int16) []int16 <span class="cov3" title="11">{
        if len(buffer) &lt; TilePixels </span><span class="cov1" title="2">{
                return nil
        }</span>

        // Use pre-allocated temp buffer
        <span class="cov2" title="9">temp := dwtTempBuffer[:]

        // Level 3: 88  1616
        // Input: HL3(@3840), LH3(@3904), HH3(@3968), LL3(@4032)
        // Output: HL2-LH2-HH2 region starting at offset 3072
        idwt2DBlock(buffer, temp, 3840, 8)

        // Level 2: 1616  3232
        // Input: HL2(@3072), LH2(@3328), HH2(@3584), + L2 from level 3
        // Output: HL1-LH1-HH1 region starting at offset 0
        idwt2DBlock(buffer, temp, 3072, 16)

        // Level 1: 3232  6464
        // Input: HL1(@0), LH1(@1024), HH1(@2048), + L1 from level 2
        // Output: Full 6464 spatial tile at offset 0
        idwt2DBlock(buffer, temp, 0, 32)

        return buffer</span>
}

// idwt2DBlock performs one level of inverse 2D DWT.
// After this operation, the output occupies 4*size*size elements starting at offset.
// The subbands are stored as: HL, LH, HH, LL (each size*size elements).
//
// Algorithm from FreeRDP rfx_dwt.c (5/3 LeGall lifting):
// Horizontal pass combines columns: LL+HL and LH+HH
// Vertical pass combines rows to produce final output
func idwt2DBlock(buffer, temp []int16, offset, size int) <span class="cov3" title="27">{
        // Calculate subband positions
        // At input: HL at offset, LH at offset+size, HH at offset+2*size, LL at offset+3*size
        size2 := size * size
        hlOfs := offset
        lhOfs := offset + size2
        hhOfs := offset + 2*size2
        llOfs := offset + 3*size2

        total := size * 2 // Output dimension

        // Horizontal pass: process each row
        // Output: L (left half) in temp[0:total*size], H (right half) in temp[total*size:]
        lDst := 0
        hDst := total * size
        for y := 0; y &lt; size; y++ </span><span class="cov6" title="504">{
                // Combine LL and HL  L row
                idwt1DRow(buffer[llOfs+y*size:], buffer[hlOfs+y*size:], temp[lDst:], size)
                lDst += total
                // Combine LH and HH  H row
                idwt1DRow(buffer[lhOfs+y*size:], buffer[hhOfs+y*size:], temp[hDst:], size)
                hDst += total
        }</span>

        // Vertical pass: process each column
        // Combine L and H columns to produce final output
        <span class="cov3" title="27">lSrc := 0
        hSrc := total * size
        for x := 0; x &lt; total; x++ </span><span class="cov7" title="1008">{
                idwt1DCol(temp, lSrc+x, hSrc+x, buffer, offset+x, total, size)
        }</span>
}

// idwt1DRow performs horizontal 1D inverse DWT.
// low: low-frequency coefficients (LL or LH row)
// high: high-frequency coefficients (HL or HH row)
// dst: output buffer (length = 2*halfSize)
// halfSize: number of samples in each input
//
// 5/3 LeGall inverse lifting (from FreeRDP):
// even[n] = low[n] - ((high[n-1] + high[n] + 1) &gt;&gt; 1)
// odd[n] = (high[n] &lt;&lt; 1) + ((even[n] + even[n+1]) &gt;&gt; 1)
func idwt1DRow(low, high []int16, dst []int16, halfSize int) <span class="cov7" title="1010">{
        // First even sample (n=0): high[-1] mirrors to high[0]
        dst[0] = low[0] - ((high[0] + high[0] + 1) &gt;&gt; 1)

        // Even samples (n=1 to halfSize-1)
        for n := 1; n &lt; halfSize; n++ </span><span class="cov10" title="23188">{
                dst[n*2] = low[n] - ((high[n-1] + high[n] + 1) &gt;&gt; 1)
        }</span>

        // Odd samples (n=0 to halfSize-2)
        <span class="cov7" title="1010">for n := 0; n &lt; halfSize-1; n++ </span><span class="cov10" title="23188">{
                dst[n*2+1] = (high[n] &lt;&lt; 1) + ((dst[n*2] + dst[n*2+2]) &gt;&gt; 1)
        }</span>

        // Last odd sample (n=halfSize-1): even[n+1] mirrors to even[n]
        <span class="cov7" title="1010">n := halfSize - 1
        dst[n*2+1] = (high[n] &lt;&lt; 1) + ((dst[n*2] + dst[n*2]) &gt;&gt; 1)</span>
}

// idwt1DCol performs vertical 1D inverse DWT on a column.
// src: source buffer containing L and H rows
// lOfs: offset to low-frequency column start
// hOfs: offset to high-frequency column start
// dst: destination buffer
// dstOfs: offset to output column start
// stride: distance between rows in source/destination
// halfSize: number of samples in each input column
func idwt1DCol(src []int16, lOfs, hOfs int, dst []int16, dstOfs, stride, halfSize int) <span class="cov7" title="1008">{
        // First even sample (n=0): h[-1] mirrors to h[0]
        l0 := src[lOfs]
        h0 := src[hOfs]
        even0 := l0 - ((h0 + h0 + 1) &gt;&gt; 1)
        dst[dstOfs] = even0

        // Even samples (n=1 to halfSize-1)
        for n := 1; n &lt; halfSize; n++ </span><span class="cov9" title="23184">{
                ln := src[lOfs+n*stride]
                hPrev := src[hOfs+(n-1)*stride]
                hn := src[hOfs+n*stride]
                dst[dstOfs+n*2*stride] = ln - ((hPrev + hn + 1) &gt;&gt; 1)
        }</span>

        // Odd samples (n=0 to halfSize-2)
        <span class="cov7" title="1008">for n := 0; n &lt; halfSize-1; n++ </span><span class="cov9" title="23184">{
                hn := src[hOfs+n*stride]
                en := dst[dstOfs+n*2*stride]
                enNext := dst[dstOfs+(n*2+2)*stride]
                dst[dstOfs+(n*2+1)*stride] = (hn &lt;&lt; 1) + ((en + enNext) &gt;&gt; 1)
        }</span>

        // Last odd sample (n=halfSize-1): even[n+1] mirrors to even[n]
        <span class="cov7" title="1008">n := halfSize - 1
        hn := src[hOfs+n*stride]
        en := dst[dstOfs+n*2*stride]
        dst[dstOfs+(n*2+1)*stride] = (hn &lt;&lt; 1) + ((en + en) &gt;&gt; 1)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package rfx

import (
        "encoding/binary"
        "fmt"
)

// ParseRFXMessage parses a complete RFX message and returns decoded tiles.
func ParseRFXMessage(data []byte, ctx *Context) (*Frame, error) <span class="cov9" title="13">{
        if len(data) &lt; 6 </span><span class="cov1" title="1">{
                return nil, ErrInvalidBlockLength
        }</span>

        <span class="cov9" title="12">frame := &amp;Frame{
                Tiles: make([]*Tile, 0),
        }

        offset := 0

        for offset &lt; len(data) </span><span class="cov10" title="15">{
                if offset+6 &gt; len(data) </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov10" title="15">blockType := binary.LittleEndian.Uint16(data[offset:])
                blockLen := int(binary.LittleEndian.Uint32(data[offset+2:]))

                if blockLen &lt; 6 || offset+blockLen &gt; len(data) </span><span class="cov3" title="2">{
                        return nil, fmt.Errorf("%w: block at offset %d", ErrInvalidBlockLength, offset)
                }</span>

                <span class="cov9" title="13">blockData := data[offset : offset+blockLen]

                switch blockType </span>{
                case WBT_SYNC:<span class="cov3" title="2">
                        if err := parseSyncBlock(blockData); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                case WBT_CODEC_VERSIONS:<span class="cov1" title="1"></span>
                        // Contains codec version info, usually just verification

                case WBT_CHANNELS:<span class="cov1" title="1"></span>
                        // Contains channel info (usually just channel 0)

                case WBT_CONTEXT:<span class="cov3" title="2">
                        if err := parseContextBlock(blockData, ctx); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                case WBT_FRAME_BEGIN:<span class="cov3" title="2">
                        frameIdx, err := parseFrameBegin(blockData)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov3" title="2">frame.FrameIdx = frameIdx</span>

                case WBT_REGION:<span class="cov3" title="2">
                        rects, err := parseRegionBlock(blockData)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov3" title="2">frame.Rects = rects</span>

                case WBT_TILESET:<span class="cov0" title="0">
                        tiles, err := parseTilesetBlock(blockData, ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">frame.Tiles = append(frame.Tiles, tiles...)</span>

                case WBT_FRAME_END:<span class="cov3" title="2"></span>
                        // Frame complete

                case WBT_EXTENSION:<span class="cov1" title="1"></span>
                        // Extension block, skip for now
                }

                <span class="cov9" title="13">offset += blockLen</span>
        }

        <span class="cov8" title="10">return frame, nil</span>
}

func parseSyncBlock(data []byte) error <span class="cov4" title="3">{
        if len(data) &lt; 12 </span><span class="cov1" title="1">{
                return ErrInvalidBlockLength
        }</span>
        // magic := binary.LittleEndian.Uint32(data[6:])
        // version := binary.LittleEndian.Uint16(data[10:])
        // Verify magic == 0xCACCACCA and version == 0x0100
        <span class="cov3" title="2">return nil</span>
}

func parseContextBlock(data []byte, ctx *Context) error <span class="cov4" title="3">{
        if len(data) &lt; 13 </span><span class="cov1" title="1">{
                return ErrInvalidBlockLength
        }</span>

        <span class="cov3" title="2">offset := 6 // Skip block header

        // ctxId := data[offset]
        offset++

        // tileSize := binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        ctx.Width = binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        ctx.Height = binary.LittleEndian.Uint16(data[offset:])

        return nil</span>
}

func parseFrameBegin(data []byte) (uint32, error) <span class="cov4" title="3">{
        if len(data) &lt; 14 </span><span class="cov1" title="1">{
                return 0, ErrInvalidBlockLength
        }</span>

        <span class="cov3" title="2">frameIdx := binary.LittleEndian.Uint32(data[6:])
        // numRegions := binary.LittleEndian.Uint16(data[10:])

        return frameIdx, nil</span>
}

func parseRegionBlock(data []byte) ([]Rect, error) <span class="cov4" title="3">{
        if len(data) &lt; 15 </span><span class="cov1" title="1">{
                return nil, ErrInvalidBlockLength
        }</span>

        <span class="cov3" title="2">offset := 6 // Skip block header

        // regionFlags := data[offset]
        offset++

        numRects := binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        rects := make([]Rect, numRects)

        for i := uint16(0); i &lt; numRects &amp;&amp; offset+8 &lt;= len(data); i++ </span><span class="cov4" title="3">{
                rects[i] = Rect{
                        X:      binary.LittleEndian.Uint16(data[offset:]),
                        Y:      binary.LittleEndian.Uint16(data[offset+2:]),
                        Width:  binary.LittleEndian.Uint16(data[offset+4:]),
                        Height: binary.LittleEndian.Uint16(data[offset+6:]),
                }
                offset += 8
        }</span>

        <span class="cov3" title="2">return rects, nil</span>
}

func parseTilesetBlock(data []byte, ctx *Context) ([]*Tile, error) <span class="cov3" title="2">{
        if len(data) &lt; 22 </span><span class="cov1" title="1">{
                return nil, ErrInvalidBlockLength
        }</span>

        <span class="cov1" title="1">offset := 6 // Skip block header

        // subtype := binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        // idx := binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        // flags := binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        numQuant := data[offset]
        offset++

        // tileSize := data[offset]
        offset++

        numTiles := binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        // tileDataSize := binary.LittleEndian.Uint32(data[offset:])
        offset += 4

        // Parse quantization tables
        quantTables := make([]*SubbandQuant, numQuant)
        for i := uint8(0); i &lt; numQuant &amp;&amp; offset+5 &lt;= len(data); i++ </span><span class="cov1" title="1">{
                quant, err := ParseQuantValues(data[offset:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">quantTables[i] = quant
                offset += 5</span>
        }

        // Parse tiles
        <span class="cov1" title="1">tiles := make([]*Tile, 0, numTiles)

        for i := uint16(0); i &lt; numTiles &amp;&amp; offset &lt; len(data); i++ </span><span class="cov0" title="0">{
                if offset+6 &gt; len(data) </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">tileBlockType := binary.LittleEndian.Uint16(data[offset:])
                if tileBlockType != CBT_TILE </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">tileBlockLen := int(binary.LittleEndian.Uint32(data[offset+2:]))
                if offset+tileBlockLen &gt; len(data) </span><span class="cov0" title="0">{
                        break</span>
                }

                // Get quant indices from tile header
                <span class="cov0" title="0">quantIdxY := data[offset+6]
                quantIdxCb := data[offset+7]
                quantIdxCr := data[offset+8]

                // Get quant tables (with bounds checking)
                quantY := DefaultQuant()
                quantCb := DefaultQuant()
                quantCr := DefaultQuant()

                if int(quantIdxY) &lt; len(quantTables) &amp;&amp; quantTables[quantIdxY] != nil </span><span class="cov0" title="0">{
                        quantY = quantTables[quantIdxY]
                }</span>
                <span class="cov0" title="0">if int(quantIdxCb) &lt; len(quantTables) &amp;&amp; quantTables[quantIdxCb] != nil </span><span class="cov0" title="0">{
                        quantCb = quantTables[quantIdxCb]
                }</span>
                <span class="cov0" title="0">if int(quantIdxCr) &lt; len(quantTables) &amp;&amp; quantTables[quantIdxCr] != nil </span><span class="cov0" title="0">{
                        quantCr = quantTables[quantIdxCr]
                }</span>

                <span class="cov0" title="0">tile, err := DecodeTile(data[offset:offset+tileBlockLen], quantY, quantCb, quantCr)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other tiles
                        offset += tileBlockLen
                        continue</span>
                }

                <span class="cov0" title="0">tiles = append(tiles, tile)
                offset += tileBlockLen</span>
        }

        <span class="cov1" title="1">return tiles, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package rfx

// Subband layout for 6464 tile coefficient buffer (linear/packed format):
// See rfx.go for offset constants (OffsetHL1, OffsetLH1, etc.)
//
// Dequantization: coefficient = coefficient &lt;&lt; (quant - 1)
// Note: MS-RDPRFX specifies quant values 6-15, effective shift is (quant - 1)
//
// Quantization value ordering (indices 0-9 in quant array):
// [0]=LL3, [1]=LH3, [2]=HL3, [3]=HH3, [4]=LH2, [5]=HL2, [6]=HH2, [7]=LH1, [8]=HL1, [9]=HH1

// Dequantize applies inverse quantization to DWT coefficients.
// The buffer uses linear/packed layout matching FreeRDP.
func Dequantize(buffer []int16, quant *SubbandQuant) <span class="cov2" title="9">{
        if quant == nil || len(buffer) &lt; TilePixels </span><span class="cov1" title="1">{
                return
        }</span>

        // Level 1 subbands (3232 = 1024 each)
        <span class="cov2" title="8">dequantBlock(buffer[OffsetHL1:OffsetHL1+SizeL1], quant.HL1)
        dequantBlock(buffer[OffsetLH1:OffsetLH1+SizeL1], quant.LH1)
        dequantBlock(buffer[OffsetHH1:OffsetHH1+SizeL1], quant.HH1)

        // Level 2 subbands (1616 = 256 each)
        dequantBlock(buffer[OffsetHL2:OffsetHL2+SizeL2], quant.HL2)
        dequantBlock(buffer[OffsetLH2:OffsetLH2+SizeL2], quant.LH2)
        dequantBlock(buffer[OffsetHH2:OffsetHH2+SizeL2], quant.HH2)

        // Level 3 subbands (88 = 64 each)
        dequantBlock(buffer[OffsetHL3:OffsetHL3+SizeL3], quant.HL3)
        dequantBlock(buffer[OffsetLH3:OffsetLH3+SizeL3], quant.LH3)
        dequantBlock(buffer[OffsetHH3:OffsetHH3+SizeL3], quant.HH3)
        dequantBlock(buffer[OffsetLL3:OffsetLL3+SizeL3], quant.LL3)</span>
}

// dequantBlock applies dequantization shift to a contiguous block.
// shift = quantValue - 1 per MS-RDPRFX spec
func dequantBlock(data []int16, quantValue uint8) <span class="cov4" title="80">{
        if quantValue &lt;= 1 </span><span class="cov0" title="0">{
                return // No shift needed
        }</span>
        <span class="cov4" title="80">shift := quantValue - 1
        for i := range data </span><span class="cov10" title="32768">{
                data[i] &lt;&lt;= shift
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package rfx implements the RemoteFX (RFX) codec decoder as specified in MS-RDPRFX.
// RemoteFX is a tile-based wavelet codec used for efficient remote desktop graphics.
package rfx

import "errors"

// Tile dimensions (fixed by MS-RDPRFX specification)
const (
        TileSize     = 64
        TilePixels   = TileSize * TileSize // 4096
        TileRGBASize = TilePixels * 4      // 16384 bytes
)

// Subband buffer offsets (linear/packed layout as used by FreeRDP)
// Coefficients are stored in this order in a 4096-element buffer:
// - HL1 (3232 = 1024) at offset 0
// - LH1 (3232 = 1024) at offset 1024
// - HH1 (3232 = 1024) at offset 2048
// - HL2 (1616 = 256)  at offset 3072
// - LH2 (1616 = 256)  at offset 3328
// - HH2 (1616 = 256)  at offset 3584
// - HL3 (88 = 64)     at offset 3840
// - LH3 (88 = 64)     at offset 3904
// - HH3 (88 = 64)     at offset 3968
// - LL3 (88 = 64)     at offset 4032
const (
        OffsetHL1 = 0
        OffsetLH1 = 1024
        OffsetHH1 = 2048
        OffsetHL2 = 3072
        OffsetLH2 = 3328
        OffsetHH2 = 3584
        OffsetHL3 = 3840
        OffsetLH3 = 3904
        OffsetHH3 = 3968
        OffsetLL3 = 4032

        SizeL1 = 1024 // 3232
        SizeL2 = 256  // 1616
        SizeL3 = 64   // 88
)

// RLGR coding modes
const (
        RLGR1 = 1 // Used for Y (luminance) component
        RLGR3 = 3 // Used for Cb, Cr (chrominance) components
)

// RLGR adaptive coding constants (from MS-RDPRFX section 3.1.8.1.7.1)
const (
        KPMAX = 80 // Maximum value for kp parameter
        LSGR  = 3  // Log2 scale factor for Golomb-Rice parameter
        UP_GR = 4  // Increment for run-length coding
        DN_GR = 6  // Decrement after non-zero value
        UQ_GR = 3  // Increment for zero value (RLGR1)
        DQ_GR = 3  // Decrement for non-zero value (RLGR1)
)

// Block type constants (MS-RDPRFX section 2.2.2.1.1)
const (
        WBT_SYNC           uint16 = 0xCCC0
        WBT_CODEC_VERSIONS uint16 = 0xCCC1
        WBT_CHANNELS       uint16 = 0xCCC2
        WBT_CONTEXT        uint16 = 0xCCC3
        WBT_FRAME_BEGIN    uint16 = 0xCCC4
        WBT_FRAME_END      uint16 = 0xCCC5
        WBT_REGION         uint16 = 0xCCC6
        WBT_EXTENSION      uint16 = 0xCCC7
        WBT_TILESET        uint16 = 0xCAC2
        CBT_TILE           uint16 = 0xCAC3
)

// Codec capability constants
const (
        CLW_VERSION_1_0    uint16 = 0x0100
        CT_TILE_64x64      uint16 = 0x0040
        CLW_COL_CONV_ICT   uint8  = 0x01
        CLW_XFORM_DWT_53_A uint8  = 0x01
        CLW_ENTROPY_RLGR1  uint8  = 0x01
        CLW_ENTROPY_RLGR3  uint8  = 0x04
)

// Errors
var (
        ErrInvalidBlockType   = errors.New("rfx: invalid block type")
        ErrInvalidBlockLength = errors.New("rfx: invalid block length")
        ErrInvalidTileData    = errors.New("rfx: invalid tile data")
        ErrRLGRDecodeError    = errors.New("rfx: RLGR decode error")
        ErrBufferTooSmall     = errors.New("rfx: buffer too small")
        ErrInvalidQuantValues = errors.New("rfx: invalid quantization values")
)

// SubbandQuant holds quantization values for all 10 subbands.
// Values are packed as 4-bit nibbles in the protocol.
type SubbandQuant struct {
        LL3 uint8 // Level 3 approximation (DC)
        LH3 uint8 // Level 3 horizontal detail
        HL3 uint8 // Level 3 vertical detail
        HH3 uint8 // Level 3 diagonal detail
        LH2 uint8 // Level 2 horizontal detail
        HL2 uint8 // Level 2 vertical detail
        HH2 uint8 // Level 2 diagonal detail
        LH1 uint8 // Level 1 horizontal detail
        HL1 uint8 // Level 1 vertical detail
        HH1 uint8 // Level 1 diagonal detail
}

// Tile represents a decoded 6464 pixel tile
type Tile struct {
        X    uint16 // Tile X index (multiply by 64 for pixel position)
        Y    uint16 // Tile Y index (multiply by 64 for pixel position)
        RGBA []byte // Decoded RGBA pixels (16384 bytes)
}

// Frame represents a complete RFX frame with multiple tiles
type Frame struct {
        FrameIdx uint32
        Tiles    []*Tile
        Rects    []Rect
}

// Rect represents a rectangular region
type Rect struct {
        X, Y          uint16
        Width, Height uint16
}

// Context holds decoder state across frames
type Context struct {
        Width       uint16
        Height      uint16
        EntropyMode uint8 // RLGR1 or RLGR3

        // Quantization tables (indexed by quantIdxY, quantIdxCb, quantIdxCr)
        QuantTables []SubbandQuant
}

// NewContext creates a new RFX decoding context
func NewContext() *Context <span class="cov10" title="17">{
        return &amp;Context{
                QuantTables: make([]SubbandQuant, 0, 8),
        }
}</span>

// DefaultQuant returns default quantization values (quality ~85%)
func DefaultQuant() *SubbandQuant <span class="cov8" title="11">{
        return &amp;SubbandQuant{
                LL3: 6, LH3: 6, HL3: 6, HH3: 6,
                LH2: 7, HL2: 7, HH2: 8,
                LH1: 8, HL1: 8, HH1: 9,
        }
}</span>

// ParseQuantValues parses packed quantization values from the protocol.
// The quant values are packed as pairs of 4-bit nibbles:
// Byte 0: LL3 (low nibble), LH3 (high nibble)
// Byte 1: HL3 (low nibble), HH3 (high nibble)
// Byte 2: LH2 (low nibble), HL2 (high nibble)
// Byte 3: HH2 (low nibble), LH1 (high nibble)
// Byte 4: HL1 (low nibble), HH1 (high nibble)
func ParseQuantValues(data []byte) (*SubbandQuant, error) <span class="cov4" title="3">{
        if len(data) &lt; 5 </span><span class="cov1" title="1">{
                return nil, ErrInvalidQuantValues
        }</span>

        <span class="cov3" title="2">return &amp;SubbandQuant{
                LL3: data[0] &amp; 0x0F,
                LH3: (data[0] &gt;&gt; 4) &amp; 0x0F,
                HL3: data[1] &amp; 0x0F,
                HH3: (data[1] &gt;&gt; 4) &amp; 0x0F,
                LH2: data[2] &amp; 0x0F,
                HL2: (data[2] &gt;&gt; 4) &amp; 0x0F,
                HH2: data[3] &amp; 0x0F,
                LH1: (data[3] &gt;&gt; 4) &amp; 0x0F,
                HL1: data[4] &amp; 0x0F,
                HH1: (data[4] &gt;&gt; 4) &amp; 0x0F,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package rfx

// BitStream provides bit-level reading from a byte slice.
// It uses a 32-bit accumulator for efficient bit extraction.
// Bits are read MSB-first (most significant bit first).
type BitStream struct {
        data      []byte
        bytePos   int
        acc       uint32 // 32-bit lookahead accumulator, left-aligned
        bitsInAcc int    // bits available in accumulator
}

// NewBitStream creates a new bit stream reader
func NewBitStream(data []byte) *BitStream <span class="cov2" title="7">{
        bs := &amp;BitStream{
                data:    data,
                bytePos: 0,
        }
        bs.refill()
        return bs
}</span>

// refill loads more bytes into the accumulator (left-aligned)
func (bs *BitStream) refill() <span class="cov3" title="15">{
        for bs.bitsInAcc &lt;= 24 &amp;&amp; bs.bytePos &lt; len(bs.data) </span><span class="cov3" title="25">{
                // Shift accumulator left by 8, add new byte in LSB position
                bs.acc |= uint32(bs.data[bs.bytePos]) &lt;&lt; (24 - bs.bitsInAcc)
                bs.bytePos++
                bs.bitsInAcc += 8
        }</span>
}

// ReadBits reads n bits (up to 25) from the stream
func (bs *BitStream) ReadBits(n int) uint32 <span class="cov4" title="35">{
        if n == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov4" title="35">if n &gt; bs.bitsInAcc </span><span class="cov1" title="2">{
                bs.refill()
        }</span>
        <span class="cov4" title="35">if n &gt; bs.bitsInAcc </span><span class="cov1" title="2">{
                // Not enough bits remaining, return what we have
                if bs.bitsInAcc == 0 </span><span class="cov1" title="2">{
                        return 0
                }</span>
                <span class="cov0" title="0">result := bs.acc &gt;&gt; (32 - bs.bitsInAcc)
                bs.bitsInAcc = 0
                bs.acc = 0
                return result</span>
        }

        <span class="cov3" title="33">result := bs.acc &gt;&gt; (32 - n)
        bs.acc &lt;&lt;= n
        bs.bitsInAcc -= n
        return result</span>
}

// ReadBit reads a single bit
func (bs *BitStream) ReadBit() uint32 <span class="cov3" title="14">{
        return bs.ReadBits(1)
}</span>

// CountLeadingZeros counts consecutive zero bits (unary prefix) until a 1 is found.
// The terminating 1 bit is consumed.
func (bs *BitStream) CountLeadingZeros() int <span class="cov3" title="12">{
        count := 0
        for </span><span class="cov4" title="38">{
                if bs.bitsInAcc == 0 </span><span class="cov1" title="3">{
                        bs.refill()
                        if bs.bitsInAcc == 0 </span><span class="cov1" title="2">{
                                return count
                        }</span>
                }

                // Check top bit
                <span class="cov4" title="36">if (bs.acc &amp; 0x80000000) != 0 </span><span class="cov2" title="10">{
                        // Found a 1 bit, consume it and return
                        bs.acc &lt;&lt;= 1
                        bs.bitsInAcc--
                        return count
                }</span>

                // Consume the 0 bit
                <span class="cov3" title="26">bs.acc &lt;&lt;= 1
                bs.bitsInAcc--
                count++

                // Safety limit to prevent infinite loops on malformed data
                if count &gt; 32000 </span><span class="cov0" title="0">{
                        return count
                }</span>
        }
}

// CountLeadingOnes counts consecutive one bits until a 0 is found.
// The terminating 0 bit is consumed.
func (bs *BitStream) CountLeadingOnes() int <span class="cov4" title="34">{
        count := 0
        for </span><span class="cov4" title="74">{
                if bs.bitsInAcc == 0 </span><span class="cov1" title="3">{
                        bs.refill()
                        if bs.bitsInAcc == 0 </span><span class="cov1" title="2">{
                                return count
                        }</span>
                }

                // Check top bit
                <span class="cov4" title="72">if (bs.acc &amp; 0x80000000) == 0 </span><span class="cov3" title="32">{
                        // Found a 0 bit, consume it and return
                        bs.acc &lt;&lt;= 1
                        bs.bitsInAcc--
                        return count
                }</span>

                // Consume the 1 bit
                <span class="cov4" title="40">bs.acc &lt;&lt;= 1
                bs.bitsInAcc--
                count++

                if count &gt; 32000 </span><span class="cov0" title="0">{
                        return count
                }</span>
        }
}

// RemainingBits returns approximate remaining bits in stream
func (bs *BitStream) RemainingBits() int <span class="cov4" title="57">{
        return (len(bs.data)-bs.bytePos)*8 + bs.bitsInAcc
}</span>

// RLGRDecode decodes RLGR-encoded data into coefficient array.
// mode: RLGR1 for Y component, RLGR3 for Cb/Cr
// output: pre-allocated int16 slice of size TilePixels (4096)
func RLGRDecode(data []byte, mode int, output []int16) error <span class="cov2" title="10">{
        if len(output) &lt; TilePixels </span><span class="cov1" title="1">{
                return ErrBufferTooSmall
        }</span>

        // Clear output buffer
        <span class="cov2" title="9">for i := range output </span><span class="cov10" title="36864">{
                output[i] = 0
        }</span>

        <span class="cov2" title="9">if len(data) == 0 </span><span class="cov2" title="7">{
                return nil
        }</span>

        <span class="cov1" title="2">bs := NewBitStream(data)

        // Initialize adaptive parameters (MS-RDPRFX 3.1.8.1.7.1)
        k := uint32(1)   // Golomb-Rice parameter for run-length
        kp := uint32(8)  // Scaled k parameter (k = kp &gt;&gt; LSGR)
        kr := uint32(1)  // Golomb-Rice parameter for magnitudes
        krp := uint32(8) // Scaled kr parameter

        idx := 0

        for idx &lt; TilePixels &amp;&amp; bs.RemainingBits() &gt; 0 </span><span class="cov3" title="33">{
                if k != 0 </span><span class="cov3" title="11">{
                        // Run/Literal mode (k &gt; 0)
                        // Decode run of zeros followed by a non-zero value

                        // Count unary prefix (number of full run-length codes)
                        nIdx := bs.CountLeadingZeros()

                        // Calculate run length
                        runLength := 0
                        for i := 0; i &lt; nIdx; i++ </span><span class="cov3" title="22">{
                                runLength += 1 &lt;&lt; k

                                // Update k parameter (increase after each full run)
                                kp += UP_GR
                                if kp &gt; KPMAX </span><span class="cov0" title="0">{
                                        kp = KPMAX
                                }</span>
                                <span class="cov3" title="22">k = kp &gt;&gt; LSGR</span>
                        }

                        // Read remainder bits for partial run
                        <span class="cov3" title="11">if k &gt; 0 &amp;&amp; bs.RemainingBits() &gt;= int(k) </span><span class="cov2" title="9">{
                                remainder := bs.ReadBits(int(k))
                                runLength += int(remainder)
                        }</span>

                        // Output zeros for run
                        <span class="cov3" title="11">for i := 0; i &lt; runLength &amp;&amp; idx &lt; TilePixels; i++ </span><span class="cov5" title="309">{
                                output[idx] = 0
                                idx++
                        }</span>

                        <span class="cov3" title="11">if idx &gt;= TilePixels </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // Decode the non-zero value
                        // Sign bit first
                        <span class="cov3" title="11">sign := bs.ReadBit()

                        // Magnitude using GR coding (count ones, then kr bits)
                        nIdx = bs.CountLeadingOnes()

                        mag := uint32(0)
                        if kr &gt; 0 &amp;&amp; bs.RemainingBits() &gt;= int(kr) </span><span class="cov1" title="2">{
                                mag = bs.ReadBits(int(kr))
                        }</span>
                        <span class="cov3" title="11">mag |= uint32(nIdx) &lt;&lt; kr

                        // Update kr parameter
                        if nIdx == 0 </span><span class="cov2" title="4">{
                                if krp &gt;= 2 </span><span class="cov2" title="4">{
                                        krp -= 2
                                }</span> else<span class="cov0" title="0"> {
                                        krp = 0
                                }</span>
                        } else<span class="cov2" title="7"> if nIdx &gt; 1 </span><span class="cov1" title="3">{
                                krp += uint32(nIdx)
                                if krp &gt; KPMAX </span><span class="cov0" title="0">{
                                        krp = KPMAX
                                }</span>
                        }
                        <span class="cov3" title="11">kr = krp &gt;&gt; LSGR

                        // Update k parameter (decrease after value)
                        if kp &gt;= DN_GR </span><span class="cov3" title="11">{
                                kp -= DN_GR
                        }</span> else<span class="cov0" title="0"> {
                                kp = 0
                        }</span>
                        <span class="cov3" title="11">k = kp &gt;&gt; LSGR

                        // Apply sign and store (magnitude is offset by 1)
                        value := int16(mag + 1)
                        if sign != 0 </span><span class="cov2" title="5">{
                                value = -value
                        }</span>
                        <span class="cov3" title="11">output[idx] = value
                        idx++</span>

                } else<span class="cov3" title="22"> {
                        // GR mode (k == 0) - no run-length coding
                        if mode == RLGR1 </span><span class="cov3" title="16">{
                                // RLGR1: Single value coding with interleaved sign
                                nIdx := bs.CountLeadingOnes()

                                mag := uint32(0)
                                if kr &gt; 0 &amp;&amp; bs.RemainingBits() &gt;= int(kr) </span><span class="cov2" title="4">{
                                        mag = bs.ReadBits(int(kr))
                                }</span>
                                <span class="cov3" title="16">mag |= uint32(nIdx) &lt;&lt; kr

                                // Update kr
                                if nIdx == 0 </span><span class="cov2" title="6">{
                                        if krp &gt;= 2 </span><span class="cov2" title="6">{
                                                krp -= 2
                                        }</span> else<span class="cov0" title="0"> {
                                                krp = 0
                                        }</span>
                                } else<span class="cov2" title="10"> if nIdx &gt; 1 </span><span class="cov1" title="2">{
                                        krp += uint32(nIdx)
                                        if krp &gt; KPMAX </span><span class="cov0" title="0">{
                                                krp = KPMAX
                                        }</span>
                                }
                                <span class="cov3" title="16">kr = krp &gt;&gt; LSGR

                                // Decode signed value (sign interleaved in LSB)
                                var value int16
                                if mag == 0 </span><span class="cov2" title="6">{
                                        value = 0
                                        // Update k (increase for zero)
                                        kp += UQ_GR
                                        if kp &gt; KPMAX </span><span class="cov0" title="0">{
                                                kp = KPMAX
                                        }</span>
                                        <span class="cov2" title="6">k = kp &gt;&gt; LSGR</span>
                                } else<span class="cov2" title="10"> {
                                        // Sign is LSB of magnitude
                                        if (mag &amp; 1) != 0 </span><span class="cov2" title="8">{
                                                value = -int16((mag + 1) &gt;&gt; 1)
                                        }</span> else<span class="cov1" title="2"> {
                                                value = int16(mag &gt;&gt; 1)
                                        }</span>
                                        // Update k (decrease for non-zero)
                                        <span class="cov2" title="10">if kp &gt;= DQ_GR </span><span class="cov1" title="2">{
                                                kp -= DQ_GR
                                        }</span> else<span class="cov2" title="8"> {
                                                kp = 0
                                        }</span>
                                        <span class="cov2" title="10">k = kp &gt;&gt; LSGR</span>
                                }

                                <span class="cov3" title="16">output[idx] = value
                                idx++</span>

                        } else<span class="cov2" title="6"> {
                                // RLGR3: Paired value coding
                                nIdx := bs.CountLeadingOnes()

                                code := uint32(0)
                                if kr &gt; 0 &amp;&amp; bs.RemainingBits() &gt;= int(kr) </span><span class="cov0" title="0">{
                                        code = bs.ReadBits(int(kr))
                                }</span>
                                <span class="cov2" title="6">code |= uint32(nIdx) &lt;&lt; kr

                                // Update kr
                                if nIdx == 0 </span><span class="cov2" title="4">{
                                        if krp &gt;= 2 </span><span class="cov2" title="4">{
                                                krp -= 2
                                        }</span> else<span class="cov0" title="0"> {
                                                krp = 0
                                        }</span>
                                } else<span class="cov1" title="2"> if nIdx &gt; 1 </span><span class="cov0" title="0">{
                                        krp += uint32(nIdx)
                                        if krp &gt; KPMAX </span><span class="cov0" title="0">{
                                                krp = KPMAX
                                        }</span>
                                }
                                <span class="cov2" title="6">kr = krp &gt;&gt; LSGR

                                // Split code into two values
                                // nIdx2 = number of bits needed to represent code
                                nIdx2 := 0
                                if code &gt; 0 </span><span class="cov1" title="2">{
                                        temp := code
                                        for temp &gt; 0 </span><span class="cov1" title="2">{
                                                temp &gt;&gt;= 1
                                                nIdx2++
                                        }</span>
                                }

                                <span class="cov2" title="6">var val1, val2 uint32
                                if nIdx2 &gt; 0 &amp;&amp; bs.RemainingBits() &gt;= nIdx2 </span><span class="cov1" title="2">{
                                        val1 = bs.ReadBits(nIdx2)
                                }</span>
                                <span class="cov2" title="6">val2 = code - val1

                                // Update k based on values
                                if val1 != 0 &amp;&amp; val2 != 0 </span><span class="cov0" title="0">{
                                        if kp &gt;= 2*DQ_GR </span><span class="cov0" title="0">{
                                                kp -= 2 * DQ_GR
                                        }</span> else<span class="cov0" title="0"> {
                                                kp = 0
                                        }</span>
                                } else<span class="cov2" title="6"> if val1 == 0 &amp;&amp; val2 == 0 </span><span class="cov2" title="4">{
                                        kp += 2 * UQ_GR
                                        if kp &gt; KPMAX </span><span class="cov0" title="0">{
                                                kp = KPMAX
                                        }</span>
                                }
                                <span class="cov2" title="6">k = kp &gt;&gt; LSGR

                                // Decode and store first value
                                if val1 == 0 </span><span class="cov2" title="4">{
                                        output[idx] = 0
                                }</span> else<span class="cov1" title="2"> if (val1 &amp; 1) != 0 </span><span class="cov1" title="2">{
                                        output[idx] = -int16((val1 + 1) &gt;&gt; 1)
                                }</span> else<span class="cov0" title="0"> {
                                        output[idx] = int16(val1 &gt;&gt; 1)
                                }</span>
                                <span class="cov2" title="6">idx++

                                if idx &gt;= TilePixels </span><span class="cov0" title="0">{
                                        break</span>
                                }

                                // Decode and store second value
                                <span class="cov2" title="6">if val2 == 0 </span><span class="cov2" title="6">{
                                        output[idx] = 0
                                }</span> else<span class="cov0" title="0"> if (val2 &amp; 1) != 0 </span><span class="cov0" title="0">{
                                        output[idx] = -int16((val2 + 1) &gt;&gt; 1)
                                }</span> else<span class="cov0" title="0"> {
                                        output[idx] = int16(val2 &gt;&gt; 1)
                                }</span>
                                <span class="cov2" title="6">idx++</span>
                        }
                }
        }

        <span class="cov1" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package rfx

import (
        "encoding/binary"
)

// DecodeTile decodes a single RFX tile from compressed data.
// data: raw tile data starting with CBT_TILE block header
// quantY, quantCb, quantCr: quantization values for each component
func DecodeTile(data []byte, quantY, quantCb, quantCr *SubbandQuant) (*Tile, error) <span class="cov10" title="5">{
        if len(data) &lt; 19 </span><span class="cov1" title="1">{ // Minimum tile header size
                return nil, ErrInvalidTileData
        }</span>

        <span class="cov8" title="4">offset := 0

        // Parse block header
        blockType := binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        if blockType != CBT_TILE </span><span class="cov1" title="1">{
                return nil, ErrInvalidBlockType
        }</span>

        <span class="cov7" title="3">blockLen := binary.LittleEndian.Uint32(data[offset:])
        offset += 4

        if int(blockLen) &gt; len(data) </span><span class="cov1" title="1">{
                return nil, ErrInvalidBlockLength
        }</span>

        // Parse tile header (MS-RDPRFX 2.2.4.4)
        // quantIdxY := data[offset]
        // quantIdxCb := data[offset+1]
        // quantIdxCr := data[offset+2]
        <span class="cov4" title="2">offset += 3

        xIdx := binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        yIdx := binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        // Component data sizes
        yLen := int(binary.LittleEndian.Uint16(data[offset:]))
        offset += 2

        cbLen := int(binary.LittleEndian.Uint16(data[offset:]))
        offset += 2

        crLen := int(binary.LittleEndian.Uint16(data[offset:]))
        offset += 2

        // Validate lengths
        if offset+yLen+cbLen+crLen &gt; len(data) </span><span class="cov1" title="1">{
                return nil, ErrInvalidTileData
        }</span>

        // Extract component data
        <span class="cov1" title="1">yData := data[offset : offset+yLen]
        offset += yLen

        cbData := data[offset : offset+cbLen]
        offset += cbLen

        crData := data[offset : offset+crLen]

        // Allocate coefficient buffers
        yCoeff := make([]int16, TilePixels)
        cbCoeff := make([]int16, TilePixels)
        crCoeff := make([]int16, TilePixels)

        // RLGR decode each component
        if err := RLGRDecode(yData, RLGR1, yCoeff); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if err := RLGRDecode(cbData, RLGR3, cbCoeff); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if err := RLGRDecode(crData, RLGR3, crCoeff); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Differential decode LL3 subband (DC coefficients)
        <span class="cov1" title="1">DifferentialDecode(yCoeff[OffsetLL3:], SizeL3)
        DifferentialDecode(cbCoeff[OffsetLL3:], SizeL3)
        DifferentialDecode(crCoeff[OffsetLL3:], SizeL3)

        // Dequantize
        Dequantize(yCoeff, quantY)
        Dequantize(cbCoeff, quantCb)
        Dequantize(crCoeff, quantCr)

        // Inverse DWT
        yPixels := InverseDWT2D(yCoeff)
        cbPixels := InverseDWT2D(cbCoeff)
        crPixels := InverseDWT2D(crCoeff)

        // Color convert to RGBA
        rgba := make([]byte, TileRGBASize)
        YCbCrToRGBA(yPixels, cbPixels, crPixels, rgba)

        return &amp;Tile{
                X:    xIdx,
                Y:    yIdx,
                RGBA: rgba,
        }, nil</span>
}

// DecodeTileWithBuffers decodes a tile using pre-allocated buffers (for WASM).
// This avoids allocations in the hot path.
func DecodeTileWithBuffers(
        data []byte,
        quantY, quantCb, quantCr *SubbandQuant,
        yCoeff, cbCoeff, crCoeff []int16,
        rgba []byte,
) (xIdx, yIdx uint16, err error) <span class="cov10" title="5">{
        if len(data) &lt; 19 </span><span class="cov1" title="1">{
                return 0, 0, ErrInvalidTileData
        }</span>

        <span class="cov8" title="4">offset := 0

        // Parse block header
        blockType := binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        if blockType != CBT_TILE </span><span class="cov1" title="1">{
                return 0, 0, ErrInvalidBlockType
        }</span>

        <span class="cov7" title="3">blockLen := binary.LittleEndian.Uint32(data[offset:])
        offset += 4

        if int(blockLen) &gt; len(data) </span><span class="cov1" title="1">{
                return 0, 0, ErrInvalidBlockLength
        }</span>

        // Skip quant indices
        <span class="cov4" title="2">offset += 3

        xIdx = binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        yIdx = binary.LittleEndian.Uint16(data[offset:])
        offset += 2

        yLen := int(binary.LittleEndian.Uint16(data[offset:]))
        offset += 2

        cbLen := int(binary.LittleEndian.Uint16(data[offset:]))
        offset += 2

        crLen := int(binary.LittleEndian.Uint16(data[offset:]))
        offset += 2

        if offset+yLen+cbLen+crLen &gt; len(data) </span><span class="cov1" title="1">{
                return 0, 0, ErrInvalidTileData
        }</span>

        // RLGR decode
        <span class="cov1" title="1">if err := RLGRDecode(data[offset:offset+yLen], RLGR1, yCoeff); err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        <span class="cov1" title="1">offset += yLen

        if err := RLGRDecode(data[offset:offset+cbLen], RLGR3, cbCoeff); err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        <span class="cov1" title="1">offset += cbLen

        if err := RLGRDecode(data[offset:offset+crLen], RLGR3, crCoeff); err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        // Differential decode LL3 subband (DC coefficients)
        <span class="cov1" title="1">DifferentialDecode(yCoeff[OffsetLL3:], SizeL3)
        DifferentialDecode(cbCoeff[OffsetLL3:], SizeL3)
        DifferentialDecode(crCoeff[OffsetLL3:], SizeL3)

        // Dequantize
        Dequantize(yCoeff, quantY)
        Dequantize(cbCoeff, quantCb)
        Dequantize(crCoeff, quantCr)

        // Inverse DWT
        yPixels := InverseDWT2D(yCoeff)
        cbPixels := InverseDWT2D(cbCoeff)
        crPixels := InverseDWT2D(crCoeff)

        // Color convert
        YCbCrToRGBA(yPixels, cbPixels, crPixels, rgba)

        return xIdx, yIdx, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package rfx

// YCbCr to RGB conversion using ICT (Irreversible Color Transform).
// This is the inverse of the color transform used in JPEG 2000 and RemoteFX.
//
// MS-RDPRFX uses 11.5 fixed-point format:
// - Coefficients from DWT are already in 11.5 format (1 sign + 10 integer + 5 fractional)
// - Y requires a DC level shift of +4096 (which is 128 in 11.5 format: 128 &lt;&lt; 5)
//
// ICT inverse transform (floating-point reference):
//
//        R = Y + 1.402525*Cr
//        G = Y - 0.343730*Cb - 0.714401*Cr
//        B = Y + 1.769905*Cb
//
// Fixed-point implementation follows FreeRDP prim_colors.c
// Using divisor=16 means we scale coefficients by 65536 and shift right by 16+5=21

// Fixed-point coefficients (scaled by 65536 with divisor=16)
const (
        // Level shift for Y: 128 in 11.5 format
        YLevelShift int32 = 4096 // 128 &lt;&lt; 5

        // Fixed-point divisor (we use 16, so shift = 16+5 = 21)
        fpDivisor = 16
        fpShift   = fpDivisor + 5 // Total shift for final result

        // Coefficients scaled by 65536 (1 &lt;&lt; 16)
        // R = Y + 1.402525*Cr
        CrToR int32 = 91916 // 1.402525 * 65536

        // G = Y - 0.343730*Cb - 0.714401*Cr
        CbToG int32 = 22527 // 0.343730 * 65536
        CrToG int32 = 46819 // 0.714401 * 65536

        // B = Y + 1.769905*Cb
        CbToB int32 = 115992 // 1.769905 * 65536

        // Rounding offset for fixed-point division
        fpRound int32 = 1 &lt;&lt; (fpShift - 1) // 1 &lt;&lt; 20 = 1048576
)

// YCbCrToRGBA converts YCbCr tile data to RGBA.
// y, cb, cr: int16 arrays of length TilePixels (4096) in 11.5 fixed-point format
// output: byte array of length TilePixels*4 (16384)
func YCbCrToRGBA(y, cb, cr []int16, output []byte) <span class="cov2" title="9">{
        if len(y) &lt; TilePixels || len(cb) &lt; TilePixels || len(cr) &lt; TilePixels </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov2" title="8">if len(output) &lt; TileRGBASize </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="8">for i := 0; i &lt; TilePixels; i++ </span><span class="cov9" title="32768">{
                // Get YCbCr values and scale Y by divisor (shift left by fpDivisor)
                // Y also needs DC level shift of +4096 (128 in 11.5 format)
                yVal := (int32(y[i]) + YLevelShift) &lt;&lt; fpDivisor
                cbVal := int32(cb[i])
                crVal := int32(cr[i])

                // ICT inverse transform with fixed-point arithmetic
                // R = Y + 1.402525*Cr
                r := (yVal + CrToR*crVal + fpRound) &gt;&gt; fpShift

                // G = Y - 0.343730*Cb - 0.714401*Cr
                g := (yVal - CbToG*cbVal - CrToG*crVal + fpRound) &gt;&gt; fpShift

                // B = Y + 1.769905*Cb
                b := (yVal + CbToB*cbVal + fpRound) &gt;&gt; fpShift

                // Clamp to [0, 255] and store as RGBA
                outIdx := i * 4
                output[outIdx+0] = clampToByte(r)
                output[outIdx+1] = clampToByte(g)
                output[outIdx+2] = clampToByte(b)
                output[outIdx+3] = 255 // Alpha = fully opaque
        }</span>
}

// clampToByte clamps an int32 to [0, 255]
func clampToByte(v int32) byte <span class="cov10" title="98311">{
        if v &lt; 0 </span><span class="cov8" title="8194">{
                return 0
        }</span>
        <span class="cov9" title="90117">if v &gt; 255 </span><span class="cov1" title="2">{
                return 255
        }</span>
        <span class="cov9" title="90115">return byte(v)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package codec

// RLE decompression for 15-bit color depth
// 15-bit uses same RLE format as 16-bit (2 bytes per pixel)
// The pixel format is RGB555 instead of RGB565

// RLEDecompress15 decompresses 15-bit RLE compressed bitmap data
// Uses same algorithm as 16-bit since pixel size is 2 bytes
func RLEDecompress15(src []byte, dest []byte, rowDelta int) bool <span class="cov0" title="0">{
        // 15-bit uses exact same RLE format as 16-bit
        return RLEDecompress16(src, dest, rowDelta)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package codec

// ReadPixel16 reads a 16-bit pixel from the buffer
func ReadPixel16(data []byte, idx int) uint16 <span class="cov1" title="1">{
        if idx+1 &gt;= len(data) </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov1" title="1">return uint16(data[idx]) | (uint16(data[idx+1]) &lt;&lt; 8)</span>
}

// WritePixel16 writes a 16-bit pixel to the buffer
func WritePixel16(data []byte, idx int, pixel uint16) <span class="cov10" title="5">{
        if idx+1 &gt;= len(data) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="5">data[idx] = byte(pixel &amp; 0xFF)
        data[idx+1] = byte((pixel &gt;&gt; 8) &amp; 0xFF)</span>
}

// WriteFgBgImage16 writes a foreground/background image for 16-bit color
func WriteFgBgImage16(dest []byte, destIdx int, rowDelta int, bitmask byte, fgPel uint16, cBits int, firstLine bool) int <span class="cov0" title="0">{
        for i := 0; i &lt; cBits &amp;&amp; i &lt; 8; i++ </span><span class="cov0" title="0">{
                if destIdx+1 &gt;= len(dest) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if firstLine </span><span class="cov0" title="0">{
                        if bitmask&amp;FgBgBitmasks[i] != 0 </span><span class="cov0" title="0">{
                                WritePixel16(dest, destIdx, fgPel)
                        }</span> else<span class="cov0" title="0"> {
                                WritePixel16(dest, destIdx, 0)
                        }</span>
                } else<span class="cov0" title="0"> {
                        xorPixel := ReadPixel16(dest, destIdx-rowDelta)
                        if bitmask&amp;FgBgBitmasks[i] != 0 </span><span class="cov0" title="0">{
                                WritePixel16(dest, destIdx, xorPixel^fgPel)
                        }</span> else<span class="cov0" title="0"> {
                                WritePixel16(dest, destIdx, xorPixel)
                        }</span>
                }
                <span class="cov0" title="0">destIdx += 2</span>
        }
        <span class="cov0" title="0">return destIdx</span>
}

// RLEDecompress16 decompresses 16-bit RLE compressed bitmap data
func RLEDecompress16(src []byte, dest []byte, rowDelta int) bool <span class="cov4" title="2">{
        srcIdx := 0
        destIdx := 0
        var fgPel uint16 = 0xFFFF // white
        fInsertFgPel := false
        fFirstLine := true

        for srcIdx &lt; len(src) &amp;&amp; destIdx &lt; len(dest) </span><span class="cov1" title="1">{
                // Check for end of first scanline
                if fFirstLine &amp;&amp; destIdx &gt;= rowDelta </span><span class="cov0" title="0">{
                        fFirstLine = false
                        fInsertFgPel = false
                }</span>

                <span class="cov1" title="1">code := ExtractCodeID(src[srcIdx])

                // Background Run Orders
                if code == RegularBgRun || code == MegaMegaBgRun </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        if fFirstLine </span><span class="cov0" title="0">{
                                if fInsertFgPel </span><span class="cov0" title="0">{
                                        WritePixel16(dest, destIdx, fgPel)
                                        destIdx += 2
                                        runLength--
                                }</span>
                                <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov0" title="0">{
                                        WritePixel16(dest, destIdx, 0)
                                        destIdx += 2
                                        runLength--
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if fInsertFgPel </span><span class="cov0" title="0">{
                                        prevPel := ReadPixel16(dest, destIdx-rowDelta)
                                        WritePixel16(dest, destIdx, prevPel^fgPel)
                                        destIdx += 2
                                        runLength--
                                }</span>
                                <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov0" title="0">{
                                        prevPel := ReadPixel16(dest, destIdx-rowDelta)
                                        WritePixel16(dest, destIdx, prevPel)
                                        destIdx += 2
                                        runLength--
                                }</span>
                        }
                        <span class="cov0" title="0">fInsertFgPel = true
                        continue</span>
                }

                <span class="cov1" title="1">fInsertFgPel = false

                // Foreground Run Orders
                if code == RegularFgRun || code == MegaMegaFgRun ||
                        code == LiteSetFgFgRun || code == MegaMegaSetFgRun </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        if code == LiteSetFgFgRun || code == MegaMegaSetFgRun </span><span class="cov0" title="0">{
                                fgPel = ReadPixel16(src, srcIdx)
                                srcIdx += 2
                        }</span>

                        <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov0" title="0">{
                                if fFirstLine </span><span class="cov0" title="0">{
                                        WritePixel16(dest, destIdx, fgPel)
                                }</span> else<span class="cov0" title="0"> {
                                        prevPel := ReadPixel16(dest, destIdx-rowDelta)
                                        WritePixel16(dest, destIdx, prevPel^fgPel)
                                }</span>
                                <span class="cov0" title="0">destIdx += 2
                                runLength--</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Dithered Run Orders
                <span class="cov1" title="1">if code == LiteDitheredRun || code == MegaMegaDitheredRun </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        pixelA := ReadPixel16(src, srcIdx)
                        srcIdx += 2
                        pixelB := ReadPixel16(src, srcIdx)
                        srcIdx += 2

                        for runLength &gt; 0 &amp;&amp; destIdx+4 &lt;= len(dest) </span><span class="cov0" title="0">{
                                WritePixel16(dest, destIdx, pixelA)
                                destIdx += 2
                                WritePixel16(dest, destIdx, pixelB)
                                destIdx += 2
                                runLength--
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Color Run Orders
                <span class="cov1" title="1">if code == RegularColorRun || code == MegaMegaColorRun </span><span class="cov1" title="1">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        pixel := ReadPixel16(src, srcIdx)
                        srcIdx += 2

                        for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov10" title="5">{
                                WritePixel16(dest, destIdx, pixel)
                                destIdx += 2
                                runLength--
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }

                // Color Image Orders
                <span class="cov0" title="0">if code == RegularColorImage || code == MegaMegaColorImage </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) &amp;&amp; srcIdx+2 &lt;= len(src) </span><span class="cov0" title="0">{
                                pixel := ReadPixel16(src, srcIdx)
                                srcIdx += 2
                                WritePixel16(dest, destIdx, pixel)
                                destIdx += 2
                                runLength--
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Foreground/Background Image Orders
                <span class="cov0" title="0">if code == RegularFgBgImage || code == MegaMegaFgBgImage ||
                        code == LiteSetFgFgBgImage || code == MegaMegaSetFgBgImage </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        if code == LiteSetFgFgBgImage || code == MegaMegaSetFgBgImage </span><span class="cov0" title="0">{
                                fgPel = ReadPixel16(src, srcIdx)
                                srcIdx += 2
                        }</span>

                        <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; srcIdx &lt; len(src) </span><span class="cov0" title="0">{
                                bitmask := src[srcIdx]
                                srcIdx++
                                cBits := 8
                                if runLength &lt; 8 </span><span class="cov0" title="0">{
                                        cBits = runLength
                                }</span>
                                <span class="cov0" title="0">destIdx = WriteFgBgImage16(dest, destIdx, rowDelta, bitmask, fgPel, cBits, fFirstLine)
                                runLength -= cBits</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Special Orders
                <span class="cov0" title="0">if code == SpecialFgBg1 </span><span class="cov0" title="0">{
                        bitmask := byte(maskSpecialFgBg1)
                        destIdx = WriteFgBgImage16(dest, destIdx, rowDelta, bitmask, fgPel, 8, fFirstLine)
                        srcIdx++
                        continue</span>
                }

                <span class="cov0" title="0">if code == SpecialFgBg2 </span><span class="cov0" title="0">{
                        bitmask := byte(maskSpecialFgBg2)
                        destIdx = WriteFgBgImage16(dest, destIdx, rowDelta, bitmask, fgPel, 8, fFirstLine)
                        srcIdx++
                        continue</span>
                }

                // White/Black Orders
                <span class="cov0" title="0">if code == White </span><span class="cov0" title="0">{
                        WritePixel16(dest, destIdx, 0xFFFF)
                        destIdx += 2
                        srcIdx++
                        continue</span>
                }

                <span class="cov0" title="0">if code == Black </span><span class="cov0" title="0">{
                        WritePixel16(dest, destIdx, 0x0000)
                        destIdx += 2
                        srcIdx++
                        continue</span>
                }

                // Unknown code, skip
                <span class="cov0" title="0">srcIdx++</span>
        }

        <span class="cov4" title="2">return true</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package codec

// ReadPixel24 reads a 24-bit pixel from the buffer
func ReadPixel24(data []byte, idx int) uint32 <span class="cov1" title="1">{
        if idx+2 &gt;= len(data) </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov1" title="1">return uint32(data[idx]) | (uint32(data[idx+1]) &lt;&lt; 8) | (uint32(data[idx+2]) &lt;&lt; 16)</span>
}

// WritePixel24 writes a 24-bit pixel to the buffer
func WritePixel24(data []byte, idx int, pixel uint32) <span class="cov10" title="5">{
        if idx+2 &gt;= len(data) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="5">data[idx] = byte(pixel &amp; 0xFF)
        data[idx+1] = byte((pixel &gt;&gt; 8) &amp; 0xFF)
        data[idx+2] = byte((pixel &gt;&gt; 16) &amp; 0xFF)</span>
}

// WriteFgBgImage24 writes a foreground/background image for 24-bit color
func WriteFgBgImage24(dest []byte, destIdx int, rowDelta int, bitmask byte, fgPel uint32, cBits int, firstLine bool) int <span class="cov0" title="0">{
        for i := 0; i &lt; cBits &amp;&amp; i &lt; 8; i++ </span><span class="cov0" title="0">{
                if destIdx+2 &gt;= len(dest) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if firstLine </span><span class="cov0" title="0">{
                        if bitmask&amp;FgBgBitmasks[i] != 0 </span><span class="cov0" title="0">{
                                WritePixel24(dest, destIdx, fgPel)
                        }</span> else<span class="cov0" title="0"> {
                                WritePixel24(dest, destIdx, 0)
                        }</span>
                } else<span class="cov0" title="0"> {
                        xorPixel := ReadPixel24(dest, destIdx-rowDelta)
                        if bitmask&amp;FgBgBitmasks[i] != 0 </span><span class="cov0" title="0">{
                                WritePixel24(dest, destIdx, xorPixel^fgPel)
                        }</span> else<span class="cov0" title="0"> {
                                WritePixel24(dest, destIdx, xorPixel)
                        }</span>
                }
                <span class="cov0" title="0">destIdx += 3</span>
        }
        <span class="cov0" title="0">return destIdx</span>
}

// RLEDecompress24 decompresses 24-bit RLE compressed bitmap data
func RLEDecompress24(src []byte, dest []byte, rowDelta int) bool <span class="cov1" title="1">{
        srcIdx := 0
        destIdx := 0
        var fgPel uint32 = 0xFFFFFF // white
        fInsertFgPel := false
        fFirstLine := true

        for srcIdx &lt; len(src) &amp;&amp; destIdx &lt; len(dest) </span><span class="cov1" title="1">{
                // Check for end of first scanline
                if fFirstLine &amp;&amp; destIdx &gt;= rowDelta </span><span class="cov0" title="0">{
                        fFirstLine = false
                        fInsertFgPel = false
                }</span>

                <span class="cov1" title="1">code := ExtractCodeID(src[srcIdx])

                // Background Run Orders
                if code == RegularBgRun || code == MegaMegaBgRun </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        if fFirstLine </span><span class="cov0" title="0">{
                                if fInsertFgPel </span><span class="cov0" title="0">{
                                        WritePixel24(dest, destIdx, fgPel)
                                        destIdx += 3
                                        runLength--
                                }</span>
                                <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov0" title="0">{
                                        WritePixel24(dest, destIdx, 0)
                                        destIdx += 3
                                        runLength--
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if fInsertFgPel </span><span class="cov0" title="0">{
                                        prevPel := ReadPixel24(dest, destIdx-rowDelta)
                                        WritePixel24(dest, destIdx, prevPel^fgPel)
                                        destIdx += 3
                                        runLength--
                                }</span>
                                <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov0" title="0">{
                                        prevPel := ReadPixel24(dest, destIdx-rowDelta)
                                        WritePixel24(dest, destIdx, prevPel)
                                        destIdx += 3
                                        runLength--
                                }</span>
                        }
                        <span class="cov0" title="0">fInsertFgPel = true
                        continue</span>
                }

                <span class="cov1" title="1">fInsertFgPel = false

                // Foreground Run Orders
                if code == RegularFgRun || code == MegaMegaFgRun ||
                        code == LiteSetFgFgRun || code == MegaMegaSetFgRun </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        if code == LiteSetFgFgRun || code == MegaMegaSetFgRun </span><span class="cov0" title="0">{
                                fgPel = ReadPixel24(src, srcIdx)
                                srcIdx += 3
                        }</span>

                        <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov0" title="0">{
                                if fFirstLine </span><span class="cov0" title="0">{
                                        WritePixel24(dest, destIdx, fgPel)
                                }</span> else<span class="cov0" title="0"> {
                                        prevPel := ReadPixel24(dest, destIdx-rowDelta)
                                        WritePixel24(dest, destIdx, prevPel^fgPel)
                                }</span>
                                <span class="cov0" title="0">destIdx += 3
                                runLength--</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Dithered Run Orders
                <span class="cov1" title="1">if code == LiteDitheredRun || code == MegaMegaDitheredRun </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        pixelA := ReadPixel24(src, srcIdx)
                        srcIdx += 3
                        pixelB := ReadPixel24(src, srcIdx)
                        srcIdx += 3

                        for runLength &gt; 0 &amp;&amp; destIdx+6 &lt;= len(dest) </span><span class="cov0" title="0">{
                                WritePixel24(dest, destIdx, pixelA)
                                destIdx += 3
                                WritePixel24(dest, destIdx, pixelB)
                                destIdx += 3
                                runLength--
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Color Run Orders
                <span class="cov1" title="1">if code == RegularColorRun || code == MegaMegaColorRun </span><span class="cov1" title="1">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        pixel := ReadPixel24(src, srcIdx)
                        srcIdx += 3

                        for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov10" title="5">{
                                WritePixel24(dest, destIdx, pixel)
                                destIdx += 3
                                runLength--
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }

                // Color Image Orders
                <span class="cov0" title="0">if code == RegularColorImage || code == MegaMegaColorImage </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) &amp;&amp; srcIdx+3 &lt;= len(src) </span><span class="cov0" title="0">{
                                pixel := ReadPixel24(src, srcIdx)
                                srcIdx += 3
                                WritePixel24(dest, destIdx, pixel)
                                destIdx += 3
                                runLength--
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Foreground/Background Image Orders
                <span class="cov0" title="0">if code == RegularFgBgImage || code == MegaMegaFgBgImage ||
                        code == LiteSetFgFgBgImage || code == MegaMegaSetFgBgImage </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        if code == LiteSetFgFgBgImage || code == MegaMegaSetFgBgImage </span><span class="cov0" title="0">{
                                fgPel = ReadPixel24(src, srcIdx)
                                srcIdx += 3
                        }</span>

                        <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; srcIdx &lt; len(src) </span><span class="cov0" title="0">{
                                bitmask := src[srcIdx]
                                srcIdx++
                                cBits := 8
                                if runLength &lt; 8 </span><span class="cov0" title="0">{
                                        cBits = runLength
                                }</span>
                                <span class="cov0" title="0">destIdx = WriteFgBgImage24(dest, destIdx, rowDelta, bitmask, fgPel, cBits, fFirstLine)
                                runLength -= cBits</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Special Orders
                <span class="cov0" title="0">if code == SpecialFgBg1 </span><span class="cov0" title="0">{
                        bitmask := byte(maskSpecialFgBg1)
                        destIdx = WriteFgBgImage24(dest, destIdx, rowDelta, bitmask, fgPel, 8, fFirstLine)
                        srcIdx++
                        continue</span>
                }

                <span class="cov0" title="0">if code == SpecialFgBg2 </span><span class="cov0" title="0">{
                        bitmask := byte(maskSpecialFgBg2)
                        destIdx = WriteFgBgImage24(dest, destIdx, rowDelta, bitmask, fgPel, 8, fFirstLine)
                        srcIdx++
                        continue</span>
                }

                // White/Black Orders
                <span class="cov0" title="0">if code == White </span><span class="cov0" title="0">{
                        WritePixel24(dest, destIdx, 0xFFFFFF)
                        destIdx += 3
                        srcIdx++
                        continue</span>
                }

                <span class="cov0" title="0">if code == Black </span><span class="cov0" title="0">{
                        WritePixel24(dest, destIdx, 0x000000)
                        destIdx += 3
                        srcIdx++
                        continue</span>
                }

                // Unknown code, skip
                <span class="cov0" title="0">srcIdx++</span>
        }

        <span class="cov1" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package codec

// ReadPixel32Src reads a 32-bit pixel from source buffer (3 bytes BGR, outputs with alpha)
func ReadPixel32Src(data []byte, idx int) uint32 <span class="cov1" title="1">{
        if idx+2 &gt;= len(data) </span><span class="cov0" title="0">{
                return 0xFF000000
        }</span>
        <span class="cov1" title="1">return uint32(data[idx]) | (uint32(data[idx+1]) &lt;&lt; 8) | (uint32(data[idx+2]) &lt;&lt; 16) | 0xFF000000</span>
}

// ReadPixel32Dest reads a 32-bit pixel from destination buffer (4 bytes)
func ReadPixel32Dest(data []byte, idx int) uint32 <span class="cov0" title="0">{
        if idx+3 &gt;= len(data) </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return uint32(data[idx]) | (uint32(data[idx+1]) &lt;&lt; 8) | (uint32(data[idx+2]) &lt;&lt; 16) | (uint32(data[idx+3]) &lt;&lt; 24)</span>
}

// WritePixel32 writes a 32-bit pixel to the buffer
func WritePixel32(data []byte, idx int, pixel uint32) <span class="cov10" title="5">{
        if idx+3 &gt;= len(data) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="5">data[idx] = byte(pixel &amp; 0xFF)
        data[idx+1] = byte((pixel &gt;&gt; 8) &amp; 0xFF)
        data[idx+2] = byte((pixel &gt;&gt; 16) &amp; 0xFF)
        data[idx+3] = byte((pixel &gt;&gt; 24) &amp; 0xFF)</span>
}

// WriteFgBgImage32 writes a foreground/background image for 32-bit color
func WriteFgBgImage32(dest []byte, destIdx int, rowDelta int, bitmask byte, fgPel uint32, cBits int, firstLine bool) int <span class="cov0" title="0">{
        for i := 0; i &lt; cBits &amp;&amp; i &lt; 8; i++ </span><span class="cov0" title="0">{
                if destIdx+3 &gt;= len(dest) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if firstLine </span><span class="cov0" title="0">{
                        if bitmask&amp;FgBgBitmasks[i] != 0 </span><span class="cov0" title="0">{
                                WritePixel32(dest, destIdx, fgPel)
                        }</span> else<span class="cov0" title="0"> {
                                WritePixel32(dest, destIdx, 0xFF000000) // black with alpha
                        }</span>
                } else<span class="cov0" title="0"> {
                        xorPixel := ReadPixel32Dest(dest, destIdx-rowDelta)
                        if bitmask&amp;FgBgBitmasks[i] != 0 </span><span class="cov0" title="0">{
                                WritePixel32(dest, destIdx, xorPixel^fgPel)
                        }</span> else<span class="cov0" title="0"> {
                                WritePixel32(dest, destIdx, xorPixel)
                        }</span>
                }
                <span class="cov0" title="0">destIdx += 4</span>
        }
        <span class="cov0" title="0">return destIdx</span>
}

// RLEDecompress32 decompresses 32-bit RLE compressed bitmap data.
// Per MS-RDPBCGR, 32-bit RLE stores pixels as 3 bytes (BGR) in compressed stream
// but outputs to 4 bytes per pixel (BGRX) buffer.
func RLEDecompress32(src []byte, dest []byte, rowDelta int) bool <span class="cov1" title="1">{
        srcIdx := 0
        destIdx := 0
        var fgPel uint32 = 0xFFFFFFFF // white with full alpha
        fInsertFgPel := false
        fFirstLine := true

        for srcIdx &lt; len(src) &amp;&amp; destIdx &lt; len(dest) </span><span class="cov1" title="1">{
                // Check for end of first scanline
                if fFirstLine &amp;&amp; destIdx &gt;= rowDelta </span><span class="cov0" title="0">{
                        fFirstLine = false
                        fInsertFgPel = false
                }</span>

                <span class="cov1" title="1">code := ExtractCodeID(src[srcIdx])

                // Background Run Orders
                if code == RegularBgRun || code == MegaMegaBgRun </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        if fFirstLine </span><span class="cov0" title="0">{
                                if fInsertFgPel </span><span class="cov0" title="0">{
                                        WritePixel32(dest, destIdx, fgPel)
                                        destIdx += 4
                                        runLength--
                                }</span>
                                <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov0" title="0">{
                                        WritePixel32(dest, destIdx, 0xFF000000) // black with alpha
                                        destIdx += 4
                                        runLength--
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if fInsertFgPel </span><span class="cov0" title="0">{
                                        prevPel := ReadPixel32Dest(dest, destIdx-rowDelta)
                                        WritePixel32(dest, destIdx, prevPel^fgPel)
                                        destIdx += 4
                                        runLength--
                                }</span>
                                <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov0" title="0">{
                                        prevPel := ReadPixel32Dest(dest, destIdx-rowDelta)
                                        WritePixel32(dest, destIdx, prevPel)
                                        destIdx += 4
                                        runLength--
                                }</span>
                        }
                        <span class="cov0" title="0">fInsertFgPel = true
                        continue</span>
                }

                <span class="cov1" title="1">fInsertFgPel = false

                // Foreground Run Orders
                if code == RegularFgRun || code == MegaMegaFgRun ||
                        code == LiteSetFgFgRun || code == MegaMegaSetFgRun </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        if code == LiteSetFgFgRun || code == MegaMegaSetFgRun </span><span class="cov0" title="0">{
                                fgPel = ReadPixel32Src(src, srcIdx) // Read 3 bytes from source
                                srcIdx += 3
                        }</span>

                        <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov0" title="0">{
                                if fFirstLine </span><span class="cov0" title="0">{
                                        WritePixel32(dest, destIdx, fgPel)
                                }</span> else<span class="cov0" title="0"> {
                                        prevPel := ReadPixel32Dest(dest, destIdx-rowDelta)
                                        WritePixel32(dest, destIdx, prevPel^fgPel)
                                }</span>
                                <span class="cov0" title="0">destIdx += 4
                                runLength--</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Dithered Run Orders
                <span class="cov1" title="1">if code == LiteDitheredRun || code == MegaMegaDitheredRun </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        pixelA := ReadPixel32Src(src, srcIdx) // Read 3 bytes
                        srcIdx += 3
                        pixelB := ReadPixel32Src(src, srcIdx) // Read 3 bytes
                        srcIdx += 3

                        for runLength &gt; 0 &amp;&amp; destIdx+8 &lt;= len(dest) </span><span class="cov0" title="0">{
                                WritePixel32(dest, destIdx, pixelA)
                                destIdx += 4
                                WritePixel32(dest, destIdx, pixelB)
                                destIdx += 4
                                runLength--
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Color Run Orders
                <span class="cov1" title="1">if code == RegularColorRun || code == MegaMegaColorRun </span><span class="cov1" title="1">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        pixel := ReadPixel32Src(src, srcIdx) // Read 3 bytes
                        srcIdx += 3

                        for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov10" title="5">{
                                WritePixel32(dest, destIdx, pixel)
                                destIdx += 4
                                runLength--
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }

                // Color Image Orders
                <span class="cov0" title="0">if code == RegularColorImage || code == MegaMegaColorImage </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) &amp;&amp; srcIdx+3 &lt;= len(src) </span><span class="cov0" title="0">{
                                pixel := ReadPixel32Src(src, srcIdx) // Read 3 bytes
                                srcIdx += 3
                                WritePixel32(dest, destIdx, pixel)
                                destIdx += 4
                                runLength--
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Foreground/Background Image Orders
                <span class="cov0" title="0">if code == RegularFgBgImage || code == MegaMegaFgBgImage ||
                        code == LiteSetFgFgBgImage || code == MegaMegaSetFgBgImage </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        if code == LiteSetFgFgBgImage || code == MegaMegaSetFgBgImage </span><span class="cov0" title="0">{
                                fgPel = ReadPixel32Src(src, srcIdx) // Read 3 bytes
                                srcIdx += 3
                        }</span>

                        <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; srcIdx &lt; len(src) </span><span class="cov0" title="0">{
                                bitmask := src[srcIdx]
                                srcIdx++
                                cBits := 8
                                if runLength &lt; 8 </span><span class="cov0" title="0">{
                                        cBits = runLength
                                }</span>
                                <span class="cov0" title="0">destIdx = WriteFgBgImage32(dest, destIdx, rowDelta, bitmask, fgPel, cBits, fFirstLine)
                                runLength -= cBits</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Special Orders
                <span class="cov0" title="0">if code == SpecialFgBg1 </span><span class="cov0" title="0">{
                        bitmask := byte(maskSpecialFgBg1)
                        destIdx = WriteFgBgImage32(dest, destIdx, rowDelta, bitmask, fgPel, 8, fFirstLine)
                        srcIdx++
                        continue</span>
                }

                <span class="cov0" title="0">if code == SpecialFgBg2 </span><span class="cov0" title="0">{
                        bitmask := byte(maskSpecialFgBg2)
                        destIdx = WriteFgBgImage32(dest, destIdx, rowDelta, bitmask, fgPel, 8, fFirstLine)
                        srcIdx++
                        continue</span>
                }

                // White/Black Orders
                <span class="cov0" title="0">if code == White </span><span class="cov0" title="0">{
                        WritePixel32(dest, destIdx, 0xFFFFFFFF)
                        destIdx += 4
                        srcIdx++
                        continue</span>
                }

                <span class="cov0" title="0">if code == Black </span><span class="cov0" title="0">{
                        WritePixel32(dest, destIdx, 0xFF000000)
                        destIdx += 4
                        srcIdx++
                        continue</span>
                }

                // Unknown code, skip
                <span class="cov0" title="0">srcIdx++</span>
        }

        <span class="cov1" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package codec

// RLE decompression for 8-bit color depth

// WriteFgBgImage8 writes a foreground/background image for 8-bit color
func WriteFgBgImage8(dest []byte, destIdx int, rowDelta int, bitmask byte, fgPel byte, cBits int, firstLine bool) int <span class="cov4" title="3">{
        for i := 0; i &lt; cBits &amp;&amp; i &lt; 8; i++ </span><span class="cov10" title="16">{
                if destIdx &gt;= len(dest) </span><span class="cov1" title="1">{
                        break</span>
                }
                <span class="cov9" title="15">if firstLine </span><span class="cov8" title="11">{
                        if bitmask&amp;FgBgBitmasks[i] != 0 </span><span class="cov7" title="7">{
                                dest[destIdx] = fgPel
                        }</span> else<span class="cov5" title="4"> {
                                dest[destIdx] = 0
                        }</span>
                } else<span class="cov5" title="4"> {
                        xorPixel := dest[destIdx-rowDelta]
                        if bitmask&amp;FgBgBitmasks[i] != 0 </span><span class="cov5" title="4">{
                                dest[destIdx] = xorPixel ^ fgPel
                        }</span> else<span class="cov0" title="0"> {
                                dest[destIdx] = xorPixel
                        }</span>
                }
                <span class="cov9" title="15">destIdx++</span>
        }
        <span class="cov4" title="3">return destIdx</span>
}

// RLEDecompress8 decompresses 8-bit RLE compressed bitmap data
func RLEDecompress8(src []byte, dest []byte, rowDelta int) bool <span class="cov5" title="4">{
        srcIdx := 0
        destIdx := 0
        var fgPel byte = 0xFF // white
        fInsertFgPel := false
        fFirstLine := true

        for srcIdx &lt; len(src) &amp;&amp; destIdx &lt; len(dest) </span><span class="cov6" title="5">{
                // Check for end of first scanline
                if fFirstLine &amp;&amp; destIdx &gt;= rowDelta </span><span class="cov0" title="0">{
                        fFirstLine = false
                        fInsertFgPel = false
                }</span>

                <span class="cov6" title="5">code := ExtractCodeID(src[srcIdx])

                // Background Run Orders
                if code == RegularBgRun || code == MegaMegaBgRun </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        if fFirstLine </span><span class="cov0" title="0">{
                                if fInsertFgPel </span><span class="cov0" title="0">{
                                        dest[destIdx] = fgPel
                                        destIdx++
                                        runLength--
                                }</span>
                                <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov0" title="0">{
                                        dest[destIdx] = 0
                                        destIdx++
                                        runLength--
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if fInsertFgPel </span><span class="cov0" title="0">{
                                        dest[destIdx] = dest[destIdx-rowDelta] ^ fgPel
                                        destIdx++
                                        runLength--
                                }</span>
                                <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov0" title="0">{
                                        dest[destIdx] = dest[destIdx-rowDelta]
                                        destIdx++
                                        runLength--
                                }</span>
                        }
                        <span class="cov0" title="0">fInsertFgPel = true
                        continue</span>
                }

                <span class="cov6" title="5">fInsertFgPel = false

                // Foreground Run Orders
                if code == RegularFgRun || code == MegaMegaFgRun ||
                        code == LiteSetFgFgRun || code == MegaMegaSetFgRun </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        if code == LiteSetFgFgRun || code == MegaMegaSetFgRun </span><span class="cov0" title="0">{
                                if srcIdx &lt; len(src) </span><span class="cov0" title="0">{
                                        fgPel = src[srcIdx]
                                        srcIdx++
                                }</span>
                        }

                        <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov0" title="0">{
                                if fFirstLine </span><span class="cov0" title="0">{
                                        dest[destIdx] = fgPel
                                }</span> else<span class="cov0" title="0"> {
                                        dest[destIdx] = dest[destIdx-rowDelta] ^ fgPel
                                }</span>
                                <span class="cov0" title="0">destIdx++
                                runLength--</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Dithered Run Orders
                <span class="cov6" title="5">if code == LiteDitheredRun || code == MegaMegaDitheredRun </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        var pixelA, pixelB byte
                        if srcIdx &lt; len(src) </span><span class="cov0" title="0">{
                                pixelA = src[srcIdx]
                                srcIdx++
                        }</span>
                        <span class="cov0" title="0">if srcIdx &lt; len(src) </span><span class="cov0" title="0">{
                                pixelB = src[srcIdx]
                                srcIdx++
                        }</span>

                        <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; destIdx+1 &lt; len(dest) </span><span class="cov0" title="0">{
                                dest[destIdx] = pixelA
                                destIdx++
                                dest[destIdx] = pixelB
                                destIdx++
                                runLength--
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Color Run Orders
                <span class="cov6" title="5">if code == RegularColorRun || code == MegaMegaColorRun </span><span class="cov1" title="1">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        var pixel byte
                        if srcIdx &lt; len(src) </span><span class="cov1" title="1">{
                                pixel = src[srcIdx]
                                srcIdx++
                        }</span>

                        <span class="cov1" title="1">for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) </span><span class="cov5" title="4">{
                                dest[destIdx] = pixel
                                destIdx++
                                runLength--
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }

                // Color Image Orders
                <span class="cov5" title="4">if code == RegularColorImage || code == MegaMegaColorImage </span><span class="cov1" title="1">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        for runLength &gt; 0 &amp;&amp; destIdx &lt; len(dest) &amp;&amp; srcIdx &lt; len(src) </span><span class="cov5" title="4">{
                                dest[destIdx] = src[srcIdx]
                                srcIdx++
                                destIdx++
                                runLength--
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }

                // Foreground/Background Image Orders
                <span class="cov4" title="3">if code == RegularFgBgImage || code == MegaMegaFgBgImage ||
                        code == LiteSetFgFgBgImage || code == MegaMegaSetFgBgImage </span><span class="cov0" title="0">{
                        runLength, nextIdx := ExtractRunLength(code, src, srcIdx)
                        srcIdx = nextIdx

                        if code == LiteSetFgFgBgImage || code == MegaMegaSetFgBgImage </span><span class="cov0" title="0">{
                                if srcIdx &lt; len(src) </span><span class="cov0" title="0">{
                                        fgPel = src[srcIdx]
                                        srcIdx++
                                }</span>
                        }

                        <span class="cov0" title="0">for runLength &gt; 0 &amp;&amp; srcIdx &lt; len(src) </span><span class="cov0" title="0">{
                                bitmask := src[srcIdx]
                                srcIdx++
                                cBits := 8
                                if runLength &lt; 8 </span><span class="cov0" title="0">{
                                        cBits = runLength
                                }</span>
                                <span class="cov0" title="0">destIdx = WriteFgBgImage8(dest, destIdx, rowDelta, bitmask, fgPel, cBits, fFirstLine)
                                runLength -= cBits</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Special Orders
                <span class="cov4" title="3">if code == SpecialFgBg1 </span><span class="cov0" title="0">{
                        bitmask := byte(maskSpecialFgBg1)
                        destIdx = WriteFgBgImage8(dest, destIdx, rowDelta, bitmask, fgPel, 8, fFirstLine)
                        srcIdx++
                        continue</span>
                }

                <span class="cov4" title="3">if code == SpecialFgBg2 </span><span class="cov0" title="0">{
                        bitmask := byte(maskSpecialFgBg2)
                        destIdx = WriteFgBgImage8(dest, destIdx, rowDelta, bitmask, fgPel, 8, fFirstLine)
                        srcIdx++
                        continue</span>
                }

                // White/Black Orders
                <span class="cov4" title="3">if code == White </span><span class="cov3" title="2">{
                        dest[destIdx] = 0xFF
                        destIdx++
                        srcIdx++
                        continue</span>
                }

                <span class="cov1" title="1">if code == Black </span><span class="cov1" title="1">{
                        dest[destIdx] = 0x00
                        destIdx++
                        srcIdx++
                        continue</span>
                }

                // Unknown code, skip
                <span class="cov0" title="0">srcIdx++</span>
        }

        <span class="cov5" title="4">return true</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package codec implements RLE decompression for RDP bitmap data.
// This implements the Interleaved RLE algorithm as specified in MS-RDPBCGR section 2.2.9.1.1.3.1.2.4.
package codec

// RLE compression order codes
const (
        RegularBgRun         = 0x0
        RegularFgRun         = 0x1
        RegularFgBgImage     = 0x2
        RegularColorRun      = 0x3
        RegularColorImage    = 0x4
        MegaMegaBgRun        = 0xF0
        MegaMegaFgRun        = 0xF1
        MegaMegaFgBgImage    = 0xF2
        MegaMegaColorRun     = 0xF3
        MegaMegaColorImage   = 0xF4
        MegaMegaSetFgRun     = 0xF6
        MegaMegaSetFgBgImage = 0xF7
        MegaMegaDitheredRun  = 0xF8
        LiteSetFgFgRun       = 0xC
        LiteSetFgFgBgImage   = 0xD
        LiteDitheredRun      = 0xE
        SpecialFgBg1         = 0xF9
        SpecialFgBg2         = 0xFA
        White                = 0xFD
        Black                = 0xFE
)

const (
        maskRegularRunLength = 0x1F
        maskLiteRunLength    = 0x0F
        maskSpecialFgBg1     = 0x03
        maskSpecialFgBg2     = 0x05
)

// ExtractCodeID extracts the order code from a header byte
func ExtractCodeID(bOrderHdr byte) uint <span class="cov10" title="26">{
        if (bOrderHdr &amp; 0xC0) != 0xC0 </span><span class="cov7" title="10">{
                return uint(bOrderHdr &gt;&gt; 5)
        }</span>
        <span class="cov8" title="16">if (bOrderHdr &amp; 0xF0) == 0xF0 </span><span class="cov8" title="13">{
                return uint(bOrderHdr)
        }</span>
        <span class="cov4" title="3">return uint(bOrderHdr &gt;&gt; 4)</span>
}

// IsRegularCode returns true if the code is a regular order code
func IsRegularCode(code uint) bool <span class="cov8" title="18">{
        switch code </span>{
        case RegularBgRun, RegularFgRun, RegularColorRun, RegularColorImage, RegularFgBgImage:<span class="cov7" title="12">
                return true</span>
        }
        <span class="cov5" title="6">return false</span>
}

// IsLiteCode returns true if the code is a lite order code
func IsLiteCode(code uint) bool <span class="cov6" title="8">{
        switch code </span>{
        case LiteSetFgFgRun, LiteDitheredRun, LiteSetFgFgBgImage:<span class="cov4" title="3">
                return true</span>
        }
        <span class="cov5" title="5">return false</span>
}

// IsMegaMegaCode returns true if the code is a mega-mega order code
func IsMegaMegaCode(code uint) bool <span class="cov8" title="14">{
        switch code </span>{
        case MegaMegaBgRun, MegaMegaFgRun, MegaMegaSetFgRun, MegaMegaDitheredRun,
                MegaMegaColorRun, MegaMegaFgBgImage, MegaMegaSetFgBgImage, MegaMegaColorImage:<span class="cov7" title="9">
                return true</span>
        }
        <span class="cov5" title="5">return false</span>
}

// ExtractRunLength extracts the run length from the source buffer at the given index
func ExtractRunLength(code uint, src []byte, idx int) (length int, nextIdx int) <span class="cov7" title="10">{
        // Bounds check helper
        safeGet := func(i int) byte </span><span class="cov8" title="13">{
                if i &lt; len(src) </span><span class="cov8" title="13">{
                        return src[i]
                }</span>
                <span class="cov0" title="0">return 0</span>
        }

        <span class="cov7" title="10">if code == RegularFgBgImage </span><span class="cov2" title="2">{
                length = int(safeGet(idx) &amp; maskRegularRunLength)
                if length == 0 </span><span class="cov1" title="1">{
                        return int(safeGet(idx+1)) + 1, idx + 2
                }</span>
                <span class="cov1" title="1">return length * 8, idx + 1</span>
        }

        <span class="cov6" title="8">if code == LiteSetFgFgBgImage </span><span class="cov0" title="0">{
                length = int(safeGet(idx) &amp; maskLiteRunLength)
                if length == 0 </span><span class="cov0" title="0">{
                        return int(safeGet(idx+1)) + 1, idx + 2
                }</span>
                <span class="cov0" title="0">return length * 8, idx + 1</span>
        }

        <span class="cov6" title="8">if IsRegularCode(code) </span><span class="cov6" title="7">{
                length = int(safeGet(idx) &amp; maskRegularRunLength)
                if length == 0 </span><span class="cov1" title="1">{
                        return int(safeGet(idx+1)) + 32, idx + 2
                }</span>
                <span class="cov5" title="6">return length, idx + 1</span>
        }

        <span class="cov1" title="1">if IsLiteCode(code) </span><span class="cov0" title="0">{
                length = int(safeGet(idx) &amp; maskLiteRunLength)
                if length == 0 </span><span class="cov0" title="0">{
                        return int(safeGet(idx+1)) + 16, idx + 2
                }</span>
                <span class="cov0" title="0">return length, idx + 1</span>
        }

        <span class="cov1" title="1">if IsMegaMegaCode(code) </span><span class="cov1" title="1">{
                length = int(safeGet(idx+1)) | (int(safeGet(idx+2)) &lt;&lt; 8)
                return length, idx + 3
        }</span>

        <span class="cov0" title="0">return 0, idx + 1</span>
}

// FgBgBitmasks is the bitmask table for foreground/background image orders
var FgBgBitmasks = []byte{0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80}
</pre>
		
		<pre class="file" id="file23" style="display: none">package codec

import (
        "bytes"
        "encoding/binary"
        "io"
)

func WrapSecurityFlag(flag uint16, data []byte) []byte <span class="cov1" title="1">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, flag)
        buf.Write([]byte{0x00, 0x00}) // flagsHi

        buf.Write(data)

        return buf.Bytes()
}</span>

func UnwrapSecurityFlag(wire io.Reader) (uint16, error) <span class="cov10" title="3">{
        var (
                flags   uint16
                flagsHi uint16
                err     error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;flags)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov6" title="2">err = binary.Read(wire, binary.LittleEndian, &amp;flagsHi)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov1" title="1">return flags, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"
)

// globalConfig stores the configuration loaded with command-line overrides
// This allows other packages to access the same configuration that was loaded by the server
var (
        globalConfig *Config
        configMutex  sync.Mutex
)

// Config holds the application configuration
type Config struct {
        Server   ServerConfig   `json:"server"`
        RDP      RDPConfig      `json:"rdp"`
        Security SecurityConfig `json:"security"`
        Logging  LoggingConfig  `json:"logging"`
}

// LoadOptions holds command-line override options
type LoadOptions struct {
        Host              string
        Port              string
        LogLevel          string
        ConfigFile        string
        SkipTLSValidation bool
        TLSServerName     string
        UseNLA            bool
        EnableRFX         *bool // nil = use env/default, non-nil = override
}

// ServerConfig holds server-specific configuration
type ServerConfig struct {
        Host         string        `json:"host" env:"SERVER_HOST" default:"0.0.0.0"`
        Port         string        `json:"port" env:"SERVER_PORT" default:"8080"`
        ReadTimeout  time.Duration `json:"readTimeout" env:"SERVER_READ_TIMEOUT" default:"30s"`
        WriteTimeout time.Duration `json:"writeTimeout" env:"SERVER_WRITE_TIMEOUT" default:"30s"`
        IdleTimeout  time.Duration `json:"idleTimeout" env:"SERVER_IDLE_TIMEOUT" default:"120s"`
}

// RDPConfig holds RDP-specific configuration
type RDPConfig struct {
        DefaultWidth  int           `json:"defaultWidth" env:"RDP_DEFAULT_WIDTH" default:"1024"`
        DefaultHeight int           `json:"defaultHeight" env:"RDP_DEFAULT_HEIGHT" default:"768"`
        MaxWidth      int           `json:"maxWidth" env:"RDP_MAX_WIDTH" default:"3840"`
        MaxHeight     int           `json:"maxHeight" env:"RDP_MAX_HEIGHT" default:"2160"`
        BufferSize    int           `json:"bufferSize" env:"RDP_BUFFER_SIZE" default:"65536"`
        Timeout       time.Duration `json:"timeout" env:"RDP_TIMEOUT" default:"10s"`
        EnableRFX     bool          `json:"enableRFX" env:"RDP_ENABLE_RFX" default:"true"`
}

// SecurityConfig holds security-related configuration
type SecurityConfig struct {
        AllowedOrigins     []string `json:"allowedOrigins" env:"ALLOWED_ORIGINS" default:""`
        MaxConnections     int      `json:"maxConnections" env:"MAX_CONNECTIONS" default:"100"`
        EnableRateLimit    bool     `json:"enableRateLimit" env:"ENABLE_RATE_LIMIT" default:"true"`
        RateLimitPerMinute int      `json:"rateLimitPerMinute" env:"RATE_LIMIT_PER_MINUTE" default:"60"`
        EnableTLS          bool     `json:"enableTLS" env:"ENABLE_TLS" default:"false"`
        TLSCertFile        string   `json:"tlsCertFile" env:"TLS_CERT_FILE" default:""`
        TLSKeyFile         string   `json:"tlsKeyFile" env:"TLS_KEY_FILE" default:""`
        MinTLSVersion      string   `json:"minTLSVersion" env:"MIN_TLS_VERSION" default:"1.2"`
        SkipTLSValidation  bool     `json:"skipTLSValidation" env:"SKIP_TLS_VALIDATION" default:"false"`
        TLSServerName      string   `json:"tlsServerName" env:"TLS_SERVER_NAME" default:""`
        UseNLA             bool     `json:"useNLA" env:"USE_NLA" default:"true"`
}

// LoggingConfig holds logging configuration
type LoggingConfig struct {
        Level        string `json:"level" env:"LOG_LEVEL" default:"info"`
        Format       string `json:"format" env:"LOG_FORMAT" default:"text"`
        EnableCaller bool   `json:"enableCaller" env:"LOG_ENABLE_CALLER" default:"false"`
        File         string `json:"file" env:"LOG_FILE" default:""`
}

// Load loads configuration from environment variables with defaults
func Load() (*Config, error) <span class="cov2" title="2">{
        return LoadWithOverrides(LoadOptions{})
}</span>

// LoadWithOverrides loads configuration with command-line overrides
func LoadWithOverrides(opts LoadOptions) (*Config, error) <span class="cov3" title="3">{
        config := &amp;Config{}

        // Server config
        config.Server.Host = getOverrideOrEnv(opts.Host, "SERVER_HOST", "0.0.0.0")
        config.Server.Port = getOverrideOrEnv(opts.Port, "SERVER_PORT", "8080")
        config.Server.ReadTimeout = getDurationWithDefault("SERVER_READ_TIMEOUT", 30*time.Second)
        config.Server.WriteTimeout = getDurationWithDefault("SERVER_WRITE_TIMEOUT", 30*time.Second)
        config.Server.IdleTimeout = getDurationWithDefault("SERVER_IDLE_TIMEOUT", 120*time.Second)

        // RDP config
        config.RDP.DefaultWidth = getIntWithDefault("RDP_DEFAULT_WIDTH", 1024)
        config.RDP.DefaultHeight = getIntWithDefault("RDP_DEFAULT_HEIGHT", 768)
        config.RDP.MaxWidth = getIntWithDefault("RDP_MAX_WIDTH", 3840)
        config.RDP.MaxHeight = getIntWithDefault("RDP_MAX_HEIGHT", 2160)
        config.RDP.BufferSize = getIntWithDefault("RDP_BUFFER_SIZE", 65536)
        config.RDP.Timeout = getDurationWithDefault("RDP_TIMEOUT", 10*time.Second)
        // RFX enabled by default; use --no-rfx or RDP_ENABLE_RFX=false to disable
        if opts.EnableRFX != nil </span><span class="cov0" title="0">{
                config.RDP.EnableRFX = *opts.EnableRFX
        }</span> else<span class="cov3" title="3"> {
                config.RDP.EnableRFX = getBoolWithDefault("RDP_ENABLE_RFX", true)
        }</span>

        // Security config
        <span class="cov3" title="3">config.Security.AllowedOrigins = getStringSliceWithDefault("ALLOWED_ORIGINS", []string{})
        config.Security.MaxConnections = getIntWithDefault("MAX_CONNECTIONS", 100)
        config.Security.EnableRateLimit = getBoolWithDefault("ENABLE_RATE_LIMIT", true)
        config.Security.RateLimitPerMinute = getIntWithDefault("RATE_LIMIT_PER_MINUTE", 60)
        config.Security.EnableTLS = getBoolWithDefault("ENABLE_TLS", false)
        config.Security.TLSCertFile = getEnvWithDefault("TLS_CERT_FILE", "")
        config.Security.TLSKeyFile = getEnvWithDefault("TLS_KEY_FILE", "")
        config.Security.MinTLSVersion = getEnvWithDefault("MIN_TLS_VERSION", "1.2")
        config.Security.SkipTLSValidation = getBoolWithDefault("SKIP_TLS_VALIDATION", false) || opts.SkipTLSValidation
        config.Security.TLSServerName = getOverrideOrEnv(opts.TLSServerName, "TLS_SERVER_NAME", "")
        // NLA enabled by default for security; set USE_NLA=false to disable
        config.Security.UseNLA = getBoolWithDefault("USE_NLA", true)
        if opts.UseNLA </span><span class="cov0" title="0">{
                config.Security.UseNLA = true
        }</span>

        // Logging config
        <span class="cov3" title="3">config.Logging.Level = getOverrideOrEnv(opts.LogLevel, "LOG_LEVEL", "info")
        config.Logging.Format = getEnvWithDefault("LOG_FORMAT", "text")
        config.Logging.EnableCaller = getBoolWithDefault("LOG_ENABLE_CALLER", false)
        config.Logging.File = getEnvWithDefault("LOG_FILE", "")

        // Validate configuration
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Store the configuration globally so other packages can access it
        <span class="cov3" title="3">configMutex.Lock()
        globalConfig = config
        configMutex.Unlock()

        return config, nil</span>
}

// GetGlobalConfig returns the globally stored configuration
// This should be used by packages that need access to the configuration
// loaded by the server with command-line overrides
func GetGlobalConfig() *Config <span class="cov1" title="1">{
        configMutex.Lock()
        defer configMutex.Unlock()
        return globalConfig
}</span>

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov7" title="12">{
        // Validate server config
        if c.Server.Port == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("server port cannot be empty")
        }</span>

        <span class="cov7" title="11">if port, err := strconv.Atoi(c.Server.Port); err != nil || port &lt; 1 || port &gt; 65535 </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid server port: %s", c.Server.Port)
        }</span>

        // Validate RDP config
        <span class="cov7" title="10">if c.RDP.DefaultWidth &lt;= 0 || c.RDP.DefaultHeight &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("default dimensions must be positive")
        }</span>

        <span class="cov6" title="9">if c.RDP.MaxWidth &lt; c.RDP.DefaultWidth || c.RDP.MaxHeight &lt; c.RDP.DefaultHeight </span><span class="cov1" title="1">{
                return fmt.Errorf("max dimensions must be &gt;= default dimensions")
        }</span>

        <span class="cov6" title="8">if c.RDP.BufferSize &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("buffer size must be positive")
        }</span>

        // Validate security config
        <span class="cov6" title="7">if c.Security.EnableTLS </span><span class="cov1" title="1">{
                if c.Security.TLSCertFile == "" || c.Security.TLSKeyFile == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("TLS certificate and key files must be specified when TLS is enabled")
                }</span>

                <span class="cov0" title="0">if _, err := os.Stat(c.Security.TLSCertFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS certificate file does not exist: %s", c.Security.TLSCertFile)
                }</span>

                <span class="cov0" title="0">if _, err := os.Stat(c.Security.TLSKeyFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS key file does not exist: %s", c.Security.TLSKeyFile)
                }</span>
        }

        <span class="cov5" title="6">if c.Security.MaxConnections &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max connections must be positive")
        }</span>

        <span class="cov5" title="6">if c.Security.RateLimitPerMinute &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("rate limit per minute must be positive")
        }</span>

        // Validate logging config
        <span class="cov5" title="6">validLogLevels := map[string]bool{
                "debug": true,
                "info":  true,
                "warn":  true,
                "error": true,
        }

        if !validLogLevels[c.Logging.Level] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid log level: %s", c.Logging.Level)
        }</span>

        <span class="cov5" title="5">validLogFormats := map[string]bool{
                "text": true,
                "json": true,
        }

        if !validLogFormats[c.Logging.Format] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid log format: %s", c.Logging.Format)
        }</span>

        <span class="cov4" title="4">return nil</span>
}

// Helper functions for environment variable parsing
func getEnvWithDefault(key, defaultValue string) string <span class="cov10" title="28">{
        if value := os.Getenv(key); value != "" </span><span class="cov5" title="5">{
                return value
        }</span>
        <span class="cov9" title="23">return defaultValue</span>
}

func getIntWithDefault(key string, defaultValue int) int <span class="cov9" title="24">{
        if value := os.Getenv(key); value != "" </span><span class="cov5" title="5">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov4" title="4">{
                        return intValue
                }</span>
        }
        <span class="cov9" title="20">return defaultValue</span>
}

func getBoolWithDefault(key string, defaultValue bool) bool <span class="cov9" title="22">{
        if value := os.Getenv(key); value != "" </span><span class="cov3" title="3">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov2" title="2">{
                        return boolValue
                }</span>
        }
        <span class="cov9" title="20">return defaultValue</span>
}

func getDurationWithDefault(key string, defaultValue time.Duration) time.Duration <span class="cov8" title="15">{
        if value := os.Getenv(key); value != "" </span><span class="cov2" title="2">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov1" title="1">{
                        return duration
                }</span>
        }
        <span class="cov8" title="14">return defaultValue</span>
}

func getStringSliceWithDefault(key string, defaultValue []string) []string <span class="cov5" title="6">{
        if value := os.Getenv(key); value != "" </span><span class="cov1" title="1">{
                return splitString(value, ",")
        }</span>
        <span class="cov5" title="5">return defaultValue</span>
}

// getOverrideOrEnv returns command-line override value, env value, or default
func getOverrideOrEnv(override, envKey, defaultValue string) string <span class="cov8" title="15">{
        if override != "" </span><span class="cov4" title="4">{
                return override
        }</span>
        <span class="cov7" title="11">return getEnvWithDefault(envKey, defaultValue)</span>
}

func splitString(s, sep string) []string <span class="cov5" title="5">{
        if s == "" </span><span class="cov1" title="1">{
                return []string{}
        }</span>

        <span class="cov4" title="4">var result []string
        for _, part := range strings.Split(s, sep) </span><span class="cov7" title="12">{
                if trimmed := strings.TrimSpace(part); trimmed != "" </span><span class="cov7" title="11">{
                        result = append(result, trimmed)
                }</span>
        }
        <span class="cov4" title="4">return result</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package handler

import (
        "context"
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"

        "golang.org/x/net/websocket"

        "github.com/rcarmo/rdp-html5/internal/config"
        "github.com/rcarmo/rdp-html5/internal/logging"
        "github.com/rcarmo/rdp-html5/internal/protocol/audio"
        "github.com/rcarmo/rdp-html5/internal/protocol/pdu"
        "github.com/rcarmo/rdp-html5/internal/rdp"
)

type rdpConn interface {
        GetUpdate() (*rdp.Update, error)
        SendInputEvent(data []byte) error
}

// capabilitiesGetter interface for testing
type capabilitiesGetter interface {
        GetServerCapabilities() *rdp.ServerCapabilityInfo
}

// connectionRequest represents credentials sent via WebSocket
type connectionRequest struct {
        Type     string `json:"type"`
        Host     string `json:"host"`
        User     string `json:"user"`
        Password string `json:"password"`
}

func Connect(w http.ResponseWriter, r *http.Request) <span class="cov6" title="21">{
        // Check origin
        origin := r.Header.Get("Origin")
        if origin != "" &amp;&amp; !isAllowedOrigin(origin) </span><span class="cov1" title="1">{
                http.Error(w, "Origin not allowed", http.StatusForbidden)
                return
        }</span>

        // Create websocket handler
        <span class="cov6" title="20">handler := func(wsConn *websocket.Conn) </span><span class="cov6" title="19">{
                handleWebSocket(wsConn, r)
        }</span>

        // Configure and serve websocket
        <span class="cov6" title="20">server := websocket.Server{
                Handler: handler,
                Handshake: func(config *websocket.Config, r *http.Request) error </span><span class="cov6" title="19">{
                        // Accept any origin that passed our check
                        config.Origin, _ = websocket.Origin(config, r)
                        return nil
                }</span>,
        }
        <span class="cov6" title="20">server.ServeHTTP(w, r)</span>
}

func handleWebSocket(wsConn *websocket.Conn, r *http.Request) <span class="cov6" title="19">{
        defer func() </span><span class="cov6" title="19">{ _ = wsConn.Close() }</span>()

        <span class="cov6" title="19">ctx, cancel := context.WithCancel(r.Context())
        defer cancel()

        width, err := strconv.Atoi(r.URL.Query().Get("width"))
        if err != nil </span><span class="cov2" title="2">{
                logging.Error("Get width: %v", err)
                return
        }</span>

        <span class="cov6" title="17">height, err := strconv.Atoi(r.URL.Query().Get("height"))
        if err != nil </span><span class="cov2" title="2">{
                logging.Error("Get height: %v", err)
                return
        }</span>

        <span class="cov6" title="15">colorDepth := 16 // default to 16-bit
        if cdStr := r.URL.Query().Get("colorDepth"); cdStr != "" </span><span class="cov4" title="7">{
                if cd, err := strconv.Atoi(cdStr); err == nil &amp;&amp; (cd == 8 || cd == 15 || cd == 16 || cd == 24 || cd == 32) </span><span class="cov4" title="6">{
                        colorDepth = cd
                }</span>
        }

        // Check if NLA should be disabled for this connection
        <span class="cov6" title="15">disableNLA := r.URL.Query().Get("disableNLA") == "true"

        // Check if audio should be enabled
        enableAudio := r.URL.Query().Get("audio") == "true"

        // Wait for credentials via WebSocket message (more secure than URL params)
        var credentials connectionRequest
        
        // Set read deadline for credentials
        if err := wsConn.SetReadDeadline(time.Now().Add(30 * time.Second)); err != nil </span><span class="cov0" title="0">{
                logging.Error("Set read deadline: %v", err)
                return
        }</span>
        
        <span class="cov6" title="15">var credMsg []byte
        if err := websocket.Message.Receive(wsConn, &amp;credMsg); err != nil </span><span class="cov6" title="15">{
                logging.Error("Receive credentials: %v", err)
                sendError(wsConn, "Failed to receive credentials")
                return
        }</span>
        
        // Clear read deadline
        <span class="cov0" title="0">if err := wsConn.SetReadDeadline(time.Time{}); err != nil </span><span class="cov0" title="0">{
                logging.Error("Clear read deadline: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">if err := json.Unmarshal(credMsg, &amp;credentials); err != nil </span><span class="cov0" title="0">{
                logging.Error("Parse credentials: %v", err)
                sendError(wsConn, "Invalid credentials format")
                return
        }</span>
        
        <span class="cov0" title="0">if credentials.Type != "credentials" </span><span class="cov0" title="0">{
                logging.Error("Invalid message type: %s", credentials.Type)
                sendError(wsConn, "Expected credentials message")
                return
        }</span>
        
        <span class="cov0" title="0">host := credentials.Host
        user := credentials.User
        password := credentials.Password

        rdpClient, err := rdp.NewClient(host, user, password, width, height, colorDepth)
        if err != nil </span><span class="cov0" title="0">{
                logging.Error("RDP init: %v", err)
                sendError(wsConn, fmt.Sprintf("RDP initialization failed: %v", err))
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = rdpClient.Close() }</span>()

        // Set TLS configuration from server config
        <span class="cov0" title="0">cfg := config.GetGlobalConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                var err error
                cfg, err = config.Load()
                if err != nil </span><span class="cov0" title="0">{
                        logging.Debug("Failed to load config for TLS settings: %v", err)
                        cfg = &amp;config.Config{}
                }</span>
        }

        <span class="cov0" title="0">rdpClient.SetTLSConfig(cfg.Security.SkipTLSValidation, cfg.Security.TLSServerName)
        
        // Use NLA unless explicitly disabled by client or server config
        useNLA := cfg.Security.UseNLA &amp;&amp; !disableNLA
        rdpClient.SetUseNLA(useNLA)
        if disableNLA </span><span class="cov0" title="0">{
                logging.Info("NLA disabled for this connection")
        }</span>
        
        // Enable audio if requested
        <span class="cov0" title="0">if enableAudio </span><span class="cov0" title="0">{
                rdpClient.EnableAudio()
                logging.Info("Audio redirection enabled")
        }</span>

        <span class="cov0" title="0">if err = rdpClient.Connect(); err != nil </span><span class="cov0" title="0">{
                logging.Error("RDP connect: %v", err)
                return
        }</span>
        
        // Set up audio callback to forward audio data to browser
        <span class="cov0" title="0">if enableAudio &amp;&amp; rdpClient.GetAudioHandler() != nil </span><span class="cov0" title="0">{
                rdpClient.GetAudioHandler().SetCallback(func(data []byte, format *audio.AudioFormat, timestamp uint16) </span><span class="cov0" title="0">{
                        sendAudioData(wsConn, data, format, timestamp)
                }</span>)
        }

        // Send server capabilities info to browser
        <span class="cov0" title="0">sendCapabilitiesInfo(wsConn, rdpClient)

        go wsToRdp(ctx, wsConn, rdpClient, cancel)
        rdpToWs(ctx, rdpClient, wsConn)</span>
}

func wsToRdp(ctx context.Context, wsConn *websocket.Conn, rdpConn rdpConn, cancel context.CancelFunc) <span class="cov5" title="11">{
        defer cancel()

        for </span><span class="cov8" title="67">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                default:<span class="cov8" title="66"></span>
                }

                <span class="cov8" title="66">var data []byte
                if err := websocket.Message.Receive(wsConn, &amp;data); err != nil </span><span class="cov5" title="9">{
                        if err == io.EOF || strings.Contains(err.Error(), "use of closed network connection") </span><span class="cov5" title="9">{
                                return
                        }</span>
                        <span class="cov0" title="0">logging.Error("Error reading message from WS: %v", err)
                        return</span>
                }

                <span class="cov8" title="57">if err := rdpConn.SendInputEvent(data); err != nil </span><span class="cov1" title="1">{
                        logging.Error("Failed writing to RDP: %v", err)
                        return
                }</span>
        }
}

var wsMutex sync.Mutex

func rdpToWs(ctx context.Context, rdpConn rdpConn, wsConn *websocket.Conn) <span class="cov5" title="13">{
        for </span><span class="cov10" title="125">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                default:<span class="cov9" title="124"></span>
                }

                <span class="cov9" title="124">update, err := rdpConn.GetUpdate()
                switch </span>{
                case err == nil:<span class="cov9" title="114"></span>
                case errors.Is(err, pdu.ErrDeactiateAll):<span class="cov5" title="9">
                        return</span>
                default:<span class="cov1" title="1">
                        logging.Error("Get update: %v", err)
                        return</span>
                }

                <span class="cov9" title="114">wsMutex.Lock()
                err = websocket.Message.Send(wsConn, update.Data)
                wsMutex.Unlock()

                if err != nil </span><span class="cov2" title="2">{
                        if strings.Contains(err.Error(), "use of closed network connection") </span><span class="cov2" title="2">{
                                return
                        }</span>
                        <span class="cov0" title="0">logging.Error("Failed sending message to WS: %v", err)
                        return</span>
                }
        }
}

// sendCapabilitiesInfo sends server capabilities to the browser
func sendCapabilitiesInfo(wsConn *websocket.Conn, rdpClient capabilitiesGetter) <span class="cov3" title="4">{
        caps := rdpClient.GetServerCapabilities()
        if caps == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov3" title="3">logging.Info("Server Capabilities: codecs=%v surfaceCmds=%v colorDepth=%d desktop=%s multifrag=%d largePtr=%v frameAck=%v",
                caps.BitmapCodecs, caps.SurfaceCommands, caps.ColorDepth, caps.DesktopSize,
                caps.MultifragmentSize, caps.LargePointer, caps.FrameAcknowledge)

        msg := buildCapabilitiesMessage(caps)

        wsMutex.Lock()
        defer wsMutex.Unlock()
        if err := websocket.Message.Send(wsConn, msg); err != nil </span><span class="cov1" title="1">{
                logging.Error("Failed to send capabilities info: %v", err)
        }</span>
}

// buildCapabilitiesMessage creates the capabilities JSON message
func buildCapabilitiesMessage(caps *rdp.ServerCapabilityInfo) []byte <span class="cov4" title="6">{
        logLevel := strings.ToLower(logging.GetLevelString())
        
        jsonData := fmt.Sprintf(`{"type":"capabilities","codecs":[%s],"surfaceCommands":%t,"colorDepth":%d,"desktopSize":"%s","multifragmentSize":%d,"largePointer":%t,"frameAcknowledge":%t,"logLevel":"%s"}`,
                codecListToJSON(caps.BitmapCodecs),
                caps.SurfaceCommands,
                caps.ColorDepth,
                caps.DesktopSize,
                caps.MultifragmentSize,
                caps.LargePointer,
                caps.FrameAcknowledge,
                logLevel)

        msg := make([]byte, 1+len(jsonData))
        msg[0] = 0xFF
        copy(msg[1:], jsonData)
        return msg
}</span>

func codecListToJSON(codecs []string) string <span class="cov5" title="11">{
        if len(codecs) == 0 </span><span class="cov3" title="4">{
                return ""
        }</span>
        <span class="cov4" title="7">quoted := make([]string, len(codecs))
        for i, c := range codecs </span><span class="cov5" title="12">{
                quoted[i] = `"` + c + `"`
        }</span>
        <span class="cov4" title="7">return strings.Join(quoted, ",")</span>
}

// sendError sends an error message to the client via WebSocket
func sendError(wsConn *websocket.Conn, message string) <span class="cov6" title="15">{
        errMsg := fmt.Sprintf(`{"type":"error","message":"%s"}`, message)
        if err := websocket.Message.Send(wsConn, errMsg); err != nil </span><span class="cov0" title="0">{
                logging.Error("Failed to send error message: %v", err)
        }</span>
}

func isAllowedOrigin(origin string) bool <span class="cov8" title="44">{
        if origin == "" </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov8" title="43">normalized := strings.TrimPrefix(strings.TrimPrefix(origin, "http://"), "https://")
        normalized = strings.TrimSuffix(normalized, "/")

        allowed := os.Getenv("ALLOWED_ORIGINS")
        if allowed == "" </span><span class="cov6" title="22">{
                return true
        }</span>

        <span class="cov6" title="21">if strings.HasPrefix(normalized, "localhost") || strings.HasPrefix(normalized, "127.0.0.1") </span><span class="cov4" title="7">{
                return true
        }</span>

        <span class="cov5" title="14">for _, entry := range strings.Split(allowed, ",") </span><span class="cov6" title="16">{
                candidate := strings.TrimSpace(entry)
                if candidate == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="16">if candidate == origin || candidate == normalized </span><span class="cov5" title="10">{
                        return true
                }</span>
                <span class="cov4" title="6">if strings.TrimPrefix(candidate, "http://") == normalized || strings.TrimPrefix(candidate, "https://") == normalized </span><span class="cov2" title="2">{
                        return true
                }</span>
        }

        <span class="cov2" title="2">return false</span>
}

// Audio message types for WebSocket
const (
        AudioMsgTypeData   = 0x01 // Audio PCM data
        AudioMsgTypeFormat = 0x02 // Audio format info
)

// sendAudioData sends audio data to the browser over WebSocket
// Format: [0xFE][msgType][timestamp 2 bytes][format info if type=format][data]
func sendAudioData(wsConn *websocket.Conn, data []byte, format *audio.AudioFormat, timestamp uint16) <span class="cov3" title="3">{
        if len(data) == 0 </span><span class="cov1" title="1">{
                return
        }</span>

        // Build audio message
        // Header: 0xFE (audio marker), msgType, timestamp (2 bytes LE)
        <span class="cov2" title="2">headerSize := 4
        
        // For format messages, include format info
        var formatInfo []byte
        if format != nil </span><span class="cov1" title="1">{
                // Format: channels (2), sampleRate (4), bitsPerSample (2)
                formatInfo = make([]byte, 8)
                binary.LittleEndian.PutUint16(formatInfo[0:2], format.Channels)
                binary.LittleEndian.PutUint32(formatInfo[2:6], format.SamplesPerSec)
                binary.LittleEndian.PutUint16(formatInfo[6:8], format.BitsPerSample)
        }</span>

        <span class="cov2" title="2">msg := make([]byte, headerSize+len(formatInfo)+len(data))
        msg[0] = 0xFE // Audio marker
        msg[1] = AudioMsgTypeData
        binary.LittleEndian.PutUint16(msg[2:4], timestamp)
        
        offset := headerSize
        if len(formatInfo) &gt; 0 </span><span class="cov1" title="1">{
                msg[1] = AudioMsgTypeFormat // Include format
                copy(msg[offset:], formatInfo)
                offset += len(formatInfo)
        }</span>
        <span class="cov2" title="2">copy(msg[offset:], data)

        wsMutex.Lock()
        err := websocket.Message.Send(wsConn, msg)
        wsMutex.Unlock()

        if err != nil </span><span class="cov0" title="0">{
                logging.Debug("Failed to send audio data: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package logging provides a simple leveled logger for the RDP client.
package logging

import (
        "fmt"
        "log"
        "os"
        "strings"
        "sync"
)

// Level represents log severity levels
type Level int

const (
        LevelDebug Level = iota
        LevelInfo
        LevelWarn
        LevelError
)

var levelNames = map[Level]string{
        LevelDebug: "DEBUG",
        LevelInfo:  "INFO",
        LevelWarn:  "WARN",
        LevelError: "ERROR",
}

// Logger provides leveled logging
type Logger struct {
        level  Level
        mu     sync.RWMutex
        logger *log.Logger
}

var (
        defaultLogger *Logger
        once          sync.Once
)

// Default returns the default logger instance
func Default() *Logger <span class="cov10" title="38">{
        once.Do(func() </span><span class="cov1" title="1">{
                defaultLogger = &amp;Logger{
                        level:  LevelInfo,
                        logger: log.New(os.Stderr, "", log.LstdFlags|log.LUTC),
                }
        }</span>)
        <span class="cov10" title="38">return defaultLogger</span>
}

// SetLevel sets the minimum log level
func (l *Logger) SetLevel(level Level) <span class="cov8" title="21">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.level = level
}</span>

// SetLevelFromString sets the log level from a string
func (l *Logger) SetLevelFromString(levelStr string) <span class="cov6" title="10">{
        switch strings.ToLower(levelStr) </span>{
        case "debug":<span class="cov2" title="2">
                l.SetLevel(LevelDebug)</span>
        case "info":<span class="cov2" title="2">
                l.SetLevel(LevelInfo)</span>
        case "warn", "warning":<span class="cov2" title="2">
                l.SetLevel(LevelWarn)</span>
        case "error":<span class="cov2" title="2">
                l.SetLevel(LevelError)</span>
        default:<span class="cov2" title="2">
                l.SetLevel(LevelInfo)</span>
        }
}

// GetLevel returns the current log level
func (l *Logger) GetLevel() Level <span class="cov8" title="19">{
        l.mu.RLock()
        defer l.mu.RUnlock()
        return l.level
}</span>

// GetLevelString returns the current log level as a string
func (l *Logger) GetLevelString() string <span class="cov4" title="4">{
        return levelNames[l.GetLevel()]
}</span>

// GetLevelString returns the default logger's level as a string
func GetLevelString() string <span class="cov4" title="4">{
        return Default().GetLevelString()
}</span>

func (l *Logger) log(level Level, format string, args ...interface{}) <span class="cov4" title="5">{
        l.mu.RLock()
        currentLevel := l.level
        l.mu.RUnlock()

        if level &lt; currentLevel </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov4" title="4">prefix := levelNames[level]
        msg := fmt.Sprintf(format, args...)
        l.logger.Printf("[%s] %s", prefix, msg)</span>
}

// Debug logs a debug message
func (l *Logger) Debug(format string, args ...interface{}) <span class="cov2" title="2">{
        l.log(LevelDebug, format, args...)
}</span>

// Info logs an info message
func (l *Logger) Info(format string, args ...interface{}) <span class="cov1" title="1">{
        l.log(LevelInfo, format, args...)
}</span>

// Warn logs a warning message
func (l *Logger) Warn(format string, args ...interface{}) <span class="cov1" title="1">{
        l.log(LevelWarn, format, args...)
}</span>

// Error logs an error message
func (l *Logger) Error(format string, args ...interface{}) <span class="cov1" title="1">{
        l.log(LevelError, format, args...)
}</span>

// Package-level convenience functions

// SetLevel sets the default logger's level
func SetLevel(level Level) <span class="cov6" title="9">{
        Default().SetLevel(level)
}</span>

// SetLevelFromString sets the default logger's level from a string
func SetLevelFromString(levelStr string) <span class="cov6" title="10">{
        Default().SetLevelFromString(levelStr)
}</span>

// Debug logs a debug message to the default logger
func Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        Default().Debug(format, args...)
}</span>

// Info logs an info message to the default logger
func Info(format string, args ...interface{}) <span class="cov0" title="0">{
        Default().Info(format, args...)
}</span>

// Warn logs a warning message to the default logger
func Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        Default().Warn(format, args...)
}</span>

// Error(format string, args ...interface{}) logs an error message to the default logger
func Error(format string, args ...interface{}) <span class="cov0" title="0">{
        Default().Error(format, args...)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package audio implements RDP audio virtual channel protocols.
// This file contains virtual channel PDU handling.
package audio

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
)

// Channel PDU flags (MS-RDPBCGR 2.2.6.1)
const (
        ChannelFlagFirst    uint32 = 0x00000001
        ChannelFlagLast     uint32 = 0x00000002
        ChannelFlagShowProtocol uint32 = 0x00000010
        ChannelFlagSuspend  uint32 = 0x00000020
        ChannelFlagResume   uint32 = 0x00000040
        ChannelFlagCompress uint32 = 0x00200000
        ChannelFlagPacketAt uint32 = 0x00100000
        ChannelFlagPacketFlushed uint32 = 0x00080000
)

// ChannelPDUHeader represents the virtual channel PDU header
type ChannelPDUHeader struct {
        Length uint32 // Total length of uncompressed channel data
        Flags  uint32 // Channel flags
}

func (h *ChannelPDUHeader) Serialize() []byte <span class="cov4" title="3">{
        buf := make([]byte, 8)
        binary.LittleEndian.PutUint32(buf[0:4], h.Length)
        binary.LittleEndian.PutUint32(buf[4:8], h.Flags)
        return buf
}</span>

func (h *ChannelPDUHeader) Deserialize(r io.Reader) error <span class="cov4" title="3">{
        if err := binary.Read(r, binary.LittleEndian, &amp;h.Length); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("channel header length: %w", err)
        }</span>
        <span class="cov4" title="3">if err := binary.Read(r, binary.LittleEndian, &amp;h.Flags); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("channel header flags: %w", err)
        }</span>
        <span class="cov4" title="3">return nil</span>
}

// IsFirst returns true if this is the first chunk of a fragmented message
func (h *ChannelPDUHeader) IsFirst() bool <span class="cov10" title="13">{
        return h.Flags&amp;ChannelFlagFirst != 0
}</span>

// IsLast returns true if this is the last chunk of a fragmented message
func (h *ChannelPDUHeader) IsLast() bool <span class="cov9" title="11">{
        return h.Flags&amp;ChannelFlagLast != 0
}</span>

// IsComplete returns true if this is a complete (non-fragmented) message
func (h *ChannelPDUHeader) IsComplete() bool <span class="cov6" title="5">{
        return h.IsFirst() &amp;&amp; h.IsLast()
}</span>

// ChannelChunk represents a chunk of virtual channel data
type ChannelChunk struct {
        Header ChannelPDUHeader
        Data   []byte
}

// ChannelDefragmenter handles reassembly of fragmented channel PDUs
type ChannelDefragmenter struct {
        buffer    bytes.Buffer
        totalLen  uint32
        receiving bool
}

// Process handles a channel chunk and returns complete data when available
func (d *ChannelDefragmenter) Process(chunk *ChannelChunk) ([]byte, bool) <span class="cov5" title="4">{
        if chunk.Header.IsFirst() </span><span class="cov3" title="2">{
                d.buffer.Reset()
                d.totalLen = chunk.Header.Length
                d.receiving = true
        }</span>
        
        <span class="cov5" title="4">if !d.receiving </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        
        <span class="cov5" title="4">d.buffer.Write(chunk.Data)
        
        if chunk.Header.IsLast() </span><span class="cov3" title="2">{
                d.receiving = false
                return d.buffer.Bytes(), true
        }</span>
        
        <span class="cov3" title="2">return nil, false</span>
}

// ParseChannelData parses raw channel data into header and payload
func ParseChannelData(data []byte) (*ChannelChunk, error) <span class="cov4" title="3">{
        if len(data) &lt; 8 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("channel data too short: %d bytes", len(data))
        }</span>
        
        <span class="cov3" title="2">chunk := &amp;ChannelChunk{}
        r := bytes.NewReader(data)
        
        if err := chunk.Header.Deserialize(r); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov3" title="2">chunk.Data = data[8:]
        return chunk, nil</span>
}

// BuildChannelData creates a channel PDU with the given data
func BuildChannelData(data []byte) []byte <span class="cov3" title="2">{
        header := ChannelPDUHeader{
                Length: uint32(len(data)),
                Flags:  ChannelFlagFirst | ChannelFlagLast,
        }
        
        buf := make([]byte, 8+len(data))
        copy(buf[0:8], header.Serialize())
        copy(buf[8:], data)
        return buf
}</span>

// BuildChannelPDU creates a complete RDPSND PDU
func BuildChannelPDU(msgType uint8, body []byte) []byte <span class="cov1" title="1">{
        header := PDUHeader{
                MsgType:  msgType,
                Reserved: 0,
                BodySize: uint16(len(body)),
        }
        
        pdu := append(header.Serialize(), body...)
        return BuildChannelData(pdu)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package audio implements RDP audio virtual channel protocols.
// MS-RDPEA: Remote Desktop Protocol Audio Output Virtual Channel Extension
// MS-RDPEAI: Remote Desktop Protocol Audio Input Virtual Channel Extension
package audio

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
)

// Channel names for audio
const (
        ChannelRDPSND = "rdpsnd" // Audio output (server -&gt; client)
        ChannelAUDIN  = "audin"  // Audio input (client -&gt; server) - dynamic virtual channel
)

// RDPSND message types (MS-RDPEA 2.2.2)
const (
        CYCLIC_WRITE_KEYS     = 0x01
        SND_WAVE_CONFIRM      = 0x05
        SND_TRAINING_CONFIRM  = 0x07
        SND_SERVER_AUDIO_CAPS = 0x07
        SND_CLIENT_AUDIO_CAPS = 0x07
        SND_AUDIO_CAPS        = 0x07
        SND_WAVE              = 0x02
        SND_WAVE2             = 0x0D
        SND_TRAINING          = 0x06
        SND_CLOSE             = 0x09
        SND_FORMATS           = 0x04 // Client format request
        SND_QUALITYMODE       = 0x0C
        SND_CRYPT_KEY         = 0x08
        SND_WAVE_ENCRYPT      = 0x0F
)

// Audio format tags (WAVE format identifiers)
const (
        WAVE_FORMAT_PCM        = 0x0001
        WAVE_FORMAT_ADPCM      = 0x0002
        WAVE_FORMAT_ALAW       = 0x0006
        WAVE_FORMAT_MULAW      = 0x0007
        WAVE_FORMAT_GSM610     = 0x0031
        WAVE_FORMAT_AAC        = 0x00FF
        WAVE_FORMAT_MPEGLAYER3 = 0x0055
)

// PDUHeader represents the RDPSND PDU header
type PDUHeader struct {
        MsgType  uint8
        Reserved uint8
        BodySize uint16
}

func (h *PDUHeader) Serialize() []byte <span class="cov10" title="3">{
        buf := make([]byte, 4)
        buf[0] = h.MsgType
        buf[1] = h.Reserved
        binary.LittleEndian.PutUint16(buf[2:4], h.BodySize)
        return buf
}</span>

func (h *PDUHeader) Deserialize(r io.Reader) error <span class="cov6" title="2">{
        return binary.Read(r, binary.LittleEndian, h)
}</span>

// AudioFormat represents an audio format descriptor
type AudioFormat struct {
        FormatTag        uint16
        Channels         uint16
        SamplesPerSec    uint32
        AvgBytesPerSec   uint32
        BlockAlign       uint16
        BitsPerSample    uint16
        ExtraDataSize    uint16
        ExtraData        []byte
}

func (f *AudioFormat) Serialize() []byte <span class="cov6" title="2">{
        size := 18 + len(f.ExtraData)
        buf := make([]byte, size)
        binary.LittleEndian.PutUint16(buf[0:2], f.FormatTag)
        binary.LittleEndian.PutUint16(buf[2:4], f.Channels)
        binary.LittleEndian.PutUint32(buf[4:8], f.SamplesPerSec)
        binary.LittleEndian.PutUint32(buf[8:12], f.AvgBytesPerSec)
        binary.LittleEndian.PutUint16(buf[12:14], f.BlockAlign)
        binary.LittleEndian.PutUint16(buf[14:16], f.BitsPerSample)
        binary.LittleEndian.PutUint16(buf[16:18], f.ExtraDataSize)
        if len(f.ExtraData) &gt; 0 </span><span class="cov0" title="0">{
                copy(buf[18:], f.ExtraData)
        }</span>
        <span class="cov6" title="2">return buf</span>
}

func (f *AudioFormat) Deserialize(r io.Reader) error <span class="cov6" title="2">{
        if err := binary.Read(r, binary.LittleEndian, &amp;f.FormatTag); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="2">if err := binary.Read(r, binary.LittleEndian, &amp;f.Channels); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="2">if err := binary.Read(r, binary.LittleEndian, &amp;f.SamplesPerSec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="2">if err := binary.Read(r, binary.LittleEndian, &amp;f.AvgBytesPerSec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="2">if err := binary.Read(r, binary.LittleEndian, &amp;f.BlockAlign); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="2">if err := binary.Read(r, binary.LittleEndian, &amp;f.BitsPerSample); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="2">if err := binary.Read(r, binary.LittleEndian, &amp;f.ExtraDataSize); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="2">if f.ExtraDataSize &gt; 0 </span><span class="cov0" title="0">{
                f.ExtraData = make([]byte, f.ExtraDataSize)
                if _, err := io.ReadFull(r, f.ExtraData); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov6" title="2">return nil</span>
}

// String returns a human-readable format description
func (f *AudioFormat) String() string <span class="cov10" title="3">{
        var formatName string
        switch f.FormatTag </span>{
        case WAVE_FORMAT_PCM:<span class="cov1" title="1">
                formatName = "PCM"</span>
        case WAVE_FORMAT_ADPCM:<span class="cov1" title="1">
                formatName = "ADPCM"</span>
        case WAVE_FORMAT_ALAW:<span class="cov0" title="0">
                formatName = "A-Law"</span>
        case WAVE_FORMAT_MULAW:<span class="cov0" title="0">
                formatName = "-Law"</span>
        case WAVE_FORMAT_AAC:<span class="cov0" title="0">
                formatName = "AAC"</span>
        case WAVE_FORMAT_MPEGLAYER3:<span class="cov0" title="0">
                formatName = "MP3"</span>
        default:<span class="cov1" title="1">
                formatName = fmt.Sprintf("0x%04X", f.FormatTag)</span>
        }
        <span class="cov10" title="3">return fmt.Sprintf("%s %dHz %dch %dbit", formatName, f.SamplesPerSec, f.Channels, f.BitsPerSample)</span>
}

// ServerAudioFormats represents the server's audio format list (SNDC_FORMATS)
type ServerAudioFormats struct {
        Version            uint16
        Padding            uint16
        VolumePDUFlags     uint16
        Padding2           uint16
        NumFormats         uint16
        CbMaxPDUSize       uint8
        Pad                uint8
        Formats            []AudioFormat
}

func (s *ServerAudioFormats) Deserialize(data []byte) error <span class="cov6" title="2">{
        if len(data) &lt; 12 </span><span class="cov1" title="1">{
                return fmt.Errorf("server audio formats too short: %d", len(data))
        }</span>
        <span class="cov1" title="1">r := bytes.NewReader(data)
        
        if err := binary.Read(r, binary.LittleEndian, &amp;s.Version); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;s.Padding); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;s.VolumePDUFlags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;s.Padding2); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;s.NumFormats); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;s.CbMaxPDUSize); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;s.Pad); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov1" title="1">s.Formats = make([]AudioFormat, s.NumFormats)
        for i := uint16(0); i &lt; s.NumFormats; i++ </span><span class="cov1" title="1">{
                if err := s.Formats[i].Deserialize(r); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("format %d: %w", i, err)
                }</span>
        }
        
        <span class="cov1" title="1">return nil</span>
}

// ClientAudioFormats represents the client's response with supported formats
type ClientAudioFormats struct {
        Version            uint16
        Padding            uint16
        VolumePDUFlags     uint16
        Padding2           uint16
        NumFormats         uint16
        CbMaxPDUSize       uint8
        Pad                uint8
        Formats            []AudioFormat
}

func (c *ClientAudioFormats) Serialize() []byte <span class="cov1" title="1">{
        var buf bytes.Buffer
        _ = binary.Write(&amp;buf, binary.LittleEndian, c.Version)
        _ = binary.Write(&amp;buf, binary.LittleEndian, c.Padding)
        _ = binary.Write(&amp;buf, binary.LittleEndian, c.VolumePDUFlags)
        _ = binary.Write(&amp;buf, binary.LittleEndian, c.Padding2)
        _ = binary.Write(&amp;buf, binary.LittleEndian, c.NumFormats)
        _ = binary.Write(&amp;buf, binary.LittleEndian, c.CbMaxPDUSize)
        _ = binary.Write(&amp;buf, binary.LittleEndian, c.Pad)

        for _, format := range c.Formats </span><span class="cov1" title="1">{
                buf.Write(format.Serialize())
        }</span>

        <span class="cov1" title="1">return buf.Bytes()</span>
}

// TrainingPDU represents SNDC_TRAINING
type TrainingPDU struct {
        Timestamp uint16
        PackSize  uint16
        Data      []byte
}

func (t *TrainingPDU) Deserialize(data []byte) error <span class="cov1" title="1">{
        if len(data) &lt; 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("training PDU too short")
        }</span>
        <span class="cov1" title="1">r := bytes.NewReader(data)
        if err := binary.Read(r, binary.LittleEndian, &amp;t.Timestamp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;t.PackSize); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if t.PackSize &gt; 4 </span><span class="cov1" title="1">{
                t.Data = make([]byte, t.PackSize-4)
                if _, err := io.ReadFull(r, t.Data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// TrainingConfirmPDU represents SNDC_TRAINING_CONFIRM (client response)
type TrainingConfirmPDU struct {
        Timestamp uint16
        PackSize  uint16
}

func (t *TrainingConfirmPDU) Serialize() []byte <span class="cov1" title="1">{
        buf := make([]byte, 4)
        binary.LittleEndian.PutUint16(buf[0:2], t.Timestamp)
        binary.LittleEndian.PutUint16(buf[2:4], t.PackSize)
        return buf
}</span>

// WaveInfoPDU represents SNDC_WAVE (first part of audio data)
type WaveInfoPDU struct {
        Timestamp       uint16
        FormatNo        uint16
        BlockNo         uint8
        Padding         [3]byte
        InitialData     []byte // First 4 bytes of audio data
}

func (w *WaveInfoPDU) Deserialize(data []byte) error <span class="cov1" title="1">{
        if len(data) &lt; 12 </span><span class="cov0" title="0">{
                return fmt.Errorf("wave info too short")
        }</span>
        <span class="cov1" title="1">r := bytes.NewReader(data)
        if err := binary.Read(r, binary.LittleEndian, &amp;w.Timestamp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;w.FormatNo); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;w.BlockNo); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if _, err := r.Read(w.Padding[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">w.InitialData = make([]byte, 4)
        _, err := r.Read(w.InitialData)
        return err</span>
}

// Wave2PDU represents SNDC_WAVE2 (simplified wave PDU)
type Wave2PDU struct {
        Timestamp uint16
        FormatNo  uint16
        BlockNo   uint8
        Padding   [3]byte
        DataSize  uint32
        Data      []byte
}

func (w *Wave2PDU) Deserialize(data []byte) error <span class="cov1" title="1">{
        if len(data) &lt; 12 </span><span class="cov0" title="0">{
                return fmt.Errorf("wave2 PDU too short")
        }</span>
        <span class="cov1" title="1">r := bytes.NewReader(data)
        if err := binary.Read(r, binary.LittleEndian, &amp;w.Timestamp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;w.FormatNo); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;w.BlockNo); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if _, err := r.Read(w.Padding[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if err := binary.Read(r, binary.LittleEndian, &amp;w.DataSize); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">remaining := len(data) - 12
        if remaining &gt; 0 </span><span class="cov1" title="1">{
                w.Data = make([]byte, remaining)
                _, err := r.Read(w.Data)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WaveConfirmPDU represents SNDC_WAVECONFIRM (client acknowledgment)
type WaveConfirmPDU struct {
        Timestamp     uint16
        ConfirmedBlock uint8
        Padding        uint8
}

func (w *WaveConfirmPDU) Serialize() []byte <span class="cov1" title="1">{
        buf := make([]byte, 4)
        binary.LittleEndian.PutUint16(buf[0:2], w.Timestamp)
        buf[2] = w.ConfirmedBlock
        buf[3] = w.Padding
        return buf
}</span>

// ClosePDU represents SNDC_CLOSE
type ClosePDU struct {
}

// QualityModePDU represents SNDC_QUALITYMODE
type QualityModePDU struct {
        QualityMode uint16
}

func (q *QualityModePDU) Serialize() []byte <span class="cov10" title="3">{
        buf := make([]byte, 2)
        binary.LittleEndian.PutUint16(buf[0:2], q.QualityMode)
        return buf
}</span>

// Quality mode constants
const (
        QualityModeDynamic = 0x0000
        QualityModeMedium  = 0x0001
        QualityModeHigh    = 0x0002
)
</pre>
		
		<pre class="file" id="file29" style="display: none">package encoding

import (
        "encoding/binary"
        "errors"
        "fmt"
        "io"
)

// BER reading functions

func BerReadApplicationTag(r io.Reader) (uint8, error) <span class="cov5" title="6">{
        var (
                identifier uint8
                tag        uint8
                err        error
        )

        err = binary.Read(r, binary.BigEndian, &amp;identifier)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov4" title="5">if identifier != (ClassApplication|PCConstruct)|TagMask </span><span class="cov1" title="1">{
                return 0, errors.New("ReadApplicationTag invalid data")
        }</span>

        <span class="cov4" title="4">err = binary.Read(r, binary.BigEndian, &amp;tag)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov3" title="3">return tag, nil</span>
}

func BerReadLength(r io.Reader) (uint16, error) <span class="cov9" title="42">{
        var (
                ret  uint16
                size uint8
                err  error
        )

        err = binary.Read(r, binary.BigEndian, &amp;size)
        if err != nil </span><span class="cov2" title="2">{
                return 0, err
        }</span>

        <span class="cov9" title="40">if size&amp;0x80 &gt; 0 </span><span class="cov7" title="15">{
                size = size &amp;^ 0x80

                switch size </span>{
                case 1:<span class="cov5" title="6">
                        err = binary.Read(r, binary.BigEndian, &amp;size)
                        if err != nil </span><span class="cov1" title="1">{
                                return 0, err
                        }</span>
                        <span class="cov4" title="5">ret = uint16(size)</span>
                case 2:<span class="cov5" title="8">
                        err = binary.Read(r, binary.BigEndian, &amp;ret)
                        if err != nil </span><span class="cov1" title="1">{
                                return 0, err
                        }</span>
                default:<span class="cov1" title="1">
                        return 0, errors.New("BER length may be 1 or 2")</span>
                }
        } else<span class="cov8" title="25"> {
                ret = uint16(size)
        }</span>

        <span class="cov9" title="37">return ret, nil</span>
}

func berPC(pc bool) uint8 <span class="cov8" title="30">{
        if pc </span><span class="cov2" title="2">{
                return PCConstruct
        }</span>
        <span class="cov8" title="28">return PCPrimitive</span>
}

func BerReadUniversalTag(tag uint8, pc bool, r io.Reader) (bool, error) <span class="cov8" title="34">{
        var bb uint8

        err := binary.Read(r, binary.BigEndian, &amp;bb)
        if err != nil </span><span class="cov4" title="4">{
                return false, err
        }</span>

        <span class="cov8" title="30">return bb == (ClassUniversal|berPC(pc))|(TagMask&amp;tag), nil</span>
}

func BerReadEnumerated(r io.Reader) (uint8, error) <span class="cov5" title="6">{
        universalTag, err := BerReadUniversalTag(TagEnumerated, false, r)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov4" title="5">if !universalTag </span><span class="cov1" title="1">{
                return 0, errors.New("invalid ber tag")
        }</span>

        <span class="cov4" title="4">length, err := BerReadLength(r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov4" title="4">if length != 1 </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("enumerate size is wrong, get %v, expect 1", length)
        }</span>

        <span class="cov3" title="3">var enumerated uint8

        return enumerated, binary.Read(r, binary.BigEndian, &amp;enumerated)</span>
}

func BerReadInteger(r io.Reader) (int, error) <span class="cov6" title="11">{
        universalTag, err := BerReadUniversalTag(TagInteger, false, r)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov6" title="10">if !universalTag </span><span class="cov1" title="1">{
                return 0, errors.New("bad integer tag")
        }</span>

        <span class="cov5" title="9">size, err := BerReadLength(r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov5" title="9">switch size </span>{
        case 1:<span class="cov3" title="3">
                var num uint8

                return int(num), binary.Read(r, binary.BigEndian, &amp;num)</span>
        case 2:<span class="cov3" title="3">
                var num uint16

                return int(num), binary.Read(r, binary.BigEndian, &amp;num)</span>
        case 3:<span class="cov1" title="1">
                var (
                        int1 uint8
                        int2 uint16
                )

                err = binary.Read(r, binary.BigEndian, &amp;int1)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov1" title="1">err = binary.Read(r, binary.BigEndian, &amp;int2)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov1" title="1">return int(int1)&lt;&lt;0x10 + int(int2), nil</span>
        case 4:<span class="cov1" title="1">
                var num uint32

                return int(num), binary.Read(r, binary.BigEndian, &amp;num)</span>
        default:<span class="cov1" title="1">
                return 0, errors.New("wrong size")</span>
        }
}

// BER writing functions - writes to bytes.Buffer which doesn't fail
//
//nolint:errcheck

func BerWriteBoolean(b bool, w io.Writer) <span class="cov2" title="2">{
        bb := uint8(0)
        if b </span><span class="cov1" title="1">{
                bb = uint8(0xff)
        }</span>
        <span class="cov2" title="2">_, _ = w.Write([]byte{0x01}) // tag boolean
        BerWriteLength(1, w)
        _, _ = w.Write([]byte{bb})</span>
}

func BerWriteInteger(n int, w io.Writer) <span class="cov6" title="12">{
        _, _ = w.Write([]byte{0x02}) // tag integer
        if n &lt;= 0xff </span><span class="cov4" title="5">{
                BerWriteLength(1, w)
                _, _ = w.Write([]byte{uint8(n)})
        }</span> else<span class="cov5" title="7"> if n &lt;= 0xffff </span><span class="cov4" title="4">{
                BerWriteLength(2, w)
                _ = binary.Write(w, binary.BigEndian, uint16(n))
        }</span> else<span class="cov3" title="3"> {
                BerWriteLength(4, w)
                _ = binary.Write(w, binary.BigEndian, uint32(n))
        }</span>
}

func BerWriteOctetString(str []byte, w io.Writer) <span class="cov4" title="5">{
        _, _ = w.Write([]byte{0x04}) // tag octet string
        BerWriteLength(len(str), w)
        _, _ = w.Write(str)
}</span>

func BerWriteSequence(data []byte, w io.Writer) <span class="cov4" title="4">{
        _, _ = w.Write([]byte{0x30}) // tag sequence
        BerWriteLength(len(data), w)
        _, _ = w.Write(data)
}</span>

func BerWriteApplicationTag(tag uint8, size int, w io.Writer) <span class="cov5" title="7">{
        if tag &gt; 30 </span><span class="cov4" title="4">{
                _, _ = w.Write([]byte{
                        0x7f, // leading octet for tags with number greater than or equal to 31
                        tag,
                })
                BerWriteLength(size, w)
        }</span> else<span class="cov3" title="3"> {
                _, _ = w.Write([]byte{tag})
                BerWriteLength(size, w)
        }</span>
}

func BerWriteLength(size int, w io.Writer) <span class="cov10" title="55">{
        if size &gt; 0xff </span><span class="cov5" title="8">{
                // Long form: 0x82 means 2 bytes follow
                _, _ = w.Write([]byte{0x82})
                _ = binary.Write(w, binary.BigEndian, uint16(size))
        }</span> else<span class="cov9" title="47"> if size &gt; 0x7f </span><span class="cov5" title="8">{
                // Long form: 0x81 means 1 byte follows
                _, _ = w.Write([]byte{0x81, uint8(size)})
        }</span> else<span class="cov9" title="39"> {
                // Short form: size directly in length octet
                _, _ = w.Write([]byte{uint8(size)})
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package encoding

import (
        "encoding/binary"
        "errors"
        "io"
)

// PER reading functions

func PerReadChoice(r io.Reader) (uint8, error) <span class="cov4" title="4">{
        var choice uint8

        return choice, binary.Read(r, binary.BigEndian, &amp;choice)
}</span>

func PerReadLength(r io.Reader) (int, error) <span class="cov9" title="41">{
        var (
                octet uint8
                size  int
                err   error
        )

        if err = binary.Read(r, binary.BigEndian, &amp;octet); err != nil </span><span class="cov4" title="5">{
                return 0, err
        }</span>

        <span class="cov9" title="36">if octet&amp;0x80 != 0x80 </span><span class="cov8" title="24">{
                return int(octet), nil
        }</span>

        <span class="cov6" title="12">octet &amp;^= 0x80
        size = int(octet) &lt;&lt; 8

        if err = binary.Read(r, binary.BigEndian, &amp;octet); err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov6" title="11">size += int(octet)

        return size, nil</span>
}

func PerReadObjectIdentifier(oid [6]byte, r io.Reader) (bool, error) <span class="cov4" title="5">{
        size, err := PerReadLength(r)
        if err != nil </span><span class="cov1" title="1">{
                return false, err
        }</span>

        <span class="cov4" title="4">if size != 5 </span><span class="cov1" title="1">{
                return false, nil
        }</span>

        <span class="cov3" title="3">var t12 uint8
        err = binary.Read(r, binary.BigEndian, &amp;t12)
        if err != nil </span><span class="cov1" title="1">{
                return false, err
        }</span>

        <span class="cov2" title="2">aOid := make([]byte, 6)
        aOid[0] = t12 &gt;&gt; 4
        aOid[1] = t12 &amp; 0x0f

        for i := 2; i &lt;= 5; i++ </span><span class="cov5" title="8">{
                err = binary.Read(r, binary.BigEndian, &amp;aOid[i])
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov2" title="2">for i := 0; i &lt; len(aOid); i++ </span><span class="cov6" title="12">{
                if oid[i] != aOid[i] </span><span class="cov1" title="1">{
                        return false, nil
                }</span>
        }

        <span class="cov1" title="1">return true, nil</span>
}

func PerReadInteger16(minimum uint16, r io.Reader) (uint16, error) <span class="cov6" title="11">{
        var num uint16

        if err := binary.Read(r, binary.BigEndian, &amp;num); err != nil </span><span class="cov2" title="2">{
                return 0, err
        }</span>

        <span class="cov6" title="9">num += minimum

        return num, nil</span>
}

func PerReadInteger(r io.Reader) (int, error) <span class="cov6" title="9">{
        size, err := PerReadLength(r)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov5" title="8">switch size </span>{
        case 1:<span class="cov3" title="3">
                var num uint8

                return int(num), binary.Read(r, binary.BigEndian, &amp;num)</span>
        case 2:<span class="cov3" title="3">
                var num uint16

                return int(num), binary.Read(r, binary.BigEndian, &amp;num)</span>
        case 4:<span class="cov1" title="1">
                var num uint32

                return int(num), binary.Read(r, binary.BigEndian, &amp;num)</span>
        default:<span class="cov1" title="1">
                return 0, errors.New("bad integer length")</span>
        }
}

func PerReadEnumerates(r io.Reader) (uint8, error) <span class="cov4" title="4">{
        var num uint8

        return num, binary.Read(r, binary.BigEndian, &amp;num)
}</span>

func PerReadNumberOfSet(r io.Reader) (uint8, error) <span class="cov4" title="4">{
        var num uint8

        return num, binary.Read(r, binary.BigEndian, &amp;num)
}</span>

func PerReadOctetStream(octetStream []byte, minValue int, r io.Reader) (bool, error) <span class="cov5" title="6">{
        length, err := PerReadLength(r)
        if err != nil </span><span class="cov1" title="1">{
                return false, err
        }</span>

        <span class="cov4" title="5">size := length + minValue
        if size != len(octetStream) </span><span class="cov1" title="1">{
                return false, nil
        }</span>

        <span class="cov4" title="4">var c uint8

        for i := 0; i &lt; size; i++ </span><span class="cov7" title="17">{
                if err = binary.Read(r, binary.BigEndian, &amp;c); err != nil </span><span class="cov1" title="1">{
                        return false, err
                }</span>

                <span class="cov7" title="16">if octetStream[i] != c </span><span class="cov1" title="1">{
                        return false, nil
                }</span>
        }

        <span class="cov2" title="2">return true, nil</span>
}

// PER writing functions

func PerWriteChoice(choice uint8, w io.Writer) <span class="cov3" title="3">{
        _, _ = w.Write([]byte{
                choice,
        })
}</span>

func PerWriteObjectIdentifier(oid [6]byte, w io.Writer) <span class="cov3" title="3">{
        PerWriteLength(5, w)

        _, _ = w.Write([]byte{
                (oid[0] &lt;&lt; 4) &amp; (oid[1] &amp; 0x0f),
                oid[2],
                oid[3],
                oid[4],
                oid[5],
        })
}</span>

func PerWriteLength(value uint16, w io.Writer) <span class="cov10" title="44">{
        if value &gt; 0x7f </span><span class="cov6" title="12">{
                _ = binary.Write(w, binary.BigEndian, value|0x8000)
                return
        }</span>

        <span class="cov9" title="32">_, _ = w.Write([]byte{uint8(value)})</span>
}

func PerWriteSelection(selection uint8, w io.Writer) <span class="cov3" title="3">{
        _, _ = w.Write([]byte{
                selection,
        })
}</span>

func PerWriteNumericString(nStr string, minValue int, w io.Writer) <span class="cov4" title="5">{
        length := len(nStr)
        mLength := minValue

        if length-minValue &gt;= 0 </span><span class="cov4" title="5">{
                mLength = length - minValue
        }</span>

        <span class="cov4" title="5">result := make([]byte, 0, mLength)

        for i := 0; i &lt; length; i += 2 </span><span class="cov5" title="6">{
                c1 := nStr[i]
                c2 := byte(0x30)

                if i+1 &lt; length </span><span class="cov4" title="5">{
                        c2 = nStr[i+1]
                }</span>

                <span class="cov5" title="6">c1 = (c1 - 0x30) % 10
                c2 = (c2 - 0x30) % 10

                result = append(result, (c1&lt;&lt;4)|c2)</span>
        }

        <span class="cov4" title="5">PerWriteLength(uint16(mLength), w)
        _, _ = w.Write(result)</span>
}

func PerWritePadding(length int, w io.Writer) <span class="cov3" title="3">{
        _, _ = w.Write(make([]byte, length))
}</span>

func PerWriteNumberOfSet(numberOfSet uint8, w io.Writer) <span class="cov3" title="3">{
        _, _ = w.Write([]byte{numberOfSet})
}</span>

func PerWriteOctetStream(oStr string, minValue int, w io.Writer) <span class="cov3" title="3">{
        length := len(oStr)
        mLength := minValue

        if length-minValue &gt;= 0 </span><span class="cov3" title="3">{
                mLength = length - minValue
        }</span>

        <span class="cov3" title="3">result := make([]byte, 0, mLength)
        for i := 0; i &lt; length; i++ </span><span class="cov6" title="10">{
                result = append(result, oStr[i])
        }</span>

        <span class="cov3" title="3">PerWriteLength(uint16(mLength), w)
        _, _ = w.Write(result)</span>
}

func PerWriteInteger(value int, w io.Writer) <span class="cov7" title="13">{
        if value &lt;= 0xff </span><span class="cov4" title="5">{
                PerWriteLength(1, w)
                _, _ = w.Write([]byte{uint8(value)})

                return
        }</span>

        <span class="cov5" title="8">if value &lt; 0xffff </span><span class="cov4" title="4">{
                PerWriteLength(2, w)
                _ = binary.Write(w, binary.BigEndian, uint16(value))

                return
        }</span>

        <span class="cov4" title="4">PerWriteLength(4, w)
        _ = binary.Write(w, binary.BigEndian, uint32(value))</span>
}

func PerWriteInteger16(value, minimum uint16, w io.Writer) <span class="cov6" title="10">{
        value -= minimum

        _ = binary.Write(w, binary.BigEndian, value)
}</span>

// BerWriteInteger16 writes a 16-bit integer in BER format
func BerWriteInteger16(n uint16, w io.Writer) <span class="cov4" title="4">{
        _, _ = w.Write([]byte{0x02}) // tag integer
        BerWriteLength(2, w)
        _ = binary.Write(w, binary.BigEndian, n)
}</span>

// BerReadInteger16 reads a 16-bit integer in BER format
func BerReadInteger16(r io.Reader) (uint16, error) <span class="cov5" title="7">{
        universalTag, err := BerReadUniversalTag(TagInteger, false, r)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov5" title="6">if !universalTag </span><span class="cov1" title="1">{
                return 0, errors.New("bad integer tag")
        }</span>

        <span class="cov4" title="5">size, err := BerReadLength(r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov4" title="5">if size != 2 </span><span class="cov1" title="1">{
                return 0, errors.New("expected 2-byte integer")
        }</span>

        <span class="cov4" title="4">var num uint16
        return num, binary.Read(r, binary.BigEndian, &amp;num)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package fastpath

import (
        "io"
)

type Protocol struct {
        conn io.ReadWriter

        updatePDUData []byte
}

func New(conn io.ReadWriter) *Protocol <span class="cov10" title="12">{
        return &amp;Protocol{
                conn: conn,

                updatePDUData: make([]byte, 64*1024),
        }
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package fastpath

import (
        "encoding/binary"
        "errors"
        "io"
)

type UpdateCode uint8

const (
        UpdateCodeOrders       UpdateCode = 0x0
        UpdateCodeBitmap       UpdateCode = 0x1
        UpdateCodePalette      UpdateCode = 0x2
        UpdateCodeSynchronize  UpdateCode = 0x3
        UpdateCodeSurfCMDs     UpdateCode = 0x4
        UpdateCodePTRNull      UpdateCode = 0x5
        UpdateCodePTRDefault   UpdateCode = 0x6
        UpdateCodePTRPosition  UpdateCode = 0x8
        UpdateCodeColor        UpdateCode = 0x9
        UpdateCodeCached       UpdateCode = 0xa
        UpdateCodePointer      UpdateCode = 0xb
        UpdateCodeLargePointer UpdateCode = 0xc
)

type Fragment uint8

const (
        FragmentSingle Fragment = 0x0
        FragmentLast   Fragment = 0x1
        FragmentFirst  Fragment = 0x2
        FragmentNext   Fragment = 0x3
)

type Compression uint8

const (
        CompressionUsed Compression = 0x2
)

type Update struct {
        UpdateCode       UpdateCode
        fragmentation    Fragment
        compression      Compression
        compressionFlags uint8
        size             uint16
}

func (u *Update) Deserialize(wire io.Reader) error <span class="cov10" title="17">{
        var err error

        var updateHeader uint8
        err = binary.Read(wire, binary.LittleEndian, &amp;updateHeader)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="16">u.UpdateCode = UpdateCode(updateHeader &amp; 0xf)
        u.fragmentation = Fragment((updateHeader &gt;&gt; 4) &amp; 0x3)
        u.compression = Compression((updateHeader &gt;&gt; 6) &amp; 0x3)

        if u.compression&amp;CompressionUsed == CompressionUsed </span><span class="cov1" title="1">{
                err = binary.Read(wire, binary.LittleEndian, &amp;u.compressionFlags)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov9" title="16">err = binary.Read(wire, binary.LittleEndian, &amp;u.size)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        //switch u.UpdateCode {
        //case UpdateCodePalette:
        //        u.paletteUpdateData = &amp;paletteUpdateData{}
        //
        //        return u.paletteUpdateData.Deserialize(wire)
        //case UpdateCodeBitmap:
        //        u.bitmapUpdateData = &amp;bitmapUpdateData{}
        //
        //        return u.bitmapUpdateData.Deserialize(wire)
        //case UpdateCodeSynchronize: // do nothing
        //case UpdateCodePTRPosition:
        //        u.pointerPositionUpdateData = &amp;pointerPositionUpdateData{}
        //
        //        return u.pointerPositionUpdateData.Deserialize(wire)
        //case UpdateCodePTRNull: // do nothing
        //case UpdateCodePTRDefault: // do nothing
        //case UpdateCodeCached:
        //        u.colorPointerUpdateData = &amp;colorPointerUpdateData{}
        //
        //        return u.colorPointerUpdateData.Deserialize(wire)
        //}

        <span class="cov9" title="15">d := make([]byte, u.size)
        _, err = wire.Read(d)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="15">return nil</span>
}

type UpdatePDUAction uint8

const (
        UpdatePDUActionFastPath UpdatePDUAction = 0x0
        UpdatePDUActionX224     UpdatePDUAction = 0x3
)

type UpdatePDUFlag uint8

const (
        UpdatePDUFlagSecureChecksum UpdatePDUFlag = 0x1
        UpdatePDUFlagEncrypted      UpdatePDUFlag = 0x2
)

type UpdatePDU struct {
        fpOutputHeader uint8
        Action         UpdatePDUAction
        Flags          UpdatePDUFlag
        Data           []byte
}

var ErrUnexpectedX224 = errors.New("unexpected x224")

func (pdu *UpdatePDU) Deserialize(wire io.Reader) error <span class="cov9" title="13">{
        err := binary.Read(wire, binary.LittleEndian, &amp;pdu.fpOutputHeader)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov8" title="11">pdu.Action = UpdatePDUAction(pdu.fpOutputHeader &amp; 0x3)
        pdu.Flags = UpdatePDUFlag((pdu.fpOutputHeader &gt;&gt; 6) &amp; 0x3)

        if pdu.Action == UpdatePDUActionX224 </span><span class="cov3" title="2">{
                return ErrUnexpectedX224
        }</span>

        <span class="cov7" title="9">if pdu.Flags&amp;UpdatePDUFlagSecureChecksum == UpdatePDUFlagSecureChecksum </span><span class="cov1" title="1">{
                return errors.New("checksum not supported")
        }</span>

        <span class="cov7" title="8">if pdu.Flags&amp;UpdatePDUFlagEncrypted == UpdatePDUFlagEncrypted </span><span class="cov1" title="1">{
                return errors.New("encryption not supported")
        }</span>

        <span class="cov7" title="7">var (
                length           uint16
                length1, length2 uint8
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;length1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="7">length = uint16(length1)

        if length1&amp;0x80 == 0x80 </span><span class="cov3" title="2">{
                err = binary.Read(wire, binary.LittleEndian, &amp;length2)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov3" title="2">length1 -= 0x80

                length = binary.BigEndian.Uint16([]byte{length1, length2})</span>
        }

        <span class="cov7" title="7">if length &gt; 0x4000 </span><span class="cov1" title="1">{
                return errors.New("too big packet")
        }</span>

        <span class="cov6" title="6">if len(pdu.Data) != 0 </span><span class="cov5" title="4">{
                pdu.Data = pdu.Data[:length]
        }</span> else<span class="cov3" title="2"> {
                pdu.Data = make([]byte, length)
        }</span>

        <span class="cov6" title="6">_, err = wire.Read(pdu.Data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="6">return nil</span>
}

func (i *Protocol) Receive() (*UpdatePDU, error) <span class="cov6" title="5">{
        var pdu UpdatePDU
        pdu.Data = i.updatePDUData
        if err := pdu.Deserialize(i.conn); err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov4" title="3">return &amp;pdu, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package fastpath

import (
        "bytes"
        "encoding/binary"
        "io"
)

type InputEventPDU struct {
        action    uint8
        numEvents uint8
        flags     uint8
        eventData []byte
}

func NewInputEventPDU(eventData []byte) *InputEventPDU <span class="cov6" title="5">{
        return &amp;InputEventPDU{
                numEvents: 1,
                eventData: eventData,
        }
}</span>

func (pdu *InputEventPDU) Serialize() []byte <span class="cov9" title="11">{
        buf := new(bytes.Buffer)

        fpInputHeader := pdu.action&amp;0x3 | ((pdu.numEvents &amp; 0xf) &lt;&lt; 2) | ((pdu.flags &amp; 0x3) &lt;&lt; 6)
        length := 1 + len(pdu.eventData) // without length bytes

        _ = binary.Write(buf, binary.LittleEndian, fpInputHeader)
        _ = pdu.SerializeLength(length, buf)
        buf.Write(pdu.eventData)

        return buf.Bytes()
}</span>

func (pdu *InputEventPDU) SerializeLength(value int, w io.Writer) error <span class="cov10" title="14">{
        if value &gt; 0x7f </span><span class="cov1" title="1">{
                value += 2 // 2 bytes length

                return binary.Write(w, binary.BigEndian, uint16(value|0x8000))
        }</span>

        <span class="cov9" title="13">value += 1 // 1 byte length
        if _, err := w.Write([]byte{uint8(value)}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="13">return nil</span>
}

func (i *Protocol) Send(pdu *InputEventPDU) error <span class="cov7" title="6">{
        data := pdu.Serialize()

        _, err := i.conn.Write(data)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package fastpath

import (
        "encoding/binary"
        "io"
)

// Surface command types
const (
        CmdTypeSurfaceBits       uint16 = 0x0001
        CmdTypeFrameMarker       uint16 = 0x0004
        CmdTypeStreamSurfaceBits uint16 = 0x0006
)

// Frame marker action
const (
        FrameStart uint16 = 0x0000
        FrameEnd   uint16 = 0x0001
)

// SurfaceCommand represents a surface command PDU
type SurfaceCommand struct {
        CmdType uint16
        Data    []byte
}

// SetSurfaceBitsCommand represents CMDTYPE_SET_SURFACE_BITS
type SetSurfaceBitsCommand struct {
        DestLeft   uint16
        DestTop    uint16
        DestRight  uint16
        DestBottom uint16
        BPP        uint8
        Flags      uint8
        Reserved   uint8
        CodecID    uint8
        Width      uint16
        Height     uint16
        BitmapData []byte
}

// FrameMarkerCommand represents CMDTYPE_FRAME_MARKER
type FrameMarkerCommand struct {
        FrameAction uint16
        FrameID     uint32
}

// ParseSurfaceCommands parses surface commands from the data section of a fastpath update
func ParseSurfaceCommands(data []byte) ([]SurfaceCommand, error) <span class="cov9" title="10">{
        var commands []SurfaceCommand
        offset := 0

        for offset &lt; len(data) </span><span class="cov10" title="13">{
                if offset+2 &gt; len(data) </span><span class="cov1" title="1">{
                        break</span>
                }

                <span class="cov9" title="12">cmdType := binary.LittleEndian.Uint16(data[offset:])
                offset += 2

                var cmd SurfaceCommand
                cmd.CmdType = cmdType

                switch cmdType </span>{
                case CmdTypeSurfaceBits, CmdTypeStreamSurfaceBits:<span class="cov5" title="4">
                        // SetSurfaceBits/StreamSurfaceBits structure:
                        // cmdType (2) + destLeft (2) + destTop (2) + destRight (2) + destBottom (2)
                        // + bpp (1) + flags (1) + reserved (1) + codecID (1) + width (2) + height (2)
                        // + bitmapDataLength (4) + bitmapData (variable)
                        if offset+20 &gt; len(data) </span><span class="cov3" title="2">{
                                break</span>
                        }

                        // Skip to bitmapDataLength (offset + 16 bytes)
                        <span class="cov3" title="2">bitmapDataLengthOffset := offset + 16
                        if bitmapDataLengthOffset+4 &gt; len(data) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov3" title="2">bitmapDataLength := binary.LittleEndian.Uint32(data[bitmapDataLengthOffset:])

                        // Total command data size (excluding cmdType)
                        cmdDataSize := 20 + int(bitmapDataLength)
                        if offset+cmdDataSize &gt; len(data) </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov3" title="2">cmd.Data = data[offset : offset+cmdDataSize]
                        offset += cmdDataSize</span>

                case CmdTypeFrameMarker:<span class="cov5" title="4">
                        // FrameMarker structure: cmdType (2) + frameAction (2) + frameId (4)
                        if offset+6 &gt; len(data) </span><span class="cov1" title="1">{
                                break</span>
                        }
                        <span class="cov4" title="3">cmd.Data = data[offset : offset+6]
                        offset += 6</span>

                default:<span class="cov5" title="4">
                        // Unknown command, skip remaining data
                        cmd.Data = data[offset:]
                        offset = len(data)</span>
                }

                <span class="cov9" title="12">commands = append(commands, cmd)</span>
        }

        <span class="cov9" title="10">return commands, nil</span>
}

// ParseSetSurfaceBits parses a SetSurfaceBits command
func ParseSetSurfaceBits(data []byte) (*SetSurfaceBitsCommand, error) <span class="cov4" title="3">{
        if len(data) &lt; 20 </span><span class="cov1" title="1">{
                return nil, io.ErrUnexpectedEOF
        }</span>

        <span class="cov3" title="2">cmd := &amp;SetSurfaceBitsCommand{
                DestLeft:   binary.LittleEndian.Uint16(data[0:2]),
                DestTop:    binary.LittleEndian.Uint16(data[2:4]),
                DestRight:  binary.LittleEndian.Uint16(data[4:6]),
                DestBottom: binary.LittleEndian.Uint16(data[6:8]),
                BPP:        data[8],
                Flags:      data[9],
                Reserved:   data[10],
                CodecID:    data[11],
                Width:      binary.LittleEndian.Uint16(data[12:14]),
                Height:     binary.LittleEndian.Uint16(data[14:16]),
        }

        bitmapDataLength := binary.LittleEndian.Uint32(data[16:20])
        if len(data) &lt; 20+int(bitmapDataLength) </span><span class="cov1" title="1">{
                return nil, io.ErrUnexpectedEOF
        }</span>

        <span class="cov1" title="1">cmd.BitmapData = data[20 : 20+bitmapDataLength]
        return cmd, nil</span>
}

// ParseFrameMarker parses a FrameMarker command
func ParseFrameMarker(data []byte) (*FrameMarkerCommand, error) <span class="cov4" title="3">{
        if len(data) &lt; 6 </span><span class="cov1" title="1">{
                return nil, io.ErrUnexpectedEOF
        }</span>

        <span class="cov3" title="2">return &amp;FrameMarkerCommand{
                FrameAction: binary.LittleEndian.Uint16(data[0:2]),
                FrameID:     binary.LittleEndian.Uint32(data[2:6]),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package fastpath

import (
        "encoding/binary"
        "io"
)

type PaletteEntry struct {
        Red   uint8
        Green uint8
        Blue  uint8
}

func (e *PaletteEntry) Deserialize(wire io.Reader) error <span class="cov10" title="5">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;e.Red)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov8" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;e.Green)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;e.Blue)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="3">return nil</span>
}

type paletteUpdateData struct {
        PaletteEntries []PaletteEntry
}

func (d *paletteUpdateData) Deserialize(wire io.Reader) error <span class="cov7" title="3">{
        var err error

        var updateType uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;updateType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="2">var numberColors uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;numberColors)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">d.PaletteEntries = make([]PaletteEntry, numberColors)

        for i := 0; i &lt; len(d.PaletteEntries); i++ </span><span class="cov4" title="2">{
                err = d.PaletteEntries[i].Deserialize(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="2">return nil</span>
}

type CompressedDataHeader struct {
        CbCompMainBodySize uint16
        CbScanWidth        uint16
        CbUncompressedSize uint16
}

func (h *CompressedDataHeader) Deserialize(wire io.Reader) error <span class="cov4" title="2">{
        var err error

        var cbCompFirstRowSize uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;cbCompFirstRowSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">err = binary.Read(wire, binary.LittleEndian, &amp;h.CbCompMainBodySize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">err = binary.Read(wire, binary.LittleEndian, &amp;h.CbScanWidth)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;h.CbUncompressedSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type BitmapDataFlag uint16

const (
        // BitmapDataFlagCompression BITMAP_COMPRESSION
        BitmapDataFlagCompression BitmapDataFlag = 0x0001

        // BitmapDataFlagNoHDR NO_BITMAP_COMPRESSION_HDR
        BitmapDataFlagNoHDR BitmapDataFlag = 0x0400
)

type BitmapData struct {
        DestLeft         uint16
        DestTop          uint16
        DestRight        uint16
        DestBottom       uint16
        Width            uint16
        Height           uint16
        BitsPerPixel     uint16
        Flags            BitmapDataFlag
        BitmapLength     uint16
        BitmapComprHdr   *CompressedDataHeader
        BitmapDataStream []byte
}

func (d *BitmapData) Deserialize(wire io.Reader) error <span class="cov8" title="4">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;d.DestLeft)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;d.DestTop)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;d.DestRight)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="3">err = binary.Read(wire, binary.LittleEndian, &amp;d.DestBottom)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">err = binary.Read(wire, binary.LittleEndian, &amp;d.Width)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">err = binary.Read(wire, binary.LittleEndian, &amp;d.Height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">err = binary.Read(wire, binary.LittleEndian, &amp;d.BitsPerPixel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">err = binary.Read(wire, binary.LittleEndian, &amp;d.Flags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">err = binary.Read(wire, binary.LittleEndian, &amp;d.BitmapLength)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">if d.Flags&amp;BitmapDataFlagNoHDR != BitmapDataFlagNoHDR &amp;&amp; d.Flags&amp;BitmapDataFlagCompression == BitmapDataFlagCompression </span><span class="cov0" title="0">{
                err = d.BitmapComprHdr.Deserialize(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">d.BitmapLength -= 8</span>
        }

        <span class="cov7" title="3">d.BitmapDataStream = make([]byte, d.BitmapLength)

        _, err = wire.Read(d.BitmapDataStream)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">return nil</span>
}

type bitmapUpdateData struct {
        Rectangles []BitmapData
}

func (d *bitmapUpdateData) Deserialize(wire io.Reader) error <span class="cov7" title="3">{
        var err error

        var updateType uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;updateType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">var numberRectangles uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;numberRectangles)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="2">d.Rectangles = make([]BitmapData, numberRectangles)

        for i := range d.Rectangles </span><span class="cov1" title="1">{
                err = d.Rectangles[i].Deserialize(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="2">return nil</span>
}

type pointerPositionUpdateData struct {
        xPos uint16
        yPos uint16
}

func (d *pointerPositionUpdateData) Deserialize(wire io.Reader) error <span class="cov7" title="3">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;d.xPos)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">err = binary.Read(wire, binary.LittleEndian, &amp;d.yPos)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="2">return nil</span>
}

type colorPointerUpdateData struct {
        cacheIndex    uint16
        xPos          uint16
        yPos          uint16
        width         uint16
        height        uint16
        lengthAndMask uint16
        lengthXorMask uint16
        xorMaskData   []byte
        andMaskData   []byte
}

func (d *colorPointerUpdateData) Deserialize(wire io.Reader) error <span class="cov7" title="3">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;d.cacheIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">err = binary.Read(wire, binary.LittleEndian, &amp;d.xPos)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">err = binary.Read(wire, binary.LittleEndian, &amp;d.yPos)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="2">err = binary.Read(wire, binary.LittleEndian, &amp;d.width)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">err = binary.Read(wire, binary.LittleEndian, &amp;d.height)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">err = binary.Read(wire, binary.LittleEndian, &amp;d.lengthAndMask)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">err = binary.Read(wire, binary.LittleEndian, &amp;d.lengthXorMask)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">if d.lengthXorMask &gt; 0 </span><span class="cov1" title="1">{
                d.xorMaskData = make([]byte, d.lengthXorMask)
                _, err = wire.Read(d.xorMaskData)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="2">if d.lengthAndMask &gt; 0 </span><span class="cov1" title="1">{
                d.andMaskData = make([]byte, d.lengthAndMask)
                _, err = wire.Read(d.andMaskData)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="2">var padding uint8

        return binary.Read(wire, binary.LittleEndian, &amp;padding)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package gcc

import (
        "bytes"

        "github.com/rcarmo/rdp-html5/internal/protocol/encoding"
)

var (
        t124_02_98_oid = [6]byte{0, 0, 20, 124, 0, 1}
        h221CSKey      = "Duca"
        h221SCKey      = "McDn"
)

type ConferenceCreateRequest struct {
        UserData []byte
}

func NewConferenceCreateRequest(userData []byte) *ConferenceCreateRequest <span class="cov10" title="9">{
        return &amp;ConferenceCreateRequest{
                UserData: userData,
        }
}</span>

func (r *ConferenceCreateRequest) Serialize() []byte <span class="cov10" title="9">{
        buf := new(bytes.Buffer)

        encoding.PerWriteChoice(0, buf)
        encoding.PerWriteObjectIdentifier(t124_02_98_oid, buf)
        encoding.PerWriteLength(uint16(14+len(r.UserData)), buf)

        encoding.PerWriteChoice(0, buf)
        encoding.PerWriteSelection(0x08, buf)

        encoding.PerWriteNumericString("1", 1, buf)
        encoding.PerWritePadding(1, buf)
        encoding.PerWriteNumberOfSet(1, buf)
        encoding.PerWriteChoice(0xc0, buf)
        encoding.PerWriteOctetStream(h221CSKey, 4, buf)
        encoding.PerWriteOctetStream(string(r.UserData), 0, buf)

        return buf.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package gcc

import (
        "errors"
        "io"

        "github.com/rcarmo/rdp-html5/internal/protocol/encoding"
)

type ConferenceCreateResponse struct{}

func (r *ConferenceCreateResponse) Deserialize(wire io.Reader) error <span class="cov10" title="11">{
        _, err := encoding.PerReadChoice(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="10">var objectIdentifier bool

        objectIdentifier, err = encoding.PerReadObjectIdentifier(t124_02_98_oid, wire)
        if err != nil </span><span class="cov7" title="5">{
                return err
        }</span>

        <span class="cov7" title="5">if !objectIdentifier </span><span class="cov3" title="2">{
                return errors.New("bad object identifier t124")
        }</span>

        <span class="cov5" title="3">_, err = encoding.PerReadLength(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="3">_, err = encoding.PerReadChoice(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="3">_, err = encoding.PerReadInteger16(1001, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="3">_, err = encoding.PerReadInteger(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="3">_, err = encoding.PerReadEnumerates(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="3">_, err = encoding.PerReadNumberOfSet(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="3">_, err = encoding.PerReadChoice(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="3">var octetStream bool

        octetStream, err = encoding.PerReadOctetStream([]byte(h221SCKey), 4, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="3">if !octetStream </span><span class="cov1" title="1">{
                return errors.New("bad H221 SC_KEY")
        }</span>

        <span class="cov3" title="2">_, err = encoding.PerReadLength(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package mcs

import (
        "fmt"
        "io"

        "github.com/rcarmo/rdp-html5/internal/protocol/encoding"
)

type ClientAttachUserRequest struct{}

func (pdu *ClientAttachUserRequest) Serialize() []byte <span class="cov9" title="8">{
        // empty structure in T.125, section 7, page 18
        return nil
}</span>

type ServerAttachUserConfirm struct {
        Result    uint8
        Initiator uint16
}

func (pdu *ServerAttachUserConfirm) Deserialize(wire io.Reader) error <span class="cov10" title="9">{
        var err error

        pdu.Result, err = encoding.PerReadEnumerates(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="8">pdu.Initiator, err = encoding.PerReadInteger16(1001, wire)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov8" title="6">return nil</span>
}

func (p *Protocol) AttachUser() (uint16, error) <span class="cov7" title="5">{
        req := DomainPDU{
                Application:             attachUserRequest,
                ClientAttachUserRequest: &amp;ClientAttachUserRequest{},
        }

        if err := p.x224Conn.Send(req.Serialize()); err != nil </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("client MCS attach user request: %w", err)
        }</span>

        <span class="cov6" title="4">wire, err := p.x224Conn.Receive()
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov5" title="3">var resp DomainPDU
        if err = resp.Deserialize(wire); err != nil </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("server MCS attach user confirm reponse: %w", err)
        }</span>

        <span class="cov3" title="2">if resp.ServerAttachUserConfirm.Result != RTSuccessful </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("unsuccessful MCS attach user; result=%d", resp.ServerAttachUserConfirm.Result)
        }</span>

        <span class="cov1" title="1">return resp.ServerAttachUserConfirm.Initiator, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package mcs

import (
        "bytes"
        "errors"
        "fmt"
        "io"

        "github.com/rcarmo/rdp-html5/internal/protocol/encoding"
        "github.com/rcarmo/rdp-html5/internal/protocol/gcc"
)

type ConnectPDUApplication uint8

const (
        connectInitial ConnectPDUApplication = iota + 101
        connectResponse
        connectAdditional
        connectResult
)

type ConnectPDU struct {
        Application           ConnectPDUApplication
        ClientConnectInitial  *ClientConnectInitial
        ServerConnectResponse *ServerConnectResponse
}

func (pdu *ConnectPDU) Serialize() []byte <span class="cov8" title="7">{
        var data []byte

        switch pdu.Application </span>{
        case connectInitial:<span class="cov8" title="7">
                data = pdu.ClientConnectInitial.Serialize()</span>
        }

        <span class="cov8" title="7">buf := new(bytes.Buffer)

        encoding.BerWriteApplicationTag(uint8(pdu.Application), len(data), buf)
        buf.Write(data)

        return buf.Bytes()</span>
}

func (pdu *ConnectPDU) Deserialize(wire io.Reader) error <span class="cov8" title="7">{
        var (
                application uint8
                err         error
        )

        application, err = encoding.BerReadApplicationTag(wire)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>
        <span class="cov7" title="5">pdu.Application = ConnectPDUApplication(application)

        _, err = encoding.BerReadLength(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="4">switch pdu.Application </span>{
        case connectResponse:<span class="cov5" title="3">
                pdu.ServerConnectResponse = &amp;ServerConnectResponse{}

                return pdu.ServerConnectResponse.Deserialize(wire)</span>
        }

        <span class="cov1" title="1">return fmt.Errorf("%w: application=%v", ErrUnknownConnectApplication, pdu.Application)</span>
}

type ClientConnectInitial struct {
        calledDomainSelector  []byte
        callingDomainSelector []byte
        upwardFlag            bool
        targetParameters      domainParameters
        minimumParameters     domainParameters
        maximumParameters     domainParameters
        userData              *gcc.ConferenceCreateRequest
}

func NewClientMCSConnectInitial(userData []byte) *ClientConnectInitial <span class="cov10" title="9">{
        pdu := ClientConnectInitial{
                calledDomainSelector:  []byte{0x01},
                callingDomainSelector: []byte{0x01},
                upwardFlag:            true,
                targetParameters: domainParameters{
                        maxChannelIds:   34,
                        maxUserIds:      2,
                        maxTokenIds:     0,
                        numPriorities:   1,
                        minThroughput:   0,
                        maxHeight:       1,
                        maxMCSPDUsize:   65535,
                        protocolVersion: 2,
                },
                minimumParameters: domainParameters{
                        maxChannelIds:   1,
                        maxUserIds:      1,
                        maxTokenIds:     1,
                        numPriorities:   1,
                        minThroughput:   0,
                        maxHeight:       1,
                        maxMCSPDUsize:   1056,
                        protocolVersion: 2,
                },
                maximumParameters: domainParameters{
                        maxChannelIds:   65535,
                        maxUserIds:      65535,
                        maxTokenIds:     65535,
                        numPriorities:   1,
                        minThroughput:   0,
                        maxHeight:       1,
                        maxMCSPDUsize:   65535,
                        protocolVersion: 2,
                },
                userData: gcc.NewConferenceCreateRequest(userData),
        }

        return &amp;pdu
}</span>

func (pdu *ClientConnectInitial) Serialize() []byte <span class="cov9" title="8">{
        buf := new(bytes.Buffer)

        encoding.BerWriteOctetString(pdu.calledDomainSelector, buf)
        encoding.BerWriteOctetString(pdu.callingDomainSelector, buf)
        encoding.BerWriteBoolean(pdu.upwardFlag, buf)
        encoding.BerWriteSequence(pdu.targetParameters.Serialize(), buf)
        encoding.BerWriteSequence(pdu.minimumParameters.Serialize(), buf)
        encoding.BerWriteSequence(pdu.maximumParameters.Serialize(), buf)
        encoding.BerWriteOctetString(pdu.userData.Serialize(), buf)

        return buf.Bytes()
}</span>

type ServerConnectResponse struct {
        Result           uint8
        calledConnectId  int
        DomainParameters domainParameters
        UserData         gcc.ConferenceCreateResponse
}

func (pdu *ServerConnectResponse) Deserialize(wire io.Reader) error <span class="cov8" title="7">{
        var err error

        pdu.Result, err = encoding.BerReadEnumerated(wire)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov7" title="5">pdu.calledConnectId, err = encoding.BerReadInteger(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="4">universalTag, err := encoding.BerReadUniversalTag(encoding.TagSequence, true, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="4">if !universalTag </span><span class="cov1" title="1">{
                return errors.New("bad BER tags")
        }</span>

        <span class="cov5" title="3">_, err = encoding.BerReadLength(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="3">err = pdu.DomainParameters.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="3">universalTag, err = encoding.BerReadUniversalTag(encoding.TagOctetString, false, wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="3">if !universalTag </span><span class="cov0" title="0">{
                return errors.New("invalid expected BER tag")
        }</span>

        <span class="cov5" title="3">_, err = encoding.BerReadLength(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="3">return pdu.UserData.Deserialize(wire)</span>
}

func (p *Protocol) Connect(userData []byte) (io.Reader, error) <span class="cov7" title="5">{
        req := ConnectPDU{
                Application:          connectInitial,
                ClientConnectInitial: NewClientMCSConnectInitial(userData),
        }

        if err := p.x224Conn.Send(req.Serialize()); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("client MCS connect initial request: %w", err)
        }</span>

        <span class="cov6" title="4">wire, err := p.x224Conn.Receive()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="3">var resp ConnectPDU
        if err = resp.Deserialize(wire); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("server MCS connect response: %w", err)
        }</span>

        <span class="cov3" title="2">if resp.ServerConnectResponse.Result != RTSuccessful </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("unsuccessful MCS connect initial; result=%d", resp.ServerConnectResponse.Result)
        }</span>

        <span class="cov1" title="1">return wire, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package mcs

import (
        "fmt"
)

type ClientDisconnectUltimatumRequest struct{}

func (pdu *ClientDisconnectUltimatumRequest) Serialize() []byte <span class="cov10" title="3">{
        // per aligned RNUserRequested
        return []byte{
                0x21,
                0x80,
        }
}</span>

func (p *Protocol) Disconnect() error <span class="cov6" title="2">{
        req := ClientDisconnectUltimatumRequest{}

        if err := p.x224Conn.Send(req.Serialize()); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("client MCS disconnect ultimatum: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package mcs

import (
        "bytes"
        "fmt"
        "io"

        "github.com/rcarmo/rdp-html5/internal/protocol/encoding"
)

type DomainPDUApplication uint8

const (
        plumbDomainIndication DomainPDUApplication = iota
        erectDomainRequest
        mergeChannelsRequest
        mergeChannelsConfirm
        purgeChannelsIndication
        mergeTokensRequest
        mergeTokensConfirm
        purgeTokensIndication
        disconnectProviderUltimatum
        rejectMCSPDUUltimatum
        attachUserRequest
        attachUserConfirm
        detachUserRequest
        detachUserIndication
        channelJoinRequest
        channelJoinConfirm
        channelLeaveRequest
        channelConveneRequest
        channelConveneConfirm
        channelDisbandRequest
        channelDisbandIndication
        channelAdmitRequest
        channelAdmitIndication
        channelExpelRequest
        channelExpelIndication
        SendDataRequest
        SendDataIndication
        uniformSendDataRequest
        uniformSendDataIndication
        tokenGrabRequest
        tokenGrabConfirm
        tokenInhibitRequest
        tokenInhibitConfirm
        tokenGiveRequest
        tokenGiveIndication
        tokenGiveResponse
        tokenGiveConfirm
        tokenPleaseRequest
        tokenPleaseIndication
        tokenReleaseRequest
        tokenReleaseConfirm
        tokenTestRequest
        tokenTestConfirm
)

type DomainPDU struct {
        Application DomainPDUApplication

        ClientErectDomainRequest *ClientErectDomainRequest
        ClientAttachUserRequest  *ClientAttachUserRequest
        ClientChannelJoinRequest *ClientChannelJoinRequest
        ClientSendDataRequest    *ClientSendDataRequest

        ServerAttachUserConfirm  *ServerAttachUserConfirm
        ServerChannelJoinConfirm *ServerChannelJoinConfirm
        ServerSendDataIndication *ServerSendDataIndication
}

func (pdu *DomainPDU) Serialize() []byte <span class="cov10" title="26">{
        buf := new(bytes.Buffer)

        encoding.PerWriteChoice(uint8(pdu.Application&lt;&lt;2), buf)

        var data []byte

        switch pdu.Application </span>{
        case attachUserRequest:<span class="cov6" title="7">
                data = pdu.ClientAttachUserRequest.Serialize()</span>
        case erectDomainRequest:<span class="cov4" title="4">
                data = pdu.ClientErectDomainRequest.Serialize()</span>
        case channelJoinRequest:<span class="cov7" title="11">
                data = pdu.ClientChannelJoinRequest.Serialize()</span>
        case SendDataRequest:<span class="cov4" title="4">
                data = pdu.ClientSendDataRequest.Serialize()</span>
        }

        <span class="cov10" title="26">buf.Write(data)

        return buf.Bytes()</span>
}

func (pdu *DomainPDU) Deserialize(wire io.Reader) error <span class="cov9" title="23">{
        var (
                application uint8
                err         error
        )

        application, err = encoding.PerReadChoice(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov9" title="22">pdu.Application = DomainPDUApplication(application &gt;&gt; 2)

        switch pdu.Application </span>{
        case attachUserConfirm:<span class="cov5" title="5">
                pdu.ServerAttachUserConfirm = &amp;ServerAttachUserConfirm{}

                return pdu.ServerAttachUserConfirm.Deserialize(wire)</span>
        case channelJoinConfirm:<span class="cov7" title="9">
                pdu.ServerChannelJoinConfirm = &amp;ServerChannelJoinConfirm{}

                return pdu.ServerChannelJoinConfirm.Deserialize(wire)</span>
        case SendDataIndication:<span class="cov4" title="3">
                pdu.ServerSendDataIndication = &amp;ServerSendDataIndication{}

                return pdu.ServerSendDataIndication.Deserialize(wire)</span>
        case SendDataRequest:<span class="cov1" title="1">
                pdu.ClientSendDataRequest = &amp;ClientSendDataRequest{}

                return pdu.ClientSendDataRequest.Deserialize(wire)</span>
        case disconnectProviderUltimatum:<span class="cov2" title="2">
                return ErrDisconnectUltimatum</span>
        }

        <span class="cov2" title="2">return fmt.Errorf("%w: application=%v", ErrUnknownDomainApplication, pdu.Application)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package mcs

import (
        "bytes"
        "fmt"

        "github.com/rcarmo/rdp-html5/internal/protocol/encoding"
)

type ClientErectDomainRequest struct{}

func (pdu *ClientErectDomainRequest) Serialize() []byte <span class="cov10" title="5">{
        buf := new(bytes.Buffer)

        encoding.PerWriteInteger(0, buf)
        encoding.PerWriteInteger(0, buf)

        return buf.Bytes()
}</span>

func (p *Protocol) ErectDomain() error <span class="cov4" title="2">{
        req := DomainPDU{
                Application:              erectDomainRequest,
                ClientErectDomainRequest: &amp;ClientErectDomainRequest{},
        }

        if err := p.x224Conn.Send(req.Serialize()); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("client MCS erect domain request: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package mcs

import (
        "bytes"
        "errors"
        "fmt"
        "io"

        "github.com/rcarmo/rdp-html5/internal/protocol/encoding"
)

type ClientChannelJoinRequest struct {
        Initiator uint16
        ChannelId uint16
}

func (pdu *ClientChannelJoinRequest) Serialize() []byte <span class="cov9" title="13">{
        buf := new(bytes.Buffer)

        encoding.PerWriteInteger16(pdu.Initiator, 1001, buf)
        encoding.PerWriteInteger16(pdu.ChannelId, 0, buf)

        return buf.Bytes()
}</span>

type ServerChannelJoinConfirm struct {
        Result    uint8
        Initiator uint16
        Requested uint16
        ChannelId uint16
}

func (pdu *ServerChannelJoinConfirm) Deserialize(wire io.Reader) error <span class="cov10" title="14">{
        var err error

        pdu.Result, err = encoding.PerReadEnumerates(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="13">pdu.Initiator, err = encoding.PerReadInteger16(1001, wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="12">pdu.Requested, err = encoding.PerReadInteger16(0, wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // optional
        <span class="cov9" title="11">pdu.ChannelId, err = encoding.PerReadInteger16(0, wire)
        switch </span>{
        case errors.Is(err, nil), // pass
                errors.Is(err, io.EOF):<span class="cov9" title="11"></span>
        default:<span class="cov0" title="0">
                return err</span>
        }

        <span class="cov9" title="11">return nil</span>
}

func (p *Protocol) JoinChannels(userID uint16, channelIDMap map[string]uint16) error <span class="cov7" title="6">{
        if len(channelIDMap) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov6" title="5">for channelName, channelID := range channelIDMap </span><span class="cov7" title="7">{
                req := DomainPDU{
                        Application: channelJoinRequest,
                        ClientChannelJoinRequest: &amp;ClientChannelJoinRequest{
                                Initiator: userID,
                                ChannelId: channelID,
                        },
                }

                if err := p.x224Conn.Send(req.Serialize()); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("client MCS channel join request for channel=%s: %w", channelName, err)
                }</span>

                <span class="cov7" title="6">wire, err := p.x224Conn.Receive()
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="5">var resp DomainPDU
                if err = resp.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server MCS channel join confirm reponse: %w", err)
                }</span>

                <span class="cov6" title="5">if resp.ServerChannelJoinConfirm.Result != RTSuccessful </span><span class="cov1" title="1">{
                        return fmt.Errorf(
                                "unsuccessful MCS channel join confirm for channel=%s; result=%d",
                                channelName,
                                resp.ServerChannelJoinConfirm.Result,
                        )
                }</span>
        }

        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package mcs

import "github.com/rcarmo/rdp-html5/internal/protocol/x224"

type Protocol struct {
        x224Conn x224Conn
}

func New(x224Conn *x224.Protocol) *Protocol <span class="cov0" title="0">{
        return &amp;Protocol{
                x224Conn: x224Conn,
        }
}</span>

// newWithConn creates a Protocol with a custom x224Conn (for testing)
func newWithConn(conn x224Conn) *Protocol <span class="cov10" title="23">{
        return &amp;Protocol{
                x224Conn: conn,
        }
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package mcs

import (
        "io"

        "github.com/rcarmo/rdp-html5/internal/protocol/encoding"
)

type ServerSendDataIndication struct {
        Initiator uint16
        ChannelId uint16
}

func (d *ServerSendDataIndication) Deserialize(wire io.Reader) error <span class="cov10" title="9">{
        var err error

        d.Initiator, err = encoding.PerReadInteger16(1001, wire)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov8" title="7">d.ChannelId, err = encoding.PerReadInteger16(0, wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov8" title="6">_, err = encoding.PerReadEnumerates(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="5">_, err = encoding.PerReadLength(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="4">return nil</span>
}

// Receive returns channelName, reader or error
func (p *Protocol) Receive() (uint16, io.Reader, error) <span class="cov7" title="5">{
        wire, err := p.x224Conn.Receive()
        if err != nil </span><span class="cov1" title="1">{
                return 0, nil, err
        }</span>

        <span class="cov6" title="4">var resp DomainPDU
        if err = resp.Deserialize(wire); err != nil </span><span class="cov5" title="3">{
                return 0, nil, err
        }</span>

        <span class="cov1" title="1">if resp.Application != SendDataIndication </span><span class="cov0" title="0">{
                // Log what we actually received for debugging
                if resp.Application == disconnectProviderUltimatum </span><span class="cov0" title="0">{
                        return 0, nil, ErrDisconnectUltimatum
                }</span>
                <span class="cov0" title="0">return 0, nil, ErrUnknownDomainApplication</span>
        }

        <span class="cov1" title="1">return resp.ServerSendDataIndication.ChannelId, wire, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package mcs

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"

        "github.com/rcarmo/rdp-html5/internal/protocol/encoding"
)

type ClientSendDataRequest struct {
        Initiator uint16
        ChannelId uint16
        Data      []byte
}

func (d *ClientSendDataRequest) Serialize() []byte <span class="cov10" title="7">{
        buf := new(bytes.Buffer)

        encoding.PerWriteInteger16(d.Initiator, 1001, buf)
        encoding.PerWriteInteger16(d.ChannelId, 0, buf)
        buf.WriteByte(0x70) // magic word
        encoding.PerWriteLength(uint16(len(d.Data)), buf)

        buf.Write(d.Data)

        return buf.Bytes()
}</span>

func (d *ClientSendDataRequest) Deserialize(wire io.Reader) error <span class="cov9" title="6">{
        var err error

        d.Initiator, err = encoding.PerReadInteger16(1001, wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov8" title="5">d.ChannelId, err = encoding.PerReadInteger16(0, wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="4">var magic uint8
        err = binary.Read(wire, binary.LittleEndian, &amp;magic)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="3">_, err = encoding.PerReadLength(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (p *Protocol) Send(userID, channelID uint16, pduData []byte) error <span class="cov6" title="3">{
        req := DomainPDU{
                Application: SendDataRequest,
                ClientSendDataRequest: &amp;ClientSendDataRequest{
                        Initiator: userID,
                        ChannelId: channelID,
                        Data:      pduData,
                },
        }

        if err := p.x224Conn.Send(req.Serialize()); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("client MCS send data request: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package mcs

import (
        "bytes"
        "io"

        "github.com/rcarmo/rdp-html5/internal/protocol/encoding"
)

const (
        RTSuccessful uint8 = iota
        RTDomainMerging
        RTDomainNotHierarchical
        RTNoSuchChannel
        RTNoSuchDomain
        RTNoSuchUser
        RTNotAdmitted
        RTOtherUserId
        RTParametersUnacceptable
        RTTokenNotAvailable
        RTTokenNotPossessed
        RTTooManyChannels
        RTTooManyTokens
        RTTooManyUsers
        RTUnspecifiedFailure
        RTUserRejected
)

const (
        RNDomainDisconnected uint8 = iota
        RNProviderInitiated
        RNTokenPurged
        RNUserRequested
        RNChannelPurged
)

type domainParameters struct {
        maxChannelIds   int
        maxUserIds      int
        maxTokenIds     int
        numPriorities   int
        minThroughput   int
        maxHeight       int
        maxMCSPDUsize   int
        protocolVersion int
}

func (params *domainParameters) Serialize() []byte <span class="cov10" title="26">{
        buf := new(bytes.Buffer)

        encoding.BerWriteInteger(params.maxChannelIds, buf)
        encoding.BerWriteInteger(params.maxUserIds, buf)
        encoding.BerWriteInteger(params.maxTokenIds, buf)
        encoding.BerWriteInteger(params.numPriorities, buf)
        encoding.BerWriteInteger(params.minThroughput, buf)
        encoding.BerWriteInteger(params.maxHeight, buf)
        encoding.BerWriteInteger(params.maxMCSPDUsize, buf)
        encoding.BerWriteInteger(params.protocolVersion, buf)

        return buf.Bytes()
}</span>

func (params *domainParameters) Deserialize(wire io.Reader) error <span class="cov7" title="12">{
        var err error

        params.maxChannelIds, err = encoding.BerReadInteger(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="11">params.maxUserIds, err = encoding.BerReadInteger(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="10">params.maxTokenIds, err = encoding.BerReadInteger(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="9">params.numPriorities, err = encoding.BerReadInteger(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="8">params.minThroughput, err = encoding.BerReadInteger(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="7">params.maxHeight, err = encoding.BerReadInteger(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov5" title="6">params.maxMCSPDUsize, err = encoding.BerReadInteger(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov5" title="5">params.protocolVersion, err = encoding.BerReadInteger(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="4">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "errors"
        "io"

        "github.com/rcarmo/rdp-html5/internal/codec"
)

const (
        rdpVersion5Plus             = 0x00080004
        keyboardTypeIBM101or102Keys = 0x00000004
        projectName                 = "rdp-html5"
)

// earlyCapabilityFlags
const (
        ECFSupportErrInfoPDU        uint16 = 0x0001
        ECFWant32BPPSession         uint16 = 0x0002
        ECFSupportStatusInfoPDU     uint16 = 0x0004
        ECFStrongAsymmetricKeys     uint16 = 0x0008
        ECFUnused                   uint16 = 0x0010
        ECFValidConnectionType      uint16 = 0x0020
        ECFSupportMonitorLayoutPDU  uint16 = 0x0040
        ECFSupportNetCharAutodetect uint16 = 0x0080
        ECFSupportDynvcGFXProtocol  uint16 = 0x0100
        ECFSupportDynamicTimeZone   uint16 = 0x0200
        ECFSupportHeartbeatPDU      uint16 = 0x0400
)

type ClientCoreData struct {
        Version                uint32
        DesktopWidth           uint16
        DesktopHeight          uint16
        ColorDepth             uint16
        SASSequence            uint16
        KeyboardLayout         uint32
        ClientBuild            uint32
        ClientName             [32]byte
        KeyboardType           uint32
        KeyboardSubType        uint32
        KeyboardFunctionKey    uint32
        ImeFileName            [64]byte
        PostBeta2ColorDepth    uint16
        ClientProductId        uint16
        SerialNumber           uint32
        HighColorDepth         uint16
        SupportedColorDepths   uint16
        EarlyCapabilityFlags   uint16
        ClientDigProductId     [64]byte
        ConnectionType         uint8
        Pad1octet              uint8
        ServerSelectedProtocol uint32
        // Optional extended fields (MS-RDPBCGR 2.2.1.3.2)
        DesktopPhysicalWidth  uint32
        DesktopPhysicalHeight uint32
        DesktopOrientation    uint16
        DesktopScaleFactor    uint32
        DeviceScaleFactor     uint32
}

// Color depth constants from MS-RDPBCGR
const (
        // HighColorDepth values
        HighColor4BPP  uint16 = 0x0004
        HighColor8BPP  uint16 = 0x0008
        HighColor15BPP uint16 = 0x000F
        HighColor16BPP uint16 = 0x0010
        HighColor24BPP uint16 = 0x0018

        // SupportedColorDepths flags
        RNS_UD_24BPP_SUPPORT uint16 = 0x0001
        RNS_UD_16BPP_SUPPORT uint16 = 0x0002
        RNS_UD_15BPP_SUPPORT uint16 = 0x0004
        RNS_UD_32BPP_SUPPORT uint16 = 0x0008
)

func newClientCoreData(selectedProtocol uint32, desktopWidth, desktopHeight uint16, colorDepth int) *ClientCoreData <span class="cov6" title="5">{
        // Set color depth values based on requested depth
        var highColorDepth uint16
        var supportedColorDepths uint16
        earlyCapabilityFlags := ECFSupportErrInfoPDU

        switch colorDepth </span>{
        case 32:<span class="cov1" title="1">
                highColorDepth = HighColor24BPP // 32-bit uses 24-bit high color + ECFWant32BPPSession flag
                supportedColorDepths = RNS_UD_32BPP_SUPPORT | RNS_UD_24BPP_SUPPORT | RNS_UD_16BPP_SUPPORT
                earlyCapabilityFlags |= ECFWant32BPPSession</span>
        case 24:<span class="cov3" title="2">
                highColorDepth = HighColor24BPP
                supportedColorDepths = RNS_UD_24BPP_SUPPORT | RNS_UD_16BPP_SUPPORT</span>
        case 15:<span class="cov0" title="0">
                highColorDepth = HighColor15BPP
                supportedColorDepths = RNS_UD_15BPP_SUPPORT | RNS_UD_16BPP_SUPPORT</span>
        case 8:<span class="cov0" title="0">
                highColorDepth = HighColor8BPP
                supportedColorDepths = RNS_UD_16BPP_SUPPORT</span> // Server may upgrade
        default:<span class="cov3" title="2"> // 16-bit
                highColorDepth = HighColor16BPP
                supportedColorDepths = RNS_UD_16BPP_SUPPORT</span>
        }

        <span class="cov6" title="5">data := ClientCoreData{
                Version:                rdpVersion5Plus,
                DesktopWidth:           desktopWidth,
                DesktopHeight:          desktopHeight,
                ColorDepth:             0xCA01,     // RNS_UD_COLOR_8BPP (ignored when HighColorDepth is set)
                SASSequence:            0xAA03,     // RNS_UD_SAS_DEL
                KeyboardLayout:         0x00000409, // US
                ClientBuild:            0xece,
                ClientName:             [32]byte{},
                KeyboardType:           keyboardTypeIBM101or102Keys,
                KeyboardSubType:        0x00000000,
                KeyboardFunctionKey:    12,
                ImeFileName:            [64]byte{},
                PostBeta2ColorDepth:    0xCA03, // RNS_UD_COLOR_16BPP_565 (ignored when HighColorDepth is set)
                ClientProductId:        0x0001,
                SerialNumber:           0x00000000,
                HighColorDepth:         highColorDepth,
                SupportedColorDepths:   supportedColorDepths,
                EarlyCapabilityFlags:   earlyCapabilityFlags,
                ClientDigProductId:     [64]byte{},
                ConnectionType:         0x00,
                Pad1octet:              0x00,
                ServerSelectedProtocol: selectedProtocol,
                // Physical dimensions (in millimeters) - assume standard 96 DPI monitor
                // desktopWidth pixels * 25.4mm/inch / 96 DPI
                DesktopPhysicalWidth:  uint32(float64(desktopWidth) * 25.4 / 96.0),
                DesktopPhysicalHeight: uint32(float64(desktopHeight) * 25.4 / 96.0),
                DesktopOrientation:    0,   // ORIENTATION_LANDSCAPE
                DesktopScaleFactor:    100, // 100% scaling
                DeviceScaleFactor:     100, // 100% scaling
        }

        copy(data.ClientName[:], codec.Encode(projectName))

        return &amp;data</span>
}

const (
        // EncryptionFlag40Bit ENCRYPTION_FLAG_40BIT
        EncryptionFlag40Bit uint32 = 0x00000001

        // EncryptionFlag128Bit ENCRYPTION_FLAG_128BIT
        EncryptionFlag128Bit uint32 = 0x00000002

        // EncryptionFlag56Bit ENCRYPTION_FLAG_56BIT
        EncryptionFlag56Bit uint32 = 0x00000008

        // FIPSEncryptionFlag FIPS_ENCRYPTION_FLAG
        FIPSEncryptionFlag uint32 = 0x00000010
)

type ClientSecurityData struct {
        EncryptionMethods    uint32
        ExtEncryptionMethods uint32
}

func newClientSecurityData() *ClientSecurityData <span class="cov6" title="5">{
        data := ClientSecurityData{
                EncryptionMethods:    0,
                ExtEncryptionMethods: 0,
        }

        return &amp;data
}</span>

type ChannelDefinitionStructure struct {
        Name    [8]byte // seven ANSI chars with null-termination char in the end
        Options uint32
}

type ClientNetworkData struct {
        ChannelCount    uint32
        ChannelDefArray []ChannelDefinitionStructure
}

type ClientClusterData struct {
        Flags               uint32
        RedirectedSessionID uint32
}

type ClientUserDataSet struct {
        ClientCoreData     *ClientCoreData
        ClientSecurityData *ClientSecurityData
        ClientNetworkData  *ClientNetworkData
        ClientClusterData  *ClientClusterData
}

func NewClientUserDataSet(selectedProtocol uint32,
        desktopWidth, desktopHeight uint16,
        colorDepth int,
        channelNames []string) *ClientUserDataSet <span class="cov6" title="5">{
        return &amp;ClientUserDataSet{
                ClientCoreData:     newClientCoreData(selectedProtocol, desktopWidth, desktopHeight, colorDepth),
                ClientSecurityData: newClientSecurityData(),
                ClientNetworkData:  newClientNetworkData(channelNames),
        }
}</span>

func (data ClientCoreData) Serialize() []byte <span class="cov5" title="4">{
        // Updated dataLen to include optional extended fields:
        // Base: 216 bytes (header + fields up to ServerSelectedProtocol)
        // + DesktopPhysicalWidth (4) + DesktopPhysicalHeight (4) + DesktopOrientation (2)
        // + DesktopScaleFactor (4) + DeviceScaleFactor (4) = 234 bytes
        const dataLen uint16 = 234

        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(0xC001)) // header type CS_CORE
        _ = binary.Write(buf, binary.LittleEndian, dataLen)        // packet size

        _ = binary.Write(buf, binary.LittleEndian, data.Version)
        _ = binary.Write(buf, binary.LittleEndian, data.DesktopWidth)
        _ = binary.Write(buf, binary.LittleEndian, data.DesktopHeight)
        _ = binary.Write(buf, binary.LittleEndian, data.ColorDepth)
        _ = binary.Write(buf, binary.LittleEndian, data.SASSequence)
        _ = binary.Write(buf, binary.LittleEndian, data.KeyboardLayout)
        _ = binary.Write(buf, binary.LittleEndian, data.ClientBuild)
        _ = binary.Write(buf, binary.LittleEndian, data.ClientName)
        _ = binary.Write(buf, binary.LittleEndian, data.KeyboardType)
        _ = binary.Write(buf, binary.LittleEndian, data.KeyboardSubType)
        _ = binary.Write(buf, binary.LittleEndian, data.KeyboardFunctionKey)
        _ = binary.Write(buf, binary.LittleEndian, data.ImeFileName)
        _ = binary.Write(buf, binary.LittleEndian, data.PostBeta2ColorDepth)
        _ = binary.Write(buf, binary.LittleEndian, data.ClientProductId)
        _ = binary.Write(buf, binary.LittleEndian, data.SerialNumber)
        _ = binary.Write(buf, binary.LittleEndian, data.HighColorDepth)
        _ = binary.Write(buf, binary.LittleEndian, data.SupportedColorDepths)
        _ = binary.Write(buf, binary.LittleEndian, data.EarlyCapabilityFlags)
        _ = binary.Write(buf, binary.LittleEndian, data.ClientDigProductId)
        _ = binary.Write(buf, binary.LittleEndian, data.ConnectionType)
        _ = binary.Write(buf, binary.LittleEndian, data.Pad1octet)
        _ = binary.Write(buf, binary.LittleEndian, data.ServerSelectedProtocol)
        // Optional extended fields (MS-RDPBCGR 2.2.1.3.2)
        _ = binary.Write(buf, binary.LittleEndian, data.DesktopPhysicalWidth)
        _ = binary.Write(buf, binary.LittleEndian, data.DesktopPhysicalHeight)
        _ = binary.Write(buf, binary.LittleEndian, data.DesktopOrientation)
        _ = binary.Write(buf, binary.LittleEndian, data.DesktopScaleFactor)
        _ = binary.Write(buf, binary.LittleEndian, data.DeviceScaleFactor)

        return buf.Bytes()
}</span>

const (
        // EncryptionMethodFlag40Bit 40BIT_ENCRYPTION_FLAG
        EncryptionMethodFlag40Bit uint32 = 0x00000001

        // EncryptionMethodFlag56Bit 56BIT_ENCRYPTION_FLAG
        EncryptionMethodFlag56Bit uint32 = 0x00000008

        // EncryptionMethodFlag128Bit 128BIT_ENCRYPTION_FLAG
        EncryptionMethodFlag128Bit uint32 = 0x00000002

        // EncryptionMethodFlagFIPS FIPS_ENCRYPTION_FLAG
        EncryptionMethodFlagFIPS uint32 = 0x00000010
)

func (data ClientSecurityData) Serialize() []byte <span class="cov5" title="4">{
        const dataLen uint16 = 12

        buf := bytes.NewBuffer(make([]byte, 0, 6))

        _ = binary.Write(buf, binary.LittleEndian, uint16(0xC002)) // header type CS_SECURITY
        _ = binary.Write(buf, binary.LittleEndian, dataLen)        // packet size

        _ = binary.Write(buf, binary.LittleEndian, data.EncryptionMethods)
        _ = binary.Write(buf, binary.LittleEndian, data.ExtEncryptionMethods)

        return buf.Bytes()
}</span>

func (s ChannelDefinitionStructure) Serialize() []byte <span class="cov5" title="4">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.Name)
        _ = binary.Write(buf, binary.LittleEndian, s.Options)

        return buf.Bytes()
}</span>

func newClientNetworkData(channelNames []string) *ClientNetworkData <span class="cov6" title="5">{
        data := ClientNetworkData{
                ChannelCount: uint32(len(channelNames)),
        }

        if data.ChannelCount == 0 </span><span class="cov5" title="4">{
                return &amp;data
        }</span>

        <span class="cov1" title="1">for _, channelName := range channelNames </span><span class="cov4" title="3">{
                channelDefinition := ChannelDefinitionStructure{}
                copy(channelDefinition.Name[:], channelName)

                data.ChannelDefArray = append(data.ChannelDefArray, channelDefinition)
        }</span>

        <span class="cov1" title="1">return &amp;data</span>
}

func (data ClientNetworkData) Serialize() []byte <span class="cov5" title="4">{
        const headerLen = 8

        chBuf := new(bytes.Buffer)

        for _, channelDef := range data.ChannelDefArray </span><span class="cov4" title="3">{
                chBuf.Write(channelDef.Serialize())
        }</span>

        <span class="cov5" title="4">buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(0xC003))                // header type CS_NET
        _ = binary.Write(buf, binary.LittleEndian, uint16(headerLen+chBuf.Len())) // packet size

        _ = binary.Write(buf, binary.LittleEndian, data.ChannelCount)

        buf.Write(chBuf.Bytes())

        return buf.Bytes()</span>
}

func (d ClientClusterData) Serialize() []byte <span class="cov1" title="1">{
        const dataLen uint16 = 12

        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(0xC004)) // header type CS_CLUSTER
        _ = binary.Write(buf, binary.LittleEndian, dataLen)        // packet size

        _ = binary.Write(buf, binary.LittleEndian, d.Flags)
        _ = binary.Write(buf, binary.LittleEndian, d.RedirectedSessionID)

        return buf.Bytes()
}</span>

func (ud ClientUserDataSet) Serialize() []byte <span class="cov5" title="4">{
        buf := new(bytes.Buffer)

        buf.Write(ud.ClientCoreData.Serialize())

        if ud.ClientClusterData != nil </span><span class="cov1" title="1">{
                buf.Write(ud.ClientClusterData.Serialize())
        }</span>

        <span class="cov5" title="4">buf.Write(ud.ClientSecurityData.Serialize())
        buf.Write(ud.ClientNetworkData.Serialize())

        return buf.Bytes()</span>
}

type ServerCoreData struct {
        Version                  uint32
        ClientRequestedProtocols uint32
        EarlyCapabilityFlags     uint32

        DataLen uint16
}

func (d *ServerCoreData) Deserialize(wire io.Reader) error <span class="cov6" title="5">{
        var err error

        if err = binary.Read(wire, binary.LittleEndian, &amp;d.Version); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="5">if d.DataLen == 4 </span><span class="cov4" title="3">{
                return nil
        }</span>

        <span class="cov3" title="2">if err = binary.Read(wire, binary.LittleEndian, &amp;d.ClientRequestedProtocols); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">if d.DataLen == 8 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov1" title="1">if err = binary.Read(wire, binary.LittleEndian, &amp;d.EarlyCapabilityFlags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type RSAPublicKey struct {
        Magic   uint32
        KeyLen  uint32
        BitLen  uint32
        DataLen uint32
        PubExp  uint32
        Modulus []byte
}

func (k *RSAPublicKey) Deserialize(wire io.Reader) error <span class="cov5" title="4">{
        var err error

        if err = binary.Read(wire, binary.LittleEndian, &amp;k.Magic); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">if err = binary.Read(wire, binary.LittleEndian, &amp;k.KeyLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">if err = binary.Read(wire, binary.LittleEndian, &amp;k.BitLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">if err = binary.Read(wire, binary.LittleEndian, &amp;k.DataLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">if err = binary.Read(wire, binary.LittleEndian, &amp;k.PubExp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">k.Modulus = make([]byte, k.KeyLen)

        if _, err = wire.Read(k.Modulus); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">return nil</span>
}

type ServerProprietaryCertificate struct {
        DwSigAlgId        uint32
        DwKeyAlgId        uint32
        PublicKeyBlobType uint16
        PublicKeyBlobLen  uint16
        PublicKeyBlob     RSAPublicKey
        SignatureBlobType uint16
        SignatureBlobLen  uint16
        SignatureBlob     []byte
}

func (c *ServerProprietaryCertificate) Deserialize(wire io.Reader) error <span class="cov4" title="3">{
        var err error

        if err = binary.Read(wire, binary.LittleEndian, &amp;c.DwSigAlgId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="3">if err = binary.Read(wire, binary.LittleEndian, &amp;c.DwKeyAlgId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="3">if err = binary.Read(wire, binary.LittleEndian, &amp;c.PublicKeyBlobType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="3">if err = binary.Read(wire, binary.LittleEndian, &amp;c.PublicKeyBlobLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="3">if err = c.PublicKeyBlob.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="3">if err = binary.Read(wire, binary.LittleEndian, &amp;c.SignatureBlobType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="3">if err = binary.Read(wire, binary.LittleEndian, &amp;c.SignatureBlobLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="3">c.SignatureBlob = make([]byte, c.SignatureBlobLen)

        if _, err = wire.Read(c.SignatureBlob); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="3">return nil</span>
}

type ServerCertificate struct {
        DwVersion       uint32
        ProprietaryCert *ServerProprietaryCertificate
        X509Cert        []byte

        ServerCertLen uint32
}

func (c *ServerCertificate) Deserialize(wire io.Reader) error <span class="cov4" title="3">{
        var err error

        if err = binary.Read(wire, binary.LittleEndian, &amp;c.DwVersion); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="3">if c.DwVersion&amp;0x00000001 == 0x00000001 </span><span class="cov3" title="2">{
                c.ProprietaryCert = &amp;ServerProprietaryCertificate{}

                return c.ProprietaryCert.Deserialize(wire)
        }</span>

        <span class="cov1" title="1">c.X509Cert = make([]byte, c.ServerCertLen-4)

        if _, err = wire.Read(c.X509Cert); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type ServerSecurityData struct {
        EncryptionMethod  uint32
        EncryptionLevel   uint32
        ServerRandomLen   uint32
        ServerCertLen     uint32
        ServerRandom      []byte
        ServerCertificate *ServerCertificate
}

func (d *ServerSecurityData) Deserialize(wire io.Reader) error <span class="cov5" title="4">{
        var err error

        if err = binary.Read(wire, binary.LittleEndian, &amp;d.EncryptionMethod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">if err = binary.Read(wire, binary.LittleEndian, &amp;d.EncryptionLevel); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">if d.EncryptionMethod == 0 &amp;&amp; d.EncryptionLevel == 0 </span><span class="cov3" title="2">{ // ENCRYPTION_METHOD_NONE and ENCRYPTION_LEVEL_NONE
                return nil
        }</span>

        <span class="cov3" title="2">if err = binary.Read(wire, binary.LittleEndian, &amp;d.ServerRandomLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">if err = binary.Read(wire, binary.LittleEndian, &amp;d.ServerCertLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">d.ServerRandom = make([]byte, d.ServerRandomLen)

        if _, err = wire.Read(d.ServerRandom); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">if d.ServerCertLen &gt; 0 </span><span class="cov1" title="1">{
                d.ServerCertificate = &amp;ServerCertificate{
                        ServerCertLen: d.ServerCertLen,
                }

                return d.ServerCertificate.Deserialize(wire)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type ServerNetworkData struct {
        MCSChannelId   uint16
        ChannelCount   uint16
        ChannelIdArray []uint16
}

func (d *ServerNetworkData) Deserialize(wire io.Reader) error <span class="cov6" title="5">{
        var err error

        if err = binary.Read(wire, binary.LittleEndian, &amp;d.MCSChannelId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="5">if err = binary.Read(wire, binary.LittleEndian, &amp;d.ChannelCount); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="5">if d.ChannelCount == 0 </span><span class="cov4" title="3">{
                return nil
        }</span>

        <span class="cov3" title="2">d.ChannelIdArray = make([]uint16, d.ChannelCount)

        if err = binary.Read(wire, binary.LittleEndian, &amp;d.ChannelIdArray); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">if d.ChannelCount%2 == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov1" title="1">padding := make([]byte, 2)

        if _, err = wire.Read(padding); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type ServerMessageChannelData struct {
        MCSChannelID uint16
}

type ServerMultitransportChannelData struct {
        Flags uint32
}

type ServerUserData struct {
        ServerCoreData                  *ServerCoreData
        ServerNetworkData               *ServerNetworkData
        ServerSecurityData              *ServerSecurityData
        ServerMessageChannelData        *ServerMessageChannelData
        ServerMultitransportChannelData *ServerMultitransportChannelData
}

func (ud *ServerUserData) Deserialize(wire io.Reader) error <span class="cov7" title="8">{
        var (
                dataType uint16
                dataLen  uint16
                err      error
        )

        for </span><span class="cov10" title="15">{
                err = binary.Read(wire, binary.LittleEndian, &amp;dataType)
                switch err </span>{
                case nil:<span class="cov7" title="8"></span> // pass
                case io.EOF:<span class="cov7" title="7">
                        return nil</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }

                <span class="cov7" title="8">err = binary.Read(wire, binary.LittleEndian, &amp;dataLen)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov7" title="8">dataLen -= 4 // exclude User Data Header

                switch dataType </span>{
                case 0x0C01:<span class="cov3" title="2">
                        ud.ServerCoreData = &amp;ServerCoreData{DataLen: dataLen}

                        if err = ud.ServerCoreData.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case 0x0C02:<span class="cov1" title="1">
                        ud.ServerSecurityData = &amp;ServerSecurityData{}

                        if err = ud.ServerSecurityData.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case 0x0C03:<span class="cov3" title="2">
                        ud.ServerNetworkData = &amp;ServerNetworkData{}

                        if err = ud.ServerNetworkData.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case 0x0C04:<span class="cov1" title="1">
                        ud.ServerMessageChannelData = &amp;ServerMessageChannelData{}

                        if err = binary.Read(wire, binary.LittleEndian, &amp;ud.ServerMessageChannelData.MCSChannelID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case 0x0C08:<span class="cov1" title="1">
                        ud.ServerMultitransportChannelData = &amp;ServerMultitransportChannelData{}

                        if err = binary.Read(wire, binary.LittleEndian, &amp;ud.ServerMultitransportChannelData.Flags); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov1" title="1">
                        return errors.New("unknown header type")</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
)

type BitmapCapabilitySet struct {
        PreferredBitsPerPixel uint16
        Receive1BitPerPixel   uint16
        Receive4BitsPerPixel  uint16
        Receive8BitsPerPixel  uint16
        DesktopWidth          uint16
        DesktopHeight         uint16
        DesktopResizeFlag     uint16
        DrawingFlags          uint8
}

func NewBitmapCapabilitySet(desktopWidth, desktopHeight uint16) CapabilitySet <span class="cov8" title="5">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeBitmap,
                BitmapCapabilitySet: &amp;BitmapCapabilitySet{
                        PreferredBitsPerPixel: 0x0020, // HIGH_COLOR_32BPP (32-bit color support)
                        Receive1BitPerPixel:   0x0001,
                        Receive4BitsPerPixel:  0x0001,
                        Receive8BitsPerPixel:  0x0001,
                        DesktopWidth:          desktopWidth,
                        DesktopHeight:         desktopHeight,
                        DesktopResizeFlag:     0x0001, // Support dynamic resizing
                },
        }
}</span>

func (s *BitmapCapabilitySet) Serialize() []byte <span class="cov10" title="7">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.PreferredBitsPerPixel)
        _ = binary.Write(buf, binary.LittleEndian, s.Receive1BitPerPixel)
        _ = binary.Write(buf, binary.LittleEndian, s.Receive4BitsPerPixel)
        _ = binary.Write(buf, binary.LittleEndian, s.Receive8BitsPerPixel)
        _ = binary.Write(buf, binary.LittleEndian, s.DesktopWidth)
        _ = binary.Write(buf, binary.LittleEndian, s.DesktopHeight)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // padding
        _ = binary.Write(buf, binary.LittleEndian, s.DesktopResizeFlag)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0001)) // bitmapCompressionFlag
        _ = binary.Write(buf, binary.LittleEndian, uint8(0))       // highColorFlags
        _ = binary.Write(buf, binary.LittleEndian, s.DrawingFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0001)) // multipleRectangleSupport
        _ = binary.Write(buf, binary.LittleEndian, uint16(0))      // padding

        return buf.Bytes()
}</span>

func (s *BitmapCapabilitySet) Deserialize(wire io.Reader) error <span class="cov8" title="5">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.PreferredBitsPerPixel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.Receive1BitPerPixel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.Receive4BitsPerPixel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.Receive8BitsPerPixel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.DesktopWidth)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.DesktopHeight)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.DesktopResizeFlag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">var bitmapCompressionFlag uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;bitmapCompressionFlag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">var highColorFlags uint8
        err = binary.Read(wire, binary.LittleEndian, &amp;highColorFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.DrawingFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">var multipleRectangleSupport uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;multipleRectangleSupport)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
)

type BrushSupportLevel uint32

const (
        // BrushSupportLevelDefault BRUSH_DEFAULT
        BrushSupportLevelDefault BrushSupportLevel = 0

        // BrushSupportLevelColor8x8 BRUSH_COLOR_8x8
        BrushSupportLevelColor8x8 BrushSupportLevel = 1

        // BrushSupportLevelFull BRUSH_COLOR_FULL
        BrushSupportLevelFull BrushSupportLevel = 2
)

type BrushCapabilitySet struct {
        BrushSupportLevel BrushSupportLevel
}

func NewBrushCapabilitySet() CapabilitySet <span class="cov4" title="5">{
        return CapabilitySet{
                CapabilitySetType:  CapabilitySetTypeBrush,
                BrushCapabilitySet: &amp;BrushCapabilitySet{},
        }
}</span>

func (s *BrushCapabilitySet) Serialize() []byte <span class="cov5" title="8">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint32(s.BrushSupportLevel))

        return buf.Bytes()
}</span>

func (s *BrushCapabilitySet) Deserialize(wire io.Reader) error <span class="cov3" title="4">{
        return binary.Read(wire, binary.LittleEndian, &amp;s.BrushSupportLevel)
}</span>

type CacheDefinition struct {
        CacheEntries         uint16
        CacheMaximumCellSize uint16
}

func (d *CacheDefinition) Serialize() []byte <span class="cov10" title="81">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, d.CacheEntries)
        _ = binary.Write(buf, binary.LittleEndian, d.CacheMaximumCellSize)

        return buf.Bytes()
}</span>

func (d *CacheDefinition) Deserialize(wire io.Reader) error <span class="cov8" title="41">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;d.CacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="41">err = binary.Read(wire, binary.LittleEndian, &amp;d.CacheMaximumCellSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="41">return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
)

type BitmapCacheCapabilitySetRev1 struct {
        Cache0Entries         uint16
        Cache0MaximumCellSize uint16
        Cache1Entries         uint16
        Cache1MaximumCellSize uint16
        Cache2Entries         uint16
        Cache2MaximumCellSize uint16
}

func NewBitmapCacheCapabilitySetRev1() CapabilitySet <span class="cov9" title="5">{
        return CapabilitySet{
                CapabilitySetType:            CapabilitySetTypeBitmapCache,
                BitmapCacheCapabilitySetRev1: &amp;BitmapCacheCapabilitySetRev1{},
        }
}</span>

func (s *BitmapCacheCapabilitySetRev1) Serialize() []byte <span class="cov10" title="6">{
        buf := new(bytes.Buffer)

        buf.Write(make([]byte, 24)) // padding
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.Cache0Entries)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.Cache0MaximumCellSize)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.Cache1Entries)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.Cache1MaximumCellSize)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.Cache2Entries)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.Cache2MaximumCellSize)

        return buf.Bytes()
}</span>

func (s *BitmapCacheCapabilitySetRev1) Deserialize(wire io.Reader) error <span class="cov7" title="4">{
        var (
                padding [24]byte
                err     error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;s.Cache0Entries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;s.Cache0MaximumCellSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;s.Cache1Entries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;s.Cache1MaximumCellSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;s.Cache2Entries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;s.Cache2MaximumCellSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">return nil</span>
}

type BitmapCacheCapabilitySetRev2 struct {
        CacheFlags           uint16
        NumCellCaches        uint8
        BitmapCache0CellInfo uint32
        BitmapCache1CellInfo uint32
        BitmapCache2CellInfo uint32
        BitmapCache3CellInfo uint32
        BitmapCache4CellInfo uint32
}

func NewBitmapCacheCapabilitySetRev2() *CapabilitySet <span class="cov0" title="0">{
        return &amp;CapabilitySet{
                CapabilitySetType:            CapabilitySetTypeBitmapCacheRev2,
                BitmapCacheCapabilitySetRev2: &amp;BitmapCacheCapabilitySetRev2{},
        }
}</span>

func (s *BitmapCacheCapabilitySetRev2) Serialize() []byte <span class="cov6" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, &amp;s.CacheFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint8(0)) // padding
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.NumCellCaches)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.BitmapCache0CellInfo)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.BitmapCache1CellInfo)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.BitmapCache2CellInfo)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.BitmapCache3CellInfo)
        _ = binary.Write(buf, binary.LittleEndian, &amp;s.BitmapCache4CellInfo)
        buf.Write(make([]byte, 12)) // padding

        return buf.Bytes()
}</span>

func (s *BitmapCacheCapabilitySetRev2) Deserialize(wire io.Reader) error <span class="cov1" title="1">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.CacheFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">var padding uint8
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.NumCellCaches)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.BitmapCache0CellInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.BitmapCache1CellInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.BitmapCache2CellInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.BitmapCache3CellInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.BitmapCache4CellInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.BitmapCache4CellInfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">var padding2 [12]byte
        err = binary.Read(wire, binary.LittleEndian, &amp;padding2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type ColorCacheCapabilitySet struct {
        ColorTableCacheSize uint16
}

func (s *ColorCacheCapabilitySet) Serialize() []byte <span class="cov6" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, &amp;s.ColorTableCacheSize)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // padding

        return buf.Bytes()
}</span>

func (s *ColorCacheCapabilitySet) Deserialize(wire io.Reader) error <span class="cov4" title="2">{
        var (
                padding uint16
                err     error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;s.ColorTableCacheSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">return binary.Read(wire, binary.LittleEndian, &amp;padding)</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
)

type DrawNineGridCacheCapabilitySet struct {
        drawNineGridSupportLevel uint32
        drawNineGridCacheSize    uint16
        drawNineGridCacheEntries uint16
}

func (s *DrawNineGridCacheCapabilitySet) Serialize() []byte <span class="cov10" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.drawNineGridSupportLevel)
        _ = binary.Write(buf, binary.LittleEndian, s.drawNineGridCacheSize)
        _ = binary.Write(buf, binary.LittleEndian, s.drawNineGridCacheEntries)

        return buf.Bytes()
}</span>

func (s *DrawNineGridCacheCapabilitySet) Deserialize(wire io.Reader) error <span class="cov1" title="1">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.drawNineGridSupportLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.drawNineGridCacheSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.drawNineGridCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type GDICacheEntries struct {
        GdipGraphicsCacheEntries        uint16
        GdipBrushCacheEntries           uint16
        GdipPenCacheEntries             uint16
        GdipImageCacheEntries           uint16
        GdipImageAttributesCacheEntries uint16
}

func (e *GDICacheEntries) Serialize() []byte <span class="cov10" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, e.GdipGraphicsCacheEntries)
        _ = binary.Write(buf, binary.LittleEndian, e.GdipBrushCacheEntries)
        _ = binary.Write(buf, binary.LittleEndian, e.GdipPenCacheEntries)
        _ = binary.Write(buf, binary.LittleEndian, e.GdipImageCacheEntries)
        _ = binary.Write(buf, binary.LittleEndian, e.GdipImageAttributesCacheEntries)

        return buf.Bytes()
}</span>

func (e *GDICacheEntries) Deserialize(wire io.Reader) error <span class="cov1" title="1">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;e.GdipGraphicsCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;e.GdipBrushCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;e.GdipPenCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;e.GdipImageCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;e.GdipImageAttributesCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type GDICacheChunkSize struct {
        GdipGraphicsCacheChunkSize              uint16
        GdipObjectBrushCacheChunkSize           uint16
        GdipObjectPenCacheChunkSize             uint16
        GdipObjectImageAttributesCacheChunkSize uint16
}

func (s *GDICacheChunkSize) Serialize() []byte <span class="cov10" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.GdipGraphicsCacheChunkSize)
        _ = binary.Write(buf, binary.LittleEndian, s.GdipObjectBrushCacheChunkSize)
        _ = binary.Write(buf, binary.LittleEndian, s.GdipObjectPenCacheChunkSize)
        _ = binary.Write(buf, binary.LittleEndian, s.GdipObjectImageAttributesCacheChunkSize)

        return buf.Bytes()
}</span>

func (s *GDICacheChunkSize) Deserialize(wire io.Reader) error <span class="cov1" title="1">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.GdipGraphicsCacheChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.GdipObjectBrushCacheChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.GdipObjectPenCacheChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.GdipObjectImageAttributesCacheChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type GDIImageCacheProperties struct {
        GdipObjectImageCacheChunkSize uint16
        GdipObjectImageCacheTotalSize uint16
        GdipObjectImageCacheMaxSize   uint16
}

func (p *GDIImageCacheProperties) Serialize() []byte <span class="cov10" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, p.GdipObjectImageCacheChunkSize)
        _ = binary.Write(buf, binary.LittleEndian, p.GdipObjectImageCacheTotalSize)
        _ = binary.Write(buf, binary.LittleEndian, p.GdipObjectImageCacheMaxSize)

        return buf.Bytes()
}</span>

func (p *GDIImageCacheProperties) Deserialize(wire io.Reader) error <span class="cov1" title="1">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;p.GdipObjectImageCacheChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;p.GdipObjectImageCacheTotalSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;p.GdipObjectImageCacheMaxSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type DrawGDIPlusCapabilitySet struct {
        drawGDIPlusSupportLevel  uint32
        GdipVersion              uint32
        drawGdiplusCacheLevel    uint32
        GdipCacheEntries         GDICacheEntries
        GdipCacheChunkSize       GDICacheChunkSize
        GdipImageCacheProperties GDIImageCacheProperties
}

func (s *DrawGDIPlusCapabilitySet) Serialize() []byte <span class="cov10" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.drawGDIPlusSupportLevel)
        _ = binary.Write(buf, binary.LittleEndian, s.GdipVersion)
        _ = binary.Write(buf, binary.LittleEndian, s.drawGdiplusCacheLevel)

        buf.Write(s.GdipCacheEntries.Serialize())
        buf.Write(s.GdipCacheChunkSize.Serialize())
        buf.Write(s.GdipImageCacheProperties.Serialize())

        return buf.Bytes()
}</span>

func (s *DrawGDIPlusCapabilitySet) Deserialize(wire io.Reader) error <span class="cov1" title="1">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.drawGDIPlusSupportLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.GdipVersion)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;s.drawGdiplusCacheLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = s.GdipCacheEntries.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = s.GdipCacheChunkSize.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = s.GdipImageCacheProperties.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
)

type GeneralCapabilitySet struct {
        OSMajorType           uint16
        OSMinorType           uint16
        ExtraFlags            uint16
        RefreshRectSupport    uint8
        SuppressOutputSupport uint8
}

func NewGeneralCapabilitySet() CapabilitySet <span class="cov8" title="6">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeGeneral,
                GeneralCapabilitySet: &amp;GeneralCapabilitySet{
                        OSMajorType:           0x000A,                                     // Windows 10+ platform
                        OSMinorType:           0x0000,                                     // Latest version
                        ExtraFlags:            0x0001 | 0x0004 | 0x0400 | 0x0080 | 0x0100, // Enhanced features: FASTPATH_OUTPUT_SUPPORTED, LONG_CREDENTIALS_SUPPORTED, NO_BITMAP_COMPRESSION_HDR, DYNAMIC_DST_SUPPORTED, TILE_SUPPORT
                        RefreshRectSupport:    1,                                          // We support Refresh Rect PDU
                        SuppressOutputSupport: 1,                                          // We support Suppress Output PDU
                },
        }
}</span>

func (s *GeneralCapabilitySet) Serialize() []byte <span class="cov10" title="8">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.OSMajorType)
        _ = binary.Write(buf, binary.LittleEndian, s.OSMinorType)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0200)) // protocolVersion
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // padding
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // compressionTypes
        _ = binary.Write(buf, binary.LittleEndian, s.ExtraFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // updateCapabilityFlag
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // remoteUnshareFlag
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // compressionLevel
        _ = binary.Write(buf, binary.LittleEndian, s.RefreshRectSupport)
        _ = binary.Write(buf, binary.LittleEndian, s.SuppressOutputSupport)

        return buf.Bytes()
}</span>

func (s *GeneralCapabilitySet) Deserialize(wire io.Reader) error <span class="cov8" title="6">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.OSMajorType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">err = binary.Read(wire, binary.LittleEndian, &amp;s.OSMinorType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">var protocolVersion uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;protocolVersion)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">var compressionTypes uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;compressionTypes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">err = binary.Read(wire, binary.LittleEndian, &amp;s.ExtraFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">var updateCapabilityFlag uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;updateCapabilityFlag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">var remoteUnshareFlag uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;remoteUnshareFlag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">var compressionLevel uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;compressionLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">err = binary.Read(wire, binary.LittleEndian, &amp;s.RefreshRectSupport)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">err = binary.Read(wire, binary.LittleEndian, &amp;s.SuppressOutputSupport)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">return nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
)

type GlyphSupportLevel uint16

const (
        // GlyphSupportLevelNone GLYPH_SUPPORT_NONE
        GlyphSupportLevelNone GlyphSupportLevel = 0

        // GlyphSupportLevelPartial GLYPH_SUPPORT_PARTIAL
        GlyphSupportLevelPartial GlyphSupportLevel = 1

        // GlyphSupportLevelFull GLYPH_SUPPORT_FULL
        GlyphSupportLevelFull GlyphSupportLevel = 2

        // GlyphSupportLevelEncode GLYPH_SUPPORT_ENCODE
        GlyphSupportLevelEncode GlyphSupportLevel = 3
)

type GlyphCacheCapabilitySet struct {
        GlyphCache        [10]CacheDefinition
        FragCache         uint32
        GlyphSupportLevel GlyphSupportLevel
}

func NewGlyphCacheCapabilitySet() CapabilitySet <span class="cov4" title="5">{
        return CapabilitySet{
                CapabilitySetType:       CapabilitySetTypeGlyphCache,
                GlyphCacheCapabilitySet: &amp;GlyphCacheCapabilitySet{},
        }
}</span>

func (s *GlyphCacheCapabilitySet) Serialize() []byte <span class="cov5" title="8">{
        buf := new(bytes.Buffer)

        for i := range s.GlyphCache </span><span class="cov10" title="80">{
                buf.Write(s.GlyphCache[i].Serialize())
        }</span>

        <span class="cov5" title="8">_ = binary.Write(buf, binary.LittleEndian, s.FragCache)
        _ = binary.Write(buf, binary.LittleEndian, s.GlyphSupportLevel)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // padding

        return buf.Bytes()</span>
}

func (s *GlyphCacheCapabilitySet) Deserialize(wire io.Reader) error <span class="cov3" title="4">{
        var err error

        for i := range s.GlyphCache </span><span class="cov8" title="40">{
                err = s.GlyphCache[i].Deserialize(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov3" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;s.FragCache)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;s.GlyphSupportLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="4">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="4">return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
)

type InputCapabilitySet struct {
        InputFlags          uint16
        KeyboardLayout      uint32
        KeyboardType        uint32
        KeyboardSubType     uint32
        KeyboardFunctionKey uint32
        ImeFileName         [64]byte
}

func NewInputCapabilitySet() CapabilitySet <span class="cov7" title="5">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeInput,
                InputCapabilitySet: &amp;InputCapabilitySet{
                        InputFlags:          0x0001 | 0x0004 | 0x0010 | 0x0020, // INPUT_FLAG_SCANCODES, INPUT_FLAG_MOUSEX, INPUT_FLAG_UNICODE, INPUT_FLAG_FASTPATH_INPUT2
                        KeyboardLayout:      0x00000409,                        // US
                        KeyboardType:        0x00000004,                        // IBM enhanced (101- or 102-key) keyboard
                        KeyboardFunctionKey: 12,
                },
        }
}</span>

func (s *InputCapabilitySet) Serialize() []byte <span class="cov10" title="8">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.InputFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // padding
        _ = binary.Write(buf, binary.LittleEndian, s.KeyboardLayout)
        _ = binary.Write(buf, binary.LittleEndian, s.KeyboardType)
        _ = binary.Write(buf, binary.LittleEndian, s.KeyboardSubType)
        _ = binary.Write(buf, binary.LittleEndian, s.KeyboardFunctionKey)
        _ = binary.Write(buf, binary.LittleEndian, s.ImeFileName)

        return buf.Bytes()
}</span>

func (s *InputCapabilitySet) Deserialize(wire io.Reader) error <span class="cov7" title="5">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.InputFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.KeyboardLayout)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.KeyboardType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.KeyboardSubType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.KeyboardFunctionKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.ImeFileName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package pdu

import (
"bytes"
"encoding/binary"
"io"
)

type BitmapCacheHostSupportCapabilitySet struct{}

func NewBitmapCacheHostSupportCapabilitySet() *CapabilitySet <span class="cov1" title="1">{
        return &amp;CapabilitySet{
                CapabilitySetType:                   CapabilitySetTypeBitmapCacheHostSupport,
                BitmapCacheHostSupportCapabilitySet: &amp;BitmapCacheHostSupportCapabilitySet{},
        }
}</span>

func (s *BitmapCacheHostSupportCapabilitySet) Deserialize(wire io.Reader) error <span class="cov1" title="1">{
        var (
                cacheVersion uint8
                padding1     uint8
                padding2     uint16
                err          error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;cacheVersion)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;padding1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;padding2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return err</span>
}

type ControlCapabilitySet struct{}

func (s *ControlCapabilitySet) Serialize() []byte <span class="cov10" title="4">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // controlFlags
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // remoteDetachFlag
        _ = binary.Write(buf, binary.LittleEndian, uint16(2)) // controlInterest
        _ = binary.Write(buf, binary.LittleEndian, uint16(2)) // detachInterest

        return buf.Bytes()
}</span>

func (s *ControlCapabilitySet) Deserialize(wire io.Reader) error <span class="cov5" title="2">{
        padding := make([]byte, 8)

        return binary.Read(wire, binary.LittleEndian, &amp;padding)
}</span>

type WindowActivationCapabilitySet struct{}

func (s *WindowActivationCapabilitySet) Serialize() []byte <span class="cov10" title="4">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // helpKeyFlag
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // helpKeyIndexFlag
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // helpExtendedKeyFlag
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // windowManagerKeyFlag

        return buf.Bytes()
}</span>

func (s *WindowActivationCapabilitySet) Deserialize(wire io.Reader) error <span class="cov5" title="2">{
        padding := make([]byte, 8)

        return binary.Read(wire, binary.LittleEndian, &amp;padding)
}</span>

type ShareCapabilitySet struct{}

func (s *ShareCapabilitySet) Serialize() []byte <span class="cov10" title="4">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // nodeID
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // pad2octets

        return buf.Bytes()
}</span>

func (s *ShareCapabilitySet) Deserialize(wire io.Reader) error <span class="cov5" title="2">{
        padding := make([]byte, 4)

        return binary.Read(wire, binary.LittleEndian, &amp;padding)
}</span>

type FontCapabilitySet struct {
        fontSupportFlags uint16
}

func (s *FontCapabilitySet) Serialize() []byte <span class="cov10" title="4">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.fontSupportFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // padding

        return buf.Bytes()
}</span>

func (s *FontCapabilitySet) Deserialize(wire io.Reader) error <span class="cov5" title="2">{
        padding := make([]byte, 2)

        err := binary.Read(wire, binary.LittleEndian, &amp;s.fontSupportFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="2">return binary.Read(wire, binary.LittleEndian, &amp;padding)</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package pdu

import (
"bytes"
"encoding/binary"
"io"
)

type OffscreenBitmapCacheCapabilitySet struct {
        OffscreenSupportLevel uint32
        OffscreenCacheSize    uint16
        OffscreenCacheEntries uint16
}

func NewOffscreenBitmapCacheCapabilitySet() CapabilitySet <span class="cov7" title="5">{
        return CapabilitySet{
                CapabilitySetType:                 CapabilitySetTypeOffscreenBitmapCache,
                OffscreenBitmapCacheCapabilitySet: &amp;OffscreenBitmapCacheCapabilitySet{},
        }
}</span>

func (s *OffscreenBitmapCacheCapabilitySet) Serialize() []byte <span class="cov10" title="8">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.OffscreenSupportLevel)
        _ = binary.Write(buf, binary.LittleEndian, s.OffscreenCacheSize)
        _ = binary.Write(buf, binary.LittleEndian, s.OffscreenCacheEntries)

        return buf.Bytes()
}</span>

func (s *OffscreenBitmapCacheCapabilitySet) Deserialize(wire io.Reader) error <span class="cov7" title="4">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.OffscreenSupportLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;s.OffscreenCacheSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;s.OffscreenCacheEntries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package pdu

import (
"bytes"
"encoding/binary"
"io"
)

type OrderCapabilitySet struct {
        OrderFlags          uint16
        OrderSupport        [32]byte
        textFlags           uint16
        OrderSupportExFlags uint16
        DesktopSaveSize     uint32
        textANSICodePage    uint16
}

func NewOrderCapabilitySet() CapabilitySet <span class="cov7" title="5">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeOrder,
                OrderCapabilitySet: &amp;OrderCapabilitySet{
                        OrderFlags:      0x2 | 0x0008, // NEGOTIATEORDERSUPPORT, ZEROBOUNDSDELTASSUPPORT this flags must be set
                        DesktopSaveSize: 480 * 480,
                },
        }
}</span>

func (s *OrderCapabilitySet) Serialize() []byte <span class="cov10" title="8">{
        buf := new(bytes.Buffer)

        buf.Write(make([]byte, 16))                            // terminalDescriptor
        _ = binary.Write(buf, binary.LittleEndian, uint32(0))  // padding
        _ = binary.Write(buf, binary.LittleEndian, uint16(1))  // desktopSaveXGranularity
        _ = binary.Write(buf, binary.LittleEndian, uint16(20)) // desktopSaveYGranularity
        _ = binary.Write(buf, binary.LittleEndian, uint16(0))  // padding
        _ = binary.Write(buf, binary.LittleEndian, uint16(1))  // maximumOrderLevel = ORD_LEVEL_1_ORDERS
        _ = binary.Write(buf, binary.LittleEndian, uint16(0))  // numberFonts
        _ = binary.Write(buf, binary.LittleEndian, s.OrderFlags)
        _ = binary.Write(buf, binary.LittleEndian, s.OrderSupport)
        _ = binary.Write(buf, binary.LittleEndian, s.textFlags) // textFlags
        _ = binary.Write(buf, binary.LittleEndian, s.OrderSupportExFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint32(0)) // padding
        _ = binary.Write(buf, binary.LittleEndian, s.DesktopSaveSize)
        _ = binary.Write(buf, binary.LittleEndian, uint32(0))          // padding
        _ = binary.Write(buf, binary.LittleEndian, s.textANSICodePage) // textANSICodePage
        _ = binary.Write(buf, binary.LittleEndian, uint16(0))          // padding

        return buf.Bytes()
}</span>

func (s *OrderCapabilitySet) Deserialize(wire io.Reader) error <span class="cov7" title="5">{
        var (
                err                     error
                terminalDescriptor      [16]byte
                padding                 uint32
                desktopSaveXGranularity uint16
                desktopSaveYGranularity uint16
                padding2                uint16
                maximumOrderLevel       uint16
                numberFonts             uint16
                textFlags               uint16
                textANSICodePage        uint16
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;terminalDescriptor)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;desktopSaveXGranularity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;desktopSaveYGranularity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;padding2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;maximumOrderLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;numberFonts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.OrderFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.OrderSupport)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;textFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.OrderSupportExFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.DesktopSaveSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;textANSICodePage)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;padding2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package pdu

import (
"bytes"
"encoding/binary"
"io"
)

type PointerCapabilitySet struct {
        ColorPointerFlag      uint16
        ColorPointerCacheSize uint16
        PointerCacheSize      uint16
        lengthCapability      uint16
}

func NewPointerCapabilitySet() CapabilitySet <span class="cov7" title="5">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypePointer,
                PointerCapabilitySet: &amp;PointerCapabilitySet{
                        ColorPointerFlag: 1, // advertise color cursor support
                        PointerCacheSize: 25,
                },
        }
}</span>

func (s *PointerCapabilitySet) Serialize() []byte <span class="cov10" title="8">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.ColorPointerFlag)
        _ = binary.Write(buf, binary.LittleEndian, s.ColorPointerCacheSize)
        _ = binary.Write(buf, binary.LittleEndian, s.PointerCacheSize)

        return buf.Bytes()
}</span>

func (s *PointerCapabilitySet) Deserialize(wire io.Reader) error <span class="cov8" title="6">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.ColorPointerFlag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">err = binary.Read(wire, binary.LittleEndian, &amp;s.ColorPointerCacheSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="6">if s.lengthCapability == 4 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.PointerCacheSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package pdu

import (
"bytes"
"encoding/binary"
"io"
)

type SoundCapabilitySet struct {
        SoundFlags uint16
}

func NewSoundCapabilitySet() CapabilitySet <span class="cov7" title="5">{
        return CapabilitySet{
                CapabilitySetType:  CapabilitySetTypeSound,
                SoundCapabilitySet: &amp;SoundCapabilitySet{},
        }
}</span>

func (s *SoundCapabilitySet) Serialize() []byte <span class="cov10" title="8">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.SoundFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0))

        return buf.Bytes()
}</span>

func (s *SoundCapabilitySet) Deserialize(wire io.Reader) error <span class="cov7" title="4">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.SoundFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">return nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package pdu

import (
"bytes"
"encoding/binary"
"io"
)

type MultifragmentUpdateCapabilitySet struct {
        MaxRequestSize uint32
}

func NewMultifragmentUpdateCapabilitySet() CapabilitySet <span class="cov9" title="5">{
        return CapabilitySet{
                CapabilitySetType:                CapabilitySetTypeMultifragmentUpdate,
                MultifragmentUpdateCapabilitySet: &amp;MultifragmentUpdateCapabilitySet{},
        }
}</span>

func (s *MultifragmentUpdateCapabilitySet) Serialize() []byte <span class="cov9" title="5">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, &amp;s.MaxRequestSize)

        return buf.Bytes()
}</span>

func (s *MultifragmentUpdateCapabilitySet) Deserialize(wire io.Reader) error <span class="cov9" title="5">{
        return binary.Read(wire, binary.LittleEndian, &amp;s.MaxRequestSize)
}</span>

type LargePointerCapabilitySet struct {
        LargePointerSupportFlags uint16
}

func (s *LargePointerCapabilitySet) Deserialize(wire io.Reader) error <span class="cov4" title="2">{
        return binary.Read(wire, binary.LittleEndian, &amp;s.LargePointerSupportFlags)
}</span>

type DesktopCompositionCapabilitySet struct {
        CompDeskSupportLevel uint16
}

func (s *DesktopCompositionCapabilitySet) Deserialize(wire io.Reader) error <span class="cov1" title="1">{
        return binary.Read(wire, binary.LittleEndian, &amp;s.CompDeskSupportLevel)
}</span>

type SurfaceCommandsCapabilitySet struct {
        CmdFlags uint32
}

// Surface command flags
const (
        SurfCmdSetSurfaceBits  uint32 = 0x00000002
        SurfCmdFrameMarker     uint32 = 0x00000010
        SurfCmdStreamSurfBits  uint32 = 0x00000040
)

func NewSurfaceCommandsCapabilitySet() CapabilitySet <span class="cov4" title="2">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeSurfaceCommands,
                SurfaceCommandsCapabilitySet: &amp;SurfaceCommandsCapabilitySet{
                        CmdFlags: SurfCmdSetSurfaceBits | SurfCmdFrameMarker | SurfCmdStreamSurfBits,
                },
        }
}</span>

func (s *SurfaceCommandsCapabilitySet) Serialize() []byte <span class="cov6" title="3">{
        buf := new(bytes.Buffer)
        _ = binary.Write(buf, binary.LittleEndian, s.CmdFlags)
        _ = binary.Write(buf, binary.LittleEndian, uint32(0)) // reserved
        return buf.Bytes()
}</span>

func (s *SurfaceCommandsCapabilitySet) Deserialize(wire io.Reader) error <span class="cov6" title="3">{
        var (
                reserved uint32
                err      error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;s.CmdFlags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="3">err = binary.Read(wire, binary.LittleEndian, &amp;reserved)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="3">return nil</span>
}

type BitmapCodec struct {
        CodecGUID       [16]byte
        CodecID         uint8
        CodecProperties []byte
}

func (c *BitmapCodec) Deserialize(wire io.Reader) error <span class="cov10" title="6">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;c.CodecGUID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="6">err = binary.Read(wire, binary.LittleEndian, &amp;c.CodecID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="6">var codecPropertiesLength uint16

        err = binary.Read(wire, binary.LittleEndian, &amp;codecPropertiesLength)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="6">c.CodecProperties = make([]byte, codecPropertiesLength)

        _, err = wire.Read(c.CodecProperties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="6">return nil</span>
}

type BitmapCodecsCapabilitySet struct {
        BitmapCodecArray []BitmapCodec
}

func (s *BitmapCodecsCapabilitySet) Deserialize(wire io.Reader) error <span class="cov6" title="3">{
        var (
                bitmapCodecCount uint8
                err              error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;bitmapCodecCount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="3">s.BitmapCodecArray = make([]BitmapCodec, bitmapCodecCount)

        for i := range s.BitmapCodecArray </span><span class="cov10" title="6">{
                err = s.BitmapCodecArray[i].Deserialize(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov6" title="3">return nil</span>
}

// NSCodec GUID: CA8D1BB9-000F-154F-589F-AE2D1A87E2D6
// Stored in little-endian format as per MS-RDPBCGR
var NSCodecGUID = [16]byte{
        0xB9, 0x1B, 0x8D, 0xCA, 0x0F, 0x00, 0x4F, 0x15,
        0x58, 0x9F, 0xAE, 0x2D, 0x1A, 0x87, 0xE2, 0xD6,
}

// NSCodecCapabilitySet represents the NSCodec-specific properties
type NSCodecCapabilitySet struct {
        FAllowDynamicFidelity uint8
        FAllowSubsampling     uint8
        ColorLossLevel        uint8
}

func (c *NSCodecCapabilitySet) Serialize() []byte <span class="cov7" title="4">{
        return []byte{
                c.FAllowDynamicFidelity,
                c.FAllowSubsampling,
                c.ColorLossLevel,
        }
}</span>

func (c *BitmapCodec) Serialize() []byte <span class="cov7" title="4">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, c.CodecGUID)
        _ = binary.Write(buf, binary.LittleEndian, c.CodecID)
        _ = binary.Write(buf, binary.LittleEndian, uint16(len(c.CodecProperties)))
        buf.Write(c.CodecProperties)

        return buf.Bytes()
}</span>

func (s *BitmapCodecsCapabilitySet) Serialize() []byte <span class="cov6" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint8(len(s.BitmapCodecArray)))

        for _, codec := range s.BitmapCodecArray </span><span class="cov6" title="3">{
                buf.Write(codec.Serialize())
        }</span>

        <span class="cov6" title="3">return buf.Bytes()</span>
}

// NewBitmapCodecsCapabilitySet creates a capability set advertising NSCodec support
func NewBitmapCodecsCapabilitySet() CapabilitySet <span class="cov6" title="3">{
        nscodecProps := NSCodecCapabilitySet{
                FAllowDynamicFidelity: 1, // Allow dynamic fidelity
                FAllowSubsampling:     1, // Allow chroma subsampling
                ColorLossLevel:        3, // Moderate color loss (1=lossless, 7=max loss)
        }

        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeBitmapCodecs,
                BitmapCodecsCapabilitySet: &amp;BitmapCodecsCapabilitySet{
                        BitmapCodecArray: []BitmapCodec{
                                {
                                        CodecGUID:       NSCodecGUID,
                                        CodecID:         1, // Will be assigned by server
                                        CodecProperties: nscodecProps.Serialize(),
                                },
                        },
                },
        }
}</span>

type RailCapabilitySet struct {
        RailSupportLevel uint32
}

func NewRailCapabilitySet() CapabilitySet <span class="cov6" title="3">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeRail,
                RailCapabilitySet: &amp;RailCapabilitySet{
                        RailSupportLevel: 1, // TS_RAIL_LEVEL_SUPPORTED
                },
        }
}</span>

func (s *RailCapabilitySet) Serialize() []byte <span class="cov6" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.RailSupportLevel)

        return buf.Bytes()
}</span>

type WindowListCapabilitySet struct {
        WndSupportLevel     uint32
        NumIconCaches       uint8
        NumIconCacheEntries uint16
}

func NewWindowListCapabilitySet() CapabilitySet <span class="cov6" title="3">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeWindow,
                WindowListCapabilitySet: &amp;WindowListCapabilitySet{
                        WndSupportLevel: 0, // TS_WINDOW_LEVEL_NOT_SUPPORTED
                },
        }
}</span>

func (s *WindowListCapabilitySet) Serialize() []byte <span class="cov6" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.WndSupportLevel)
        _ = binary.Write(buf, binary.LittleEndian, s.NumIconCaches)
        _ = binary.Write(buf, binary.LittleEndian, s.NumIconCacheEntries)

        return buf.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package pdu

import (
"bytes"
"encoding/binary"
"io"
)

type VirtualChannelCapabilitySet struct {
        Flags       uint32
        VCChunkSize uint32
}

func NewVirtualChannelCapabilitySet() CapabilitySet <span class="cov7" title="5">{
        return CapabilitySet{
                CapabilitySetType:           CapabilitySetTypeVirtualChannel,
                VirtualChannelCapabilitySet: &amp;VirtualChannelCapabilitySet{},
        }
}</span>

func (s *VirtualChannelCapabilitySet) Serialize() []byte <span class="cov10" title="8">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, s.Flags)
        _ = binary.Write(buf, binary.LittleEndian, s.VCChunkSize)

        return buf.Bytes()
}</span>

func (s *VirtualChannelCapabilitySet) Deserialize(wire io.Reader) error <span class="cov7" title="5">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;s.Flags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.LittleEndian, &amp;s.VCChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
)

type CapabilitySetType uint16

const (
        // CapabilitySetTypeGeneral CAPSTYPE_GENERAL
        CapabilitySetTypeGeneral CapabilitySetType = 0x0001

        // CapabilitySetTypeBitmap CAPSTYPE_BITMAP
        CapabilitySetTypeBitmap CapabilitySetType = 0x0002

        // CapabilitySetTypeOrder CAPSTYPE_ORDER
        CapabilitySetTypeOrder CapabilitySetType = 0x0003

        // CapabilitySetTypeBitmapCache CAPSTYPE_BITMAPCACHE
        CapabilitySetTypeBitmapCache CapabilitySetType = 0x0004

        // CapabilitySetTypeControl CAPSTYPE_CONTROL
        CapabilitySetTypeControl CapabilitySetType = 0x0005

        // CapabilitySetTypeActivation CAPSTYPE_ACTIVATION
        CapabilitySetTypeActivation CapabilitySetType = 0x0007

        // CapabilitySetTypePointer CAPSTYPE_POINTER
        CapabilitySetTypePointer CapabilitySetType = 0x0008

        // CapabilitySetTypeShare CAPSTYPE_SHARE
        CapabilitySetTypeShare CapabilitySetType = 0x0009

        // CapabilitySetTypeColorCache CAPSTYPE_COLORCACHE
        CapabilitySetTypeColorCache CapabilitySetType = 0x000A

        // CapabilitySetTypeSound CAPSTYPE_SOUND
        CapabilitySetTypeSound CapabilitySetType = 0x000C

        // CapabilitySetTypeInput CAPSTYPE_INPUT
        CapabilitySetTypeInput CapabilitySetType = 0x000D

        // CapabilitySetTypeFont CAPSTYPE_FONT
        CapabilitySetTypeFont CapabilitySetType = 0x000E

        // CapabilitySetTypeBrush CAPSTYPE_BRUSH
        CapabilitySetTypeBrush CapabilitySetType = 0x000F

        // CapabilitySetTypeGlyphCache CAPSTYPE_GLYPHCACHE
        CapabilitySetTypeGlyphCache CapabilitySetType = 0x0010

        // CapabilitySetTypeOffscreenBitmapCache CAPSTYPE_OFFSCREENCACHE
        CapabilitySetTypeOffscreenBitmapCache CapabilitySetType = 0x0011

        // CapabilitySetTypeBitmapCacheHostSupport CAPSTYPE_BITMAPCACHE_HOSTSUPPORT
        CapabilitySetTypeBitmapCacheHostSupport CapabilitySetType = 0x0012

        // CapabilitySetTypeBitmapCacheRev2 CAPSTYPE_BITMAPCACHE_REV2
        CapabilitySetTypeBitmapCacheRev2 CapabilitySetType = 0x0013

        // CapabilitySetTypeVirtualChannel CAPSTYPE_VIRTUALCHANNEL
        CapabilitySetTypeVirtualChannel CapabilitySetType = 0x0014

        // CapabilitySetTypeDrawNineGridCache CAPSTYPE_DRAWNINEGRIDCACHE
        CapabilitySetTypeDrawNineGridCache CapabilitySetType = 0x0015

        // CapabilitySetTypeDrawGDIPlus CAPSTYPE_DRAWGDIPLUS
        CapabilitySetTypeDrawGDIPlus CapabilitySetType = 0x0016

        // CapabilitySetTypeRail CAPSTYPE_RAIL
        CapabilitySetTypeRail CapabilitySetType = 0x0017

        // CapabilitySetTypeWindow CAPSTYPE_WINDOW
        CapabilitySetTypeWindow CapabilitySetType = 0x0018

        // CapabilitySetTypeCompDesk CAPSETTYPE_COMPDESK
        CapabilitySetTypeCompDesk CapabilitySetType = 0x0019

        // CapabilitySetTypeMultifragmentUpdate CAPSETTYPE_MULTIFRAGMENTUPDATE
        CapabilitySetTypeMultifragmentUpdate CapabilitySetType = 0x001A

        // CapabilitySetTypeLargePointer CAPSETTYPE_LARGE_POINTER
        CapabilitySetTypeLargePointer CapabilitySetType = 0x001B

        // CapabilitySetTypeSurfaceCommands CAPSETTYPE_SURFACE_COMMANDS
        CapabilitySetTypeSurfaceCommands CapabilitySetType = 0x001C

        // CapabilitySetTypeBitmapCodecs CAPSETTYPE_BITMAP_CODECS
        CapabilitySetTypeBitmapCodecs CapabilitySetType = 0x001D

        // CapabilitySetTypeFrameAcknowledge CAPSSETTYPE_FRAME_ACKNOWLEDGE
        CapabilitySetTypeFrameAcknowledge CapabilitySetType = 0x001E
)

type CapabilitySet struct {
        CapabilitySetType                   CapabilitySetType
        GeneralCapabilitySet                *GeneralCapabilitySet
        BitmapCapabilitySet                 *BitmapCapabilitySet
        OrderCapabilitySet                  *OrderCapabilitySet
        BitmapCacheCapabilitySetRev1        *BitmapCacheCapabilitySetRev1
        BitmapCacheCapabilitySetRev2        *BitmapCacheCapabilitySetRev2
        ColorCacheCapabilitySet             *ColorCacheCapabilitySet
        PointerCapabilitySet                *PointerCapabilitySet
        InputCapabilitySet                  *InputCapabilitySet
        BrushCapabilitySet                  *BrushCapabilitySet
        GlyphCacheCapabilitySet             *GlyphCacheCapabilitySet
        OffscreenBitmapCacheCapabilitySet   *OffscreenBitmapCacheCapabilitySet
        VirtualChannelCapabilitySet         *VirtualChannelCapabilitySet
        DrawNineGridCacheCapabilitySet      *DrawNineGridCacheCapabilitySet
        DrawGDIPlusCapabilitySet            *DrawGDIPlusCapabilitySet
        SoundCapabilitySet                  *SoundCapabilitySet
        BitmapCacheHostSupportCapabilitySet *BitmapCacheHostSupportCapabilitySet
        ControlCapabilitySet                *ControlCapabilitySet
        WindowActivationCapabilitySet       *WindowActivationCapabilitySet
        ShareCapabilitySet                  *ShareCapabilitySet
        FontCapabilitySet                   *FontCapabilitySet
        MultifragmentUpdateCapabilitySet    *MultifragmentUpdateCapabilitySet
        LargePointerCapabilitySet           *LargePointerCapabilitySet
        DesktopCompositionCapabilitySet     *DesktopCompositionCapabilitySet
        SurfaceCommandsCapabilitySet        *SurfaceCommandsCapabilitySet
        BitmapCodecsCapabilitySet           *BitmapCodecsCapabilitySet
        RailCapabilitySet                   *RailCapabilitySet
        WindowListCapabilitySet             *WindowListCapabilitySet
        FrameAcknowledgeCapabilitySet       *FrameAcknowledgeCapabilitySet
}

func (set *CapabilitySet) Serialize() []byte <span class="cov10" title="111">{
        var data []byte

        switch set.CapabilitySetType </span>{
        case CapabilitySetTypeGeneral:<span class="cov4" title="8">
                data = set.GeneralCapabilitySet.Serialize()</span>
        case CapabilitySetTypeBitmap:<span class="cov4" title="7">
                data = set.BitmapCapabilitySet.Serialize()</span>
        case CapabilitySetTypeOrder:<span class="cov4" title="8">
                data = set.OrderCapabilitySet.Serialize()</span>
        case CapabilitySetTypeBitmapCache:<span class="cov4" title="5">
                data = set.BitmapCacheCapabilitySetRev1.Serialize()</span>
        case CapabilitySetTypeBitmapCacheRev2:<span class="cov2" title="2">
                data = set.BitmapCacheCapabilitySetRev2.Serialize()</span>
        case CapabilitySetTypeColorCache:<span class="cov2" title="2">
                data = set.ColorCacheCapabilitySet.Serialize()</span>
        case CapabilitySetTypeActivation:<span class="cov2" title="2">
                data = set.WindowActivationCapabilitySet.Serialize()</span>
        case CapabilitySetTypeControl:<span class="cov2" title="2">
                data = set.ControlCapabilitySet.Serialize()</span>
        case CapabilitySetTypePointer:<span class="cov4" title="6">
                data = set.PointerCapabilitySet.Serialize()</span>
        case CapabilitySetTypeInput:<span class="cov4" title="7">
                data = set.InputCapabilitySet.Serialize()</span>
        case CapabilitySetTypeBrush:<span class="cov4" title="7">
                data = set.BrushCapabilitySet.Serialize()</span>
        case CapabilitySetTypeGlyphCache:<span class="cov4" title="7">
                data = set.GlyphCacheCapabilitySet.Serialize()</span>
        case CapabilitySetTypeOffscreenBitmapCache:<span class="cov4" title="7">
                data = set.OffscreenBitmapCacheCapabilitySet.Serialize()</span>
        case CapabilitySetTypeVirtualChannel:<span class="cov4" title="7">
                data = set.VirtualChannelCapabilitySet.Serialize()</span>
        case CapabilitySetTypeSound:<span class="cov4" title="7">
                data = set.SoundCapabilitySet.Serialize()</span>
        case CapabilitySetTypeShare:<span class="cov2" title="2">
                data = set.ShareCapabilitySet.Serialize()</span>
        case CapabilitySetTypeFont:<span class="cov2" title="2">
                data = set.FontCapabilitySet.Serialize()</span>
        case CapabilitySetTypeDrawNineGridCache:<span class="cov2" title="2">
                data = set.DrawNineGridCacheCapabilitySet.Serialize()</span>
        case CapabilitySetTypeDrawGDIPlus:<span class="cov2" title="2">
                data = set.DrawGDIPlusCapabilitySet.Serialize()</span>
        case CapabilitySetTypeMultifragmentUpdate:<span class="cov3" title="4">
                data = set.MultifragmentUpdateCapabilitySet.Serialize()</span>
        case CapabilitySetTypeRail:<span class="cov3" title="3">
                data = set.RailCapabilitySet.Serialize()</span>
        case CapabilitySetTypeWindow:<span class="cov3" title="3">
                data = set.WindowListCapabilitySet.Serialize()</span>
        case CapabilitySetTypeFrameAcknowledge:<span class="cov3" title="4">
                data = set.FrameAcknowledgeCapabilitySet.Serialize()</span>
        case CapabilitySetTypeBitmapCodecs:<span class="cov3" title="3">
                data = set.BitmapCodecsCapabilitySet.Serialize()</span>
        case CapabilitySetTypeSurfaceCommands:<span class="cov2" title="2">
                data = set.SurfaceCommandsCapabilitySet.Serialize()</span>
        }

        <span class="cov10" title="111">buf := new(bytes.Buffer)

        lengthCapability := uint16(4 + len(data))

        _ = binary.Write(buf, binary.LittleEndian, set.CapabilitySetType)
        _ = binary.Write(buf, binary.LittleEndian, lengthCapability)
        buf.Write(data)

        return buf.Bytes()</span>
}

func (set *CapabilitySet) DeserializeQuick(wire io.Reader) error <span class="cov1" title="1">{
        var (
                lengthCapability uint16
                err              error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;set.CapabilitySetType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;lengthCapability)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">data := make([]byte, lengthCapability-4)
        if _, err = wire.Read(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (set *CapabilitySet) Deserialize(wire io.Reader) error <span class="cov8" title="61">{
        var (
                lengthCapability uint16
                err              error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;set.CapabilitySetType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="61">err = binary.Read(wire, binary.LittleEndian, &amp;lengthCapability)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="61">switch set.CapabilitySetType </span>{
        case CapabilitySetTypeGeneral:<span class="cov3" title="4">
                set.GeneralCapabilitySet = &amp;GeneralCapabilitySet{}

                return set.GeneralCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeBitmap:<span class="cov3" title="4">
                set.BitmapCapabilitySet = &amp;BitmapCapabilitySet{}

                return set.BitmapCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeOrder:<span class="cov3" title="4">
                set.OrderCapabilitySet = &amp;OrderCapabilitySet{}

                return set.OrderCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeBitmapCache:<span class="cov3" title="3">
                set.BitmapCacheCapabilitySetRev1 = &amp;BitmapCacheCapabilitySetRev1{}

                return set.BitmapCacheCapabilitySetRev1.Deserialize(wire)</span>
        case CapabilitySetTypeBitmapCacheRev2:<span class="cov0" title="0">
                set.BitmapCacheCapabilitySetRev2 = &amp;BitmapCacheCapabilitySetRev2{}

                return set.BitmapCacheCapabilitySetRev2.Deserialize(wire)</span>
        case CapabilitySetTypeColorCache:<span class="cov1" title="1">
                set.ColorCacheCapabilitySet = &amp;ColorCacheCapabilitySet{}

                return set.ColorCacheCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypePointer:<span class="cov3" title="4">
                set.PointerCapabilitySet = &amp;PointerCapabilitySet{
                        lengthCapability: lengthCapability - 4,
                }

                return set.PointerCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeInput:<span class="cov3" title="4">
                set.InputCapabilitySet = &amp;InputCapabilitySet{}

                return set.InputCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeBrush:<span class="cov3" title="3">
                set.BrushCapabilitySet = &amp;BrushCapabilitySet{}

                return set.BrushCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeGlyphCache:<span class="cov3" title="3">
                set.GlyphCacheCapabilitySet = &amp;GlyphCacheCapabilitySet{}

                return set.GlyphCacheCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeOffscreenBitmapCache:<span class="cov3" title="3">
                set.OffscreenBitmapCacheCapabilitySet = &amp;OffscreenBitmapCacheCapabilitySet{}

                return set.OffscreenBitmapCacheCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeVirtualChannel:<span class="cov3" title="4">
                set.VirtualChannelCapabilitySet = &amp;VirtualChannelCapabilitySet{}

                return set.VirtualChannelCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeDrawNineGridCache:<span class="cov0" title="0">
                set.DrawNineGridCacheCapabilitySet = &amp;DrawNineGridCacheCapabilitySet{}

                return set.DrawNineGridCacheCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeDrawGDIPlus:<span class="cov0" title="0">
                set.DrawGDIPlusCapabilitySet = &amp;DrawGDIPlusCapabilitySet{}

                return set.DrawGDIPlusCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeSound:<span class="cov3" title="3">
                set.SoundCapabilitySet = &amp;SoundCapabilitySet{}

                return set.SoundCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeFrameAcknowledge:<span class="cov3" title="4">
                set.FrameAcknowledgeCapabilitySet = &amp;FrameAcknowledgeCapabilitySet{}

                return set.FrameAcknowledgeCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeSurfaceCommands:<span class="cov2" title="2">
                set.SurfaceCommandsCapabilitySet = &amp;SurfaceCommandsCapabilitySet{}

                return set.SurfaceCommandsCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeBitmapCodecs:<span class="cov2" title="2">
                set.BitmapCodecsCapabilitySet = &amp;BitmapCodecsCapabilitySet{}

                return set.BitmapCodecsCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeMultifragmentUpdate:<span class="cov3" title="4">
                set.MultifragmentUpdateCapabilitySet = &amp;MultifragmentUpdateCapabilitySet{}

                return set.MultifragmentUpdateCapabilitySet.Deserialize(wire)</span>
        case CapabilitySetTypeLargePointer:<span class="cov1" title="1">
                set.LargePointerCapabilitySet = &amp;LargePointerCapabilitySet{}

                return set.LargePointerCapabilitySet.Deserialize(wire)</span>
        }

        <span class="cov4" title="8">data := make([]byte, lengthCapability-4)
        if _, err = wire.Read(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="8">return nil</span>
}

// Frame Acknowledge Capability Set - for RDP 8.0+
type FrameAcknowledgeCapabilitySet struct {
        MaxUnacknowledgedFrames uint32
}

func (s *FrameAcknowledgeCapabilitySet) Serialize() []byte <span class="cov4" title="5">{
        buf := new(bytes.Buffer)
        _ = binary.Write(buf, binary.LittleEndian, s.MaxUnacknowledgedFrames)
        return buf.Bytes()
}</span>

func (s *FrameAcknowledgeCapabilitySet) Deserialize(wire io.Reader) error <span class="cov4" title="5">{
        return binary.Read(wire, binary.LittleEndian, &amp;s.MaxUnacknowledgedFrames)
}</span>

func NewFrameAcknowledgeCapabilitySet() CapabilitySet <span class="cov4" title="5">{
        return CapabilitySet{
                CapabilitySetType: CapabilitySetTypeFrameAcknowledge,
                FrameAcknowledgeCapabilitySet: &amp;FrameAcknowledgeCapabilitySet{
                        MaxUnacknowledgedFrames: 2, // Default value for better performance
                },
        }
}</span>

type ServerDemandActive struct {
        ShareControlHeader         ShareControlHeader
        ShareID                    uint32
        LengthSourceDescriptor     uint16
        LengthCombinedCapabilities uint16
        SourceDescriptor           []byte
        NumberCapabilities         uint16
        pad2Octets                 uint16
        CapabilitySets             []CapabilitySet
        SessionId                  uint32
}

func (pdu *ServerDemandActive) Deserialize(wire io.Reader) error <span class="cov1" title="1">{
        err := pdu.ShareControlHeader.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.ShareID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.LengthSourceDescriptor)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.LengthCombinedCapabilities)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">pdu.SourceDescriptor = make([]byte, pdu.LengthSourceDescriptor)

        _, err = wire.Read(pdu.SourceDescriptor)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.NumberCapabilities)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.pad2Octets)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">pdu.CapabilitySets = make([]CapabilitySet, 0, pdu.NumberCapabilities)

        for i := uint16(0); i &lt; pdu.NumberCapabilities; i++ </span><span class="cov6" title="17">{
                var capabilitySet CapabilitySet

                if err = capabilitySet.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov6" title="17">pdu.CapabilitySets = append(pdu.CapabilitySets, capabilitySet)</span>
        }

        <span class="cov1" title="1">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.SessionId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type ClientConfirmActive struct {
        ShareControlHeader ShareControlHeader
        ShareID            uint32
        SourceDescriptor   []byte
        CapabilitySets     []CapabilitySet
}

func NewClientConfirmActive(shareID uint32, userId, desktopWidth, desktopHeight uint16, withRemoteApp bool) *ClientConfirmActive <span class="cov3" title="3">{
        pdu := ClientConfirmActive{
                ShareControlHeader: ShareControlHeader{
                        PDUType:   TypeConfirmActive,
                        PDUSource: userId,
                },
                ShareID:          shareID,
                SourceDescriptor: []byte(projectName),
                CapabilitySets: []CapabilitySet{
                        NewGeneralCapabilitySet(),
                        NewBitmapCapabilitySet(desktopWidth, desktopHeight),
                        NewOrderCapabilitySet(),
                        NewBitmapCacheCapabilitySetRev1(),
                        NewPointerCapabilitySet(),
                        NewInputCapabilitySet(),
                        NewBrushCapabilitySet(),
                        NewGlyphCacheCapabilitySet(),
                        NewOffscreenBitmapCacheCapabilitySet(),
                        NewVirtualChannelCapabilitySet(),
                        NewSoundCapabilitySet(),
                        NewMultifragmentUpdateCapabilitySet(),
                        NewFrameAcknowledgeCapabilitySet(),
                        // Note: Do NOT add SurfaceCommands or BitmapCodecs here!
                        // Adding them causes xrdp to use GDI orders instead of bitmap updates,
                        // which we don't support. Keep capabilities identical to master branch.
                },
        }

        if withRemoteApp </span><span class="cov1" title="1">{
                pdu.CapabilitySets = append(pdu.CapabilitySets, NewRailCapabilitySet(), NewWindowListCapabilitySet())
        }</span>

        <span class="cov3" title="3">return &amp;pdu</span>
}

func (pdu *ClientConfirmActive) Serialize() []byte <span class="cov3" title="3">{
        capBuf := bytes.Buffer{}

        for _, set := range pdu.CapabilitySets </span><span class="cov8" title="46">{
                capBuf.Write(set.Serialize())
        }</span>

        <span class="cov3" title="3">lengthSourceDescriptor := uint16(len(pdu.SourceDescriptor))
        lengthCombinedCapabilities := uint16(4 + capBuf.Len())

        pdu.ShareControlHeader.PDUType = TypeConfirmActive
        pdu.ShareControlHeader.TotalLength = 6 + 4 + 2 + 2 + 2 + lengthSourceDescriptor + lengthCombinedCapabilities

        buf := new(bytes.Buffer)

        buf.Write(pdu.ShareControlHeader.Serialize())
        _ = binary.Write(buf, binary.LittleEndian, pdu.ShareID)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x03EA)) // originatorID
        _ = binary.Write(buf, binary.LittleEndian, lengthSourceDescriptor)
        _ = binary.Write(buf, binary.LittleEndian, lengthCombinedCapabilities)

        buf.Write(pdu.SourceDescriptor)

        _ = binary.Write(buf, binary.LittleEndian, uint16(len(pdu.CapabilitySets)))
        _ = binary.Write(buf, binary.LittleEndian, uint16(0)) // padding

        buf.Write(capBuf.Bytes())

        return buf.Bytes()</span>
}

func (pdu *ClientConfirmActive) Deserialize(wire io.Reader) error <span class="cov2" title="2">{
        var err error

        err = pdu.ShareControlHeader.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.ShareID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">var originatorID uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;originatorID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">var lengthSourceDescriptor uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;lengthSourceDescriptor)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">var lengthCombinedCapabilities uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;lengthCombinedCapabilities)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">pdu.SourceDescriptor = make([]byte, lengthSourceDescriptor)
        _, err = wire.Read(pdu.SourceDescriptor)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">var numberCapabilities uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;numberCapabilities)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">pdu.CapabilitySets = make([]CapabilitySet, numberCapabilities)

        for i := range pdu.CapabilitySets </span><span class="cov7" title="28">{
                err = pdu.CapabilitySets[i].Deserialize(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
)

type MessageType uint16

const (
        MessageTypeSync MessageType = 1
)

type SynchronizePDUData struct {
        MessageType MessageType
}

func NewSynchronize(shareID uint32, userId uint16) *Data <span class="cov5" title="4">{
        return &amp;Data{
                ShareDataHeader: *newShareDataHeader(shareID, userId, TypeData, Type2Synchronize),
                SynchronizePDUData: &amp;SynchronizePDUData{
                        MessageType: MessageTypeSync,
                },
        }
}</span>

const ServerChannelID uint16 = 1002

func (pdu *SynchronizePDUData) Serialize() []byte <span class="cov6" title="5">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(pdu.MessageType))
        _ = binary.Write(buf, binary.LittleEndian, ServerChannelID) // targetUser

        return buf.Bytes()
}</span>

func (pdu *SynchronizePDUData) Deserialize(wire io.Reader) error <span class="cov4" title="3">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;pdu.MessageType)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov3" title="2">var targetUser uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;targetUser)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">return nil</span>
}

type ControlAction uint16

const (
        // ControlActionRequestControl CTRLACTION_REQUEST_CONTROL
        ControlActionRequestControl ControlAction = 0x0001

        // ControlActionGrantedControl CTRLACTION_GRANTED_CONTROL
        ControlActionGrantedControl ControlAction = 0x0002

        // ControlActionDetach CTRLACTION_DETACH
        ControlActionDetach ControlAction = 0x0003

        // ControlActionCooperate CTRLACTION_COOPERATE
        ControlActionCooperate ControlAction = 0x0004
)

type ControlPDUData struct {
        Action    ControlAction
        GrantID   uint16
        ControlID uint32
}

func NewControl(shareID uint32, userId uint16, action ControlAction) *Data <span class="cov8" title="10">{
        return &amp;Data{
                ShareDataHeader: *newShareDataHeader(shareID, userId, TypeData, Type2Control),
                ControlPDUData: &amp;ControlPDUData{
                        Action: action,
                },
        }
}</span>

func (pdu *ControlPDUData) Serialize() []byte <span class="cov10" title="14">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(pdu.Action))
        _ = binary.Write(buf, binary.LittleEndian, pdu.GrantID)
        _ = binary.Write(buf, binary.LittleEndian, pdu.ControlID)

        return buf.Bytes()
}</span>

func (pdu *ControlPDUData) Deserialize(wire io.Reader) error <span class="cov9" title="11">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;pdu.Action)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov8" title="9">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.GrantID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="9">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.ControlID)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov8" title="8">return nil</span>
}

type FontListPDUData struct{}

func NewFontList(shareID uint32, userId uint16) *Data <span class="cov4" title="3">{
        return &amp;Data{
                ShareDataHeader: *newShareDataHeader(shareID, userId, TypeData, Type2Fontlist),
                FontListPDUData: &amp;FontListPDUData{},
        }
}</span>

func (pdu *FontListPDUData) Serialize() []byte <span class="cov5" title="4">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // numberFonts
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0000)) // totalNumFonts
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0003)) // listFlags = FONTLIST_FIRST | FONTLIST_LAST
        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0032)) // entrySize

        return buf.Bytes()
}</span>

type FontMapPDUData struct{}

func (pdu *FontMapPDUData) Deserialize(wire io.Reader) error <span class="cov6" title="5">{
        var (
                numberEntries   uint16
                totalNumEntries uint16
                mapFlags        uint16
                entrySize       uint16
                err             error
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;numberEntries)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov5" title="4">err = binary.Read(wire, binary.LittleEndian, &amp;totalNumEntries)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="3">err = binary.Read(wire, binary.LittleEndian, &amp;mapFlags)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov3" title="2">err = binary.Read(wire, binary.LittleEndian, &amp;entrySize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "io"
        "strings"
)

type NegotiationType uint8

const (
        // NegotiationTypeRequest TYPE_RDP_NEG_REQ
        NegotiationTypeRequest NegotiationType = 0x01

        // NegotiationTypeResponse TYPE_RDP_NEG_RSP
        NegotiationTypeResponse NegotiationType = 0x02

        // NegotiationTypeFailure TYPE_RDP_NEG_FAILURE
        NegotiationTypeFailure NegotiationType = 0x03
)

func (t NegotiationType) IsRequest() bool <span class="cov5" title="4">{
        return t == NegotiationTypeRequest
}</span>

func (t NegotiationType) IsResponse() bool <span class="cov5" title="4">{
        return t == NegotiationTypeResponse
}</span>

func (t NegotiationType) IsFailure() bool <span class="cov5" title="4">{
        return t == NegotiationTypeFailure
}</span>

// NegotiationRequestFlag Protocol flags.
type NegotiationRequestFlag uint8

const (
        // NegReqFlagRestrictedAdminModeRequired RESTRICTED_ADMIN_MODE_REQUIRED
        NegReqFlagRestrictedAdminModeRequired NegotiationRequestFlag = 0x01

        // NegReqFlagRedirectedAuthenticationModeRequired REDIRECTED_AUTHENTICATION_MODE_REQUIRED
        NegReqFlagRedirectedAuthenticationModeRequired NegotiationRequestFlag = 0x02

        // NegReqFlagCorrelationInfoPresent CORRELATION_INFO_PRESENT
        NegReqFlagCorrelationInfoPresent NegotiationRequestFlag = 0x08
)

func (f NegotiationRequestFlag) IsRestrictedAdminModeRequired() bool <span class="cov5" title="5">{
        return f&amp;NegReqFlagRestrictedAdminModeRequired == NegReqFlagRestrictedAdminModeRequired
}</span>

func (f NegotiationRequestFlag) IsRedirectedAuthenticationModeRequired() bool <span class="cov5" title="5">{
        return f&amp;NegReqFlagRedirectedAuthenticationModeRequired == NegReqFlagRedirectedAuthenticationModeRequired
}</span>

func (f NegotiationRequestFlag) IsCorrelationInfoPresent() bool <span class="cov6" title="6">{
        return f&amp;NegReqFlagCorrelationInfoPresent == NegReqFlagCorrelationInfoPresent
}</span>

// NegotiationProtocol Supported security protocol.
type NegotiationProtocol uint32

const (
        // NegotiationProtocolRDP PROTOCOL_RDP
        NegotiationProtocolRDP NegotiationProtocol = 0x00000000

        // NegotiationProtocolSSL PROTOCOL_SSL
        NegotiationProtocolSSL NegotiationProtocol = 0x00000001

        // NegotiationProtocolHybrid PROTOCOL_HYBRID
        NegotiationProtocolHybrid NegotiationProtocol = 0x00000002

        // NegotiationProtocolRDSTLS PROTOCOL_RDSTLS
        NegotiationProtocolRDSTLS NegotiationProtocol = 0x00000004

        // NegotiationProtocolHybridEx PROTOCOL_HYBRID_EX
        NegotiationProtocolHybridEx NegotiationProtocol = 0x00000008
)

func (p NegotiationProtocol) IsRDP() bool <span class="cov5" title="5">{
        return p == NegotiationProtocolRDP
}</span>

func (p NegotiationProtocol) IsSSL() bool <span class="cov5" title="5">{
        return p == NegotiationProtocolSSL
}</span>

func (p NegotiationProtocol) IsHybrid() bool <span class="cov5" title="5">{
        return p == NegotiationProtocolHybrid
}</span>

func (p NegotiationProtocol) IsRDSTLS() bool <span class="cov5" title="5">{
        return p == NegotiationProtocolRDSTLS
}</span>

func (p NegotiationProtocol) IsHybridEx() bool <span class="cov5" title="5">{
        return p == NegotiationProtocolHybridEx
}</span>

// NegotiationRequest RDP Negotiation Request (RDP_NEG_REQ).
type NegotiationRequest struct {
        Flags              NegotiationRequestFlag // Protocol flags
        RequestedProtocols NegotiationProtocol    // supported security protocols
}

func (r NegotiationRequest) Serialize() []byte <span class="cov1" title="1">{
        const negReqLen = uint16(8)

        buf := bytes.NewBuffer(make([]byte, 0, negReqLen))

        buf.Write([]byte{
                byte(NegotiationTypeRequest), // type TYPE_RDP_NEG_REQ
                byte(r.Flags),                // flags
        })

        // length (always 8 bytes)
        _ = binary.Write(buf, binary.LittleEndian, negReqLen)

        // requestedProtocols
        _ = binary.Write(buf, binary.LittleEndian, r.RequestedProtocols)

        return buf.Bytes()
}</span>

// CorrelationInfo RDP Correlation Info (RDP_NEG_CORRELATION_INFO).
type CorrelationInfo struct {
        correlationID []byte
}

func (i CorrelationInfo) SetCorrelationID(correlationID []byte) error <span class="cov5" title="5">{
        if len(correlationID) != 16 </span><span class="cov1" title="1">{
                return ErrInvalidCorrelationID
        }</span>

        // The first byte in the array SHOULD NOT have a value of 0x00 or 0xF4
        <span class="cov5" title="4">if correlationID[0] == 0x00 || correlationID[0] == 0xF4 </span><span class="cov3" title="2">{
                return ErrInvalidCorrelationID
        }</span>

        // value 0x0D SHOULD NOT be contained in any of the bytes
        <span class="cov3" title="2">for _, b := range correlationID </span><span class="cov10" title="21">{
                if b == 0x0D </span><span class="cov1" title="1">{
                        return ErrInvalidCorrelationID
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (i CorrelationInfo) Serialize() []byte <span class="cov3" title="2">{
        const corrInfoLen = uint16(36)

        buf := bytes.NewBuffer(make([]byte, 0, corrInfoLen))

        buf.Write([]byte{
                0x06, // type TYPE_RDP_CORRELATION_INFO
                0x00, // flags
        })

        // length (always 36 bytes)
        _ = binary.Write(buf, binary.LittleEndian, corrInfoLen)

        // correlationId
        if i.correlationID == nil </span><span class="cov1" title="1">{
                buf.Write(make([]byte, 16))
        }</span> else<span class="cov1" title="1"> {
                buf.Write(i.correlationID)
        }</span>

        // reserved
        <span class="cov3" title="2">buf.Write(make([]byte, 16))

        return buf.Bytes()</span>
}

// NegotiationResponseFlag RDP Negotiation Response flags
type NegotiationResponseFlag uint8

const (
        // NegotiationResponseFlagECDBSupported EXTENDED_CLIENT_DATA_SUPPORTED
        NegotiationResponseFlagECDBSupported NegotiationResponseFlag = 0x01

        // NegotiationResponseFlagGFXSupported DYNVC_GFX_PROTOCOL_SUPPORTED
        NegotiationResponseFlagGFXSupported NegotiationResponseFlag = 0x02

        // NegotiationResponseFlagAdminModeSupported RESTRICTED_ADMIN_MODE_SUPPORTED
        NegotiationResponseFlagAdminModeSupported NegotiationResponseFlag = 0x08

        // NegotiationResponseFlagAuthModeSupported REDIRECTED_AUTHENTICATION_MODE_SUPPORTED
        NegotiationResponseFlagAuthModeSupported NegotiationResponseFlag = 0x10
)

func (f NegotiationResponseFlag) IsExtendedClientDataSupported() bool <span class="cov6" title="6">{
        return f&amp;NegotiationResponseFlagECDBSupported == NegotiationResponseFlagECDBSupported
}</span>

func (f NegotiationResponseFlag) IsGFXProtocolSupported() bool <span class="cov5" title="5">{
        return f&amp;NegotiationResponseFlagGFXSupported == NegotiationResponseFlagGFXSupported
}</span>

func (f NegotiationResponseFlag) IsRestrictedAdminModeSupported() bool <span class="cov5" title="5">{
        return f&amp;NegotiationResponseFlagAdminModeSupported == NegotiationResponseFlagAdminModeSupported
}</span>

func (f NegotiationResponseFlag) IsRedirectedAuthModeSupported() bool <span class="cov5" title="5">{
        return f&amp;NegotiationResponseFlagAuthModeSupported == NegotiationResponseFlagAuthModeSupported
}</span>

func (f NegotiationResponseFlag) String() string <span class="cov1" title="1">{
        var features []string

        switch </span>{
        case f.IsExtendedClientDataSupported():<span class="cov1" title="1">
                features = append(features, "EXTENDED_CLIENT_DATA_SUPPORTED")</span>
        case f.IsGFXProtocolSupported():<span class="cov0" title="0">
                features = append(features, "DYNVC_GFX_PROTOCOL_SUPPORTED")</span>
        case f.IsRestrictedAdminModeSupported():<span class="cov0" title="0">
                features = append(features, "RESTRICTED_ADMIN_MODE_SUPPORTED")</span>
        case f.IsRedirectedAuthModeSupported():<span class="cov0" title="0">
                features = append(features, "REDIRECTED_AUTHENTICATION_MODE_SUPPORTED")</span>
        }

        <span class="cov1" title="1">return strings.Join(features, ", ")</span>
}

// NegotiationFailureCode RDP Negotiation Failure failureCode
type NegotiationFailureCode uint32

const (
        // NegotiationFailureCodeSSLRequired SSL_REQUIRED_BY_SERVER
        NegotiationFailureCodeSSLRequired NegotiationFailureCode = 0x00000001

        // NegotiationFailureCodeSSLNotAllowed SSL_NOT_ALLOWED_BY_SERVER
        NegotiationFailureCodeSSLNotAllowed NegotiationFailureCode = 0x00000002

        // NegotiationFailureCodeSSLCertNotOnServer SSL_CERT_NOT_ON_SERVER
        NegotiationFailureCodeSSLCertNotOnServer NegotiationFailureCode = 0x00000003

        // NegotiationFailureCodeInconsistentFlags INCONSISTENT_FLAGS
        NegotiationFailureCodeInconsistentFlags NegotiationFailureCode = 0x00000004

        // NegotiationFailureCodeHybridRequired HYBRID_REQUIRED_BY_SERVER
        NegotiationFailureCodeHybridRequired NegotiationFailureCode = 0x00000005

        // NegotiationFailureCodeSSLWithUserAuthRequired SSL_WITH_USER_AUTH_REQUIRED_BY_SERVER
        NegotiationFailureCodeSSLWithUserAuthRequired NegotiationFailureCode = 0x00000006
)

var NegotiationFailureCodeMap = map[NegotiationFailureCode]string{
        NegotiationFailureCodeSSLRequired:             "SSL_REQUIRED_BY_SERVER",
        NegotiationFailureCodeSSLNotAllowed:           "SSL_NOT_ALLOWED_BY_SERVER",
        NegotiationFailureCodeSSLCertNotOnServer:      "SSL_CERT_NOT_ON_SERVER",
        NegotiationFailureCodeInconsistentFlags:       "INCONSISTENT_FLAGS",
        NegotiationFailureCodeHybridRequired:          "HYBRID_REQUIRED_BY_SERVER",
        NegotiationFailureCodeSSLWithUserAuthRequired: "SSL_WITH_USER_AUTH_REQUIRED_BY_SERVER",
}

func (c NegotiationFailureCode) String() string <span class="cov6" title="6">{
        return NegotiationFailureCodeMap[c]
}</span>

// ClientConnectionRequest Client X.224 Connection Request PDU
type ClientConnectionRequest struct {
        RoutingToken       string // one of RoutingToken or Cookie ending CR+LF
        Cookie             string
        NegotiationRequest NegotiationRequest // RDP Negotiation Request
        CorrelationInfo    CorrelationInfo    // Correlation Info
}

func (pdu *ClientConnectionRequest) Serialize() []byte <span class="cov1" title="1">{
        const (
                CRLF         = "\r\n"
                cookieHeader = "Cookie: mstshash="
        )

        buf := new(bytes.Buffer)

        // routingToken or cookie
        if pdu.RoutingToken != "" </span><span class="cov0" title="0">{
                buf.WriteString(strings.Trim(pdu.RoutingToken, CRLF) + CRLF)
        }</span> else<span class="cov1" title="1"> if pdu.Cookie != "" </span><span class="cov1" title="1">{
                buf.WriteString(cookieHeader + strings.Trim(pdu.Cookie, CRLF) + CRLF)
        }</span>

        // rdpNegReq
        <span class="cov1" title="1">buf.Write(pdu.NegotiationRequest.Serialize())

        // rdpCorrelationInfo
        if pdu.NegotiationRequest.Flags.IsCorrelationInfoPresent() </span><span class="cov0" title="0">{
                buf.Write(pdu.CorrelationInfo.Serialize())
        }</span>

        <span class="cov1" title="1">return buf.Bytes()</span>
}

type ServerConnectionConfirm struct {
        Type   NegotiationType
        Flags  NegotiationResponseFlag // RDP Negotiation Response flags
        length uint16
        data   uint32 // RDP Negotiation Response selectedProtocol or RDP Negotiation Failure failureCode
}

func (pdu *ServerConnectionConfirm) SelectedProtocol() NegotiationProtocol <span class="cov1" title="1">{
        return NegotiationProtocol(pdu.data)
}</span>

func (pdu *ServerConnectionConfirm) FailureCode() NegotiationFailureCode <span class="cov3" title="2">{
        return NegotiationFailureCode(pdu.data)
}</span>

func (pdu *ServerConnectionConfirm) Deserialize(wire io.Reader) error <span class="cov3" title="2">{
        err := binary.Read(wire, binary.LittleEndian, &amp;pdu.Type)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.Flags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.length)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
)

type Type uint16

const (
        // TypeDemandActive PDUTYPE_DEMANDACTIVEPDU
        TypeDemandActive Type = 0x11

        // TypeConfirmActive PDUTYPE_CONFIRMACTIVEPDU
        TypeConfirmActive Type = 0x13

        // TypeDeactivateAll PDUTYPE_DEACTIVATEALLPDU
        TypeDeactivateAll Type = 0x16

        // TypeData PDUTYPE_DATAPDU
        TypeData Type = 0x17
)

func (t Type) IsDemandActive() bool <span class="cov5" title="5">{
        return t == TypeDemandActive
}</span>

func (t Type) IsConfirmActive() bool <span class="cov5" title="5">{
        return t == TypeConfirmActive
}</span>

func (t Type) IsDeactivateAll() bool <span class="cov8" title="21">{
        return t == TypeDeactivateAll
}</span>

func (t Type) IsData() bool <span class="cov5" title="5">{
        return t == TypeData
}</span>

type ShareControlHeader struct {
        TotalLength uint16
        PDUType     Type
        PDUSource   uint16
}

func newShareControlHeader(pduType Type, pduSource uint16) *ShareControlHeader <span class="cov9" title="25">{
        return &amp;ShareControlHeader{
                PDUType:   pduType,
                PDUSource: pduSource,
        }
}</span>

func (header *ShareControlHeader) Serialize() []byte <span class="cov9" title="34">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, header.TotalLength)
        _ = binary.Write(buf, binary.LittleEndian, uint16(header.PDUType))
        _ = binary.Write(buf, binary.LittleEndian, header.PDUSource)

        return buf.Bytes()
}</span>

func (header *ShareControlHeader) Deserialize(wire io.Reader) error <span class="cov8" title="24">{
        if err := binary.Read(wire, binary.LittleEndian, &amp;header.TotalLength); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov8" title="23">if err := binary.Read(wire, binary.LittleEndian, &amp;header.PDUType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="23">return binary.Read(wire, binary.LittleEndian, &amp;header.PDUSource)</span>
}

type Type2 uint8

const (
        // Type2Update PDUTYPE2_UPDATE
        Type2Update Type2 = 0x02

        // Type2Control PDUTYPE2_CONTROL
        Type2Control Type2 = 0x14

        // Type2Pointer PDUTYPE2_POINTER
        Type2Pointer Type2 = 0x1B

        // Type2Input PDUTYPE2_INPUT
        Type2Input Type2 = 0x1C

        // Type2Synchronize PDUTYPE2_SYNCHRONIZE
        Type2Synchronize Type2 = 0x1F

        // Type2Fontlist PDUTYPE2_FONTLIST
        Type2Fontlist Type2 = 0x27

        // Type2Fontmap PDUTYPE2_FONTMAP
        Type2Fontmap Type2 = 0x28

        // Type2ErrorInfo PDUTYPE2_SET_ERROR_INFO_PDU
        Type2ErrorInfo Type2 = 0x2f

        // Type2SaveSessionInfo PDUTYPE2_SAVE_SESSION_INFO
        Type2SaveSessionInfo Type2 = 0x26
)

func (t Type2) IsUpdate() bool <span class="cov7" title="12">{
        return t == Type2Update
}</span>

func (t Type2) IsControl() bool <span class="cov9" title="32">{
        return t == Type2Control
}</span>

func (t Type2) IsPointer() bool <span class="cov6" title="11">{
        return t == Type2Pointer
}</span>

func (t Type2) IsInput() bool <span class="cov6" title="9">{
        return t == Type2Input
}</span>

func (t Type2) IsSynchronize() bool <span class="cov10" title="37">{
        return t == Type2Synchronize
}</span>

func (t Type2) IsFontlist() bool <span class="cov7" title="12">{
        return t == Type2Fontlist
}</span>

func (t Type2) IsErrorInfo() bool <span class="cov7" title="14">{
        return t == Type2ErrorInfo
}</span>

func (t Type2) IsFontmap() bool <span class="cov7" title="15">{
        return t == Type2Fontmap
}</span>

func (t Type2) IsSaveSessionInfo() bool <span class="cov7" title="13">{
        return t == Type2SaveSessionInfo
}</span>

type ShareDataHeader struct {
        ShareControlHeader ShareControlHeader
        ShareID            uint32
        StreamID           uint8
        UncompressedLength uint16
        PDUType2           Type2
        CompressedType     uint8
        CompressedLength   uint16
}

func newShareDataHeader(shareID uint32, pduSource uint16, pduType Type, pduType2 Type2) *ShareDataHeader <span class="cov8" title="24">{
        return &amp;ShareDataHeader{
                ShareControlHeader: *newShareControlHeader(pduType, pduSource),
                ShareID:            shareID,
                StreamID:           0x01, // STREAM_LOW
                PDUType2:           pduType2,
        }
}</span>

func (header *ShareDataHeader) Serialize() []byte <span class="cov9" title="27">{
        buf := new(bytes.Buffer)

        buf.Write(header.ShareControlHeader.Serialize())
        _ = binary.Write(buf, binary.LittleEndian, header.ShareID)
        _ = binary.Write(buf, binary.LittleEndian, uint8(0)) // padding
        _ = binary.Write(buf, binary.LittleEndian, header.StreamID)
        _ = binary.Write(buf, binary.LittleEndian, header.UncompressedLength)
        _ = binary.Write(buf, binary.LittleEndian, uint8(header.PDUType2))
        _ = binary.Write(buf, binary.LittleEndian, header.CompressedType)
        _ = binary.Write(buf, binary.LittleEndian, header.CompressedLength)

        return buf.Bytes()
}</span>

func (header *ShareDataHeader) Deserialize(wire io.Reader) error <span class="cov8" title="18">{
        var (
                padding uint8
                err     error
        )

        if err = header.ShareControlHeader.Deserialize(wire); err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov7" title="16">if header.ShareControlHeader.PDUType.IsDeactivateAll() </span><span class="cov1" title="1">{
                return ErrDeactiateAll
        }</span>

        <span class="cov7" title="15">err = binary.Read(wire, binary.LittleEndian, &amp;header.ShareID)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="14">err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="14">err = binary.Read(wire, binary.LittleEndian, &amp;header.StreamID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="14">err = binary.Read(wire, binary.LittleEndian, &amp;header.UncompressedLength)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="14">err = binary.Read(wire, binary.LittleEndian, &amp;header.PDUType2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="14">err = binary.Read(wire, binary.LittleEndian, &amp;header.CompressedType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="14">err = binary.Read(wire, binary.LittleEndian, &amp;header.CompressedLength)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="14">return nil</span>
}

type Data struct {
        ShareDataHeader    ShareDataHeader
        SynchronizePDUData *SynchronizePDUData
        ControlPDUData     *ControlPDUData
        FontListPDUData    *FontListPDUData
        FontMapPDUData     *FontMapPDUData
        ErrorInfoPDUData   *ErrorInfoPDUData
}

func (pdu *Data) Serialize() []byte <span class="cov8" title="17">{
        var data []byte

        switch </span>{
        case pdu.ShareDataHeader.PDUType2.IsSynchronize():<span class="cov4" title="4">
                data = pdu.SynchronizePDUData.Serialize()</span>
        case pdu.ShareDataHeader.PDUType2.IsControl():<span class="cov6" title="10">
                data = pdu.ControlPDUData.Serialize()</span>
        case pdu.ShareDataHeader.PDUType2.IsFontlist():<span class="cov3" title="3">
                data = pdu.FontListPDUData.Serialize()</span>
        }

        <span class="cov8" title="17">pdu.ShareDataHeader.ShareControlHeader.TotalLength = uint16(18 + len(data))
        pdu.ShareDataHeader.UncompressedLength = uint16(4 + len(data))

        buf := new(bytes.Buffer)

        buf.Write(pdu.ShareDataHeader.Serialize())
        buf.Write(data)

        return buf.Bytes()</span>
}

func (pdu *Data) Deserialize(wire io.Reader) error <span class="cov6" title="11">{
        var err error

        if err = pdu.ShareDataHeader.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="11">switch </span>{
        case pdu.ShareDataHeader.PDUType2.IsSynchronize():<span class="cov1" title="1">
                pdu.SynchronizePDUData = &amp;SynchronizePDUData{}

                return pdu.SynchronizePDUData.Deserialize(wire)</span>
        case pdu.ShareDataHeader.PDUType2.IsControl():<span class="cov4" title="4">
                pdu.ControlPDUData = &amp;ControlPDUData{}

                return pdu.ControlPDUData.Deserialize(wire)</span>
        case pdu.ShareDataHeader.PDUType2.IsFontmap():<span class="cov1" title="1">
                pdu.FontMapPDUData = &amp;FontMapPDUData{}

                return pdu.FontMapPDUData.Deserialize(wire)</span>
        case pdu.ShareDataHeader.PDUType2.IsErrorInfo():<span class="cov1" title="1">
                pdu.ErrorInfoPDUData = &amp;ErrorInfoPDUData{}

                return pdu.ErrorInfoPDUData.Deserialize(wire)</span>
        case pdu.ShareDataHeader.PDUType2.IsSaveSessionInfo():<span class="cov1" title="1"> // ignore
                return nil</span>
        case pdu.ShareDataHeader.PDUType2.IsUpdate():<span class="cov1" title="1"> // slow-path graphics update, handled via fastpath
                return nil</span>
        case pdu.ShareDataHeader.PDUType2.IsPointer():<span class="cov1" title="1"> // pointer update, ignore for now
                return nil</span>
        }

        <span class="cov1" title="1">return fmt.Errorf("unknown data pdu: %d", pdu.ShareDataHeader.PDUType2)</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package pdu

import (
        "encoding/binary"
        "fmt"
        "io"
)

type ErrorInfoPDUData struct {
        ErrorInfo uint32
}

func (pdu *ErrorInfoPDUData) Deserialize(wire io.Reader) error <span class="cov5" title="14">{
        return binary.Read(wire, binary.LittleEndian, &amp;pdu.ErrorInfo)
}</span>

var errorInfoMap = map[uint32]string{
        0x00000000: "ERRINFO_NONE",
        0x00000001: "ERRINFO_RPC_INITIATED_DISCONNECT",
        0x00000002: "ERRINFO_RPC_INITIATED_LOGOFF",
        0x00000003: "ERRINFO_IDLE_TIMEOUT",
        0x00000004: "ERRINFO_LOGON_TIMEOUT",
        0x00000005: "ERRINFO_DISCONNECTED_BY_OTHERCONNECTION",
        0x00000006: "ERRINFO_OUT_OF_MEMORY",
        0x00000007: "ERRINFO_SERVER_DENIED_CONNECTION",
        0x00000009: "ERRINFO_SERVER_INSUFFICIENT_PRIVILEGES",
        0x0000000A: "ERRINFO_SERVER_FRESH_CREDENTIALS_REQUIRED",
        0x0000000B: "ERRINFO_RPC_INITIATED_DISCONNECT_BYUSER",
        0x0000000C: "ERRINFO_LOGOFF_BY_USER",
        0x0000000F: "ERRINFO_CLOSE_STACK_ON_DRIVER_NOT_READY",
        0x00000010: "ERRINFO_SERVER_DWM_CRASH",
        0x00000011: "ERRINFO_CLOSE_STACK_ON_DRIVER_FAILURE",
        0x00000012: "ERRINFO_CLOSE_STACK_ON_DRIVER_IFACE_FAILURE",
        0x00000017: "ERRINFO_SERVER_WINLOGON_CRASH",
        0x00000018: "ERRINFO_SERVER_CSRSS_CRASH",
        0x00000019: "ERRINFO_SERVER_SHUTDOWN",
        0x0000001A: "ERRINFO_SERVER_REBOOT",
        0x00000100: "ERRINFO_LICENSE_INTERNAL",
        0x00000101: "ERRINFO_LICENSE_NO_LICENSE_SERVER",
        0x00000102: "ERRINFO_LICENSE_NO_LICENSE",
        0x00000103: "ERRINFO_LICENSE_BAD_CLIENT_MSG",
        0x00000104: "ERRINFO_LICENSE_HWID_DOESNT_MATCH_LICENSE",
        0x00000105: "ERRINFO_LICENSE_BAD_CLIENT_LICENSE",
        0x00000106: "ERRINFO_LICENSE_CANT_FINISH_PROTOCOL",
        0x00000107: "ERRINFO_LICENSE_CLIENT_ENDED_PROTOCOL",
        0x00000108: "ERRINFO_LICENSE_BAD_CLIENT_ENCRYPTION",
        0x00000109: "ERRINFO_LICENSE_CANT_UPGRADE_LICENSE",
        0x0000010A: "ERRINFO_LICENSE_NO_REMOTE_CONNECTIONS",
        0x00000400: "ERRINFO_CB_DESTINATION_NOT_FOUND",
        0x00000402: "ERRINFO_CB_LOADING_DESTINATION",
        0x00000404: "ERRINFO_CB_REDIRECTING_TO_DESTINATION",
        0x00000405: "ERRINFO_CB_SESSION_ONLINE_VM_WAKE",
        0x00000406: "ERRINFO_CB_SESSION_ONLINE_VM_BOOT",
        0x00000407: "ERRINFO_CB_SESSION_ONLINE_VM_NO_DNS",
        0x00000408: "ERRINFO_CB_DESTINATION_POOL_NOT_FREE",
        0x00000409: "ERRINFO_CB_CONNECTION_CANCELLED",
        0x00000410: "ERRINFO_CB_CONNECTION_ERROR_INVALID_SETTINGS",
        0x00000411: "ERRINFO_CB_SESSION_ONLINE_VM_BOOT_TIMEOUT",
        0x00000412: "ERRINFO_CB_SESSION_ONLINE_VM_SESSMON_FAILED",
        0x000010C9: "ERRINFO_UNKNOWNPDUTYPE2",
        0x000010CA: "ERRINFO_UNKNOWNPDUTYPE",
        0x000010CB: "ERRINFO_DATAPDUSEQUENCE",
        0x000010CD: "ERRINFO_CONTROLPDUSEQUENCE",
        0x000010CE: "ERRINFO_INVALIDCONTROLPDUACTION",
        0x000010CF: "ERRINFO_INVALIDINPUTPDUTYPE",
        0x000010D0: "ERRINFO_INVALIDINPUTPDUMOUSE",
        0x000010D1: "ERRINFO_INVALIDREFRESHRECTPDU",
        0x000010D2: "ERRINFO_CREATEUSERDATAFAILED",
        0x000010D3: "ERRINFO_CONNECTFAILED",
        0x000010D4: "ERRINFO_CONFIRMACTIVEWRONGSHAREID",
        0x000010D5: "ERRINFO_CONFIRMACTIVEWRONGORIGINATOR",
        0x000010DA: "ERRINFO_PERSISTENTKEYPDUBADLENGTH",
        0x000010DB: "ERRINFO_PERSISTENTKEYPDUILLEGALFIRST",
        0x000010DC: "ERRINFO_PERSISTENTKEYPDUTOOMANYTOTALKEYS",
        0x000010DD: "ERRINFO_PERSISTENTKEYPDUTOOMANYCACHEKEYS",
        0x000010DE: "ERRINFO_INPUTPDUBADLENGTH",
        0x000010DF: "ERRINFO_BITMAPCACHEERRORPDUBADLENGTH",
        0x000010E0: "ERRINFO_SECURITYDATATOOSHORT",
        0x000010E1: "ERRINFO_VCHANNELDATATOOSHORT",
        0x000010E2: "ERRINFO_SHAREDATATOOSHORT",
        0x000010E3: "ERRINFO_BADSUPRESSOUTPUTPDU",
        0x000010E5: "ERRINFO_CONFIRMACTIVEPDUTOOSHORT",
        0x000010E7: "ERRINFO_CAPABILITYSETTOOSMALL",
        0x000010E8: "ERRINFO_CAPABILITYSETTOOLARGE",
        0x000010E9: "ERRINFO_NOCURSORCACHE",
        0x000010EA: "ERRINFO_BADCAPABILITIES",
        0x000010EC: "ERRINFO_VIRTUALCHANNELDECOMPRESSIONERR",
        0x000010ED: "ERRINFO_INVALIDVCCOMPRESSIONTYPE",
        0x000010EF: "ERRINFO_INVALIDCHANNELID",
        0x000010F0: "ERRINFO_VCHANNELSTOOMANY",
        0x000010F3: "ERRINFO_REMOTEAPPSNOTENABLED",
        0x000010F4: "ERRINFO_CACHECAPNOTSET",
        0x000010F5: "ERRINFO_BITMAPCACHEERRORPDUBADLENGTH2",
        0x000010F6: "ERRINFO_OFFSCRCACHEERRORPDUBADLENGTH",
        0x000010F7: "ERRINFO_DNGCACHEERRORPDUBADLENGTH",
        0x000010F8: "ERRINFO_GDIPLUSPDUBADLENGTH",
        0x00001111: "ERRINFO_SECURITYDATATOOSHORT2",
        0x00001112: "ERRINFO_SECURITYDATATOOSHORT3",
        0x00001113: "ERRINFO_SECURITYDATATOOSHORT4",
        0x00001114: "ERRINFO_SECURITYDATATOOSHORT5",
        0x00001115: "ERRINFO_SECURITYDATATOOSHORT6",
        0x00001116: "ERRINFO_SECURITYDATATOOSHORT7",
        0x00001117: "ERRINFO_SECURITYDATATOOSHORT8",
        0x00001118: "ERRINFO_SECURITYDATATOOSHORT9",
        0x00001119: "ERRINFO_SECURITYDATATOOSHORT10",
        0x0000111A: "ERRINFO_SECURITYDATATOOSHORT11",
        0x0000111B: "ERRINFO_SECURITYDATATOOSHORT12",
        0x0000111C: "ERRINFO_SECURITYDATATOOSHORT13",
        0x0000111D: "ERRINFO_SECURITYDATATOOSHORT14",
        0x0000111E: "ERRINFO_SECURITYDATATOOSHORT15",
        0x0000111F: "ERRINFO_SECURITYDATATOOSHORT16",
        0x00001120: "ERRINFO_SECURITYDATATOOSHORT17",
        0x00001121: "ERRINFO_SECURITYDATATOOSHORT18",
        0x00001122: "ERRINFO_SECURITYDATATOOSHORT19",
        0x00001123: "ERRINFO_SECURITYDATATOOSHORT20",
        0x00001124: "ERRINFO_SECURITYDATATOOSHORT21",
        0x00001125: "ERRINFO_SECURITYDATATOOSHORT22",
        0x00001126: "ERRINFO_SECURITYDATATOOSHORT23",
        0x00001129: "ERRINFO_BADMONITORDATA",
        0x0000112A: "ERRINFO_VCDECOMPRESSEDREASSEMBLEFAILED",
        0x0000112B: "ERRINFO_VCDATATOOLONG",
        0x0000112C: "ERRINFO_BAD_FRAME_ACK_DATA",
        0x0000112D: "ERRINFO_GRAPHICSMODENOTSUPPORTED",
        0x0000112E: "ERRINFO_GRAPHICSSUBSYSTEMRESETFAILED",
        0x0000112F: "ERRINFO_GRAPHICSSUBSYSTEMFAILED",
        0x00001130: "ERRINFO_TIMEZONEKEYNAMELENGTHTOOSHORT",
        0x00001131: "ERRINFO_TIMEZONEKEYNAMELENGTHTOOLONG",
        0x00001132: "ERRINFO_DYNAMICDSTDISABLEDFIELDMISSING",
        0x00001133: "ERRINFO_VCDECODINGERROR",
        0x00001134: "ERRINFO_VIRTUALDESKTOPTOOLARGE",
        0x00001135: "ERRINFO_MONITORGEOMETRYVALIDATIONFAILED",
        0x00001136: "ERRINFO_INVALIDMONITORCOUNT",
        0x00001191: "ERRINFO_UPDATESESSIONKEYFAILED",
        0x00001192: "ERRINFO_DECRYPTFAILED",
        0x00001193: "ERRINFO_ENCRYPTFAILED",
        0x00001194: "ERRINFO_ENCPKGMISMATCH",
        0x00001195: "ERRINFO_DECRYPTFAILED2",
}

func (pdu *ErrorInfoPDUData) String() string <span class="cov10" title="121">{
        code, ok := errorInfoMap[pdu.ErrorInfo]
        if ok </span><span class="cov9" title="120">{
                return code
        }</span>

        <span class="cov1" title="1">return fmt.Sprintf("unknown code: %d", pdu.ErrorInfo)</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
)

// TS_FRAME_ACKNOWLEDGE_PDU - MS-RDPBCGR 2.2.14.2
// Sent from client to server to acknowledge receipt of a frame
type FrameAcknowledgePDU struct {
        ShareDataHeader ShareDataHeader
        FrameID         uint32
}

// NewFrameAcknowledgePDU creates a new Frame Acknowledge PDU
func NewFrameAcknowledgePDU(shareID uint32, userID uint16, frameID uint32) *FrameAcknowledgePDU <span class="cov10" title="2">{
        return &amp;FrameAcknowledgePDU{
                ShareDataHeader: ShareDataHeader{
                        ShareControlHeader: ShareControlHeader{
                                PDUType:   TypeData,
                                PDUSource: userID,
                        },
                        ShareID:            shareID,
                        StreamID:           0x01, // STREAM_LOW
                        UncompressedLength: 4,    // frameID is 4 bytes
                        PDUType2:           38,   // PDUTYPE2_FRAME_ACKNOWLEDGE
                },
                FrameID: frameID,
        }
}</span>

// Serialize serializes the Frame Acknowledge PDU to bytes
func (pdu *FrameAcknowledgePDU) Serialize() []byte <span class="cov1" title="1">{
        buf := new(bytes.Buffer)

        // Frame data (just the frameID)
        frameData := make([]byte, 4)
        binary.LittleEndian.PutUint32(frameData, pdu.FrameID)

        // Update lengths
        pdu.ShareDataHeader.UncompressedLength = uint16(len(frameData))
        pdu.ShareDataHeader.ShareControlHeader.TotalLength = 6 + 12 + uint16(len(frameData)) // ShareControl(6) + ShareData(12) + data

        // Write header and data
        buf.Write(pdu.ShareDataHeader.Serialize())
        buf.Write(frameData)

        return buf.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
)

type EventCode uint8

const (
        //EventCodeScanCode FASTPATH_INPUT_EVENT_SCANCODE
        EventCodeScanCode EventCode = 0

        //EventCodeMouse FASTPATH_INPUT_EVENT_MOUSE
        EventCodeMouse EventCode = 1

        //EventCodeMouseX FASTPATH_INPUT_EVENT_MOUSEX
        EventCodeMouseX EventCode = 2

        //EventCodeSync FASTPATH_INPUT_EVENT_SYNC
        EventCodeSync EventCode = 3

        //EventCodeUnicode FASTPATH_INPUT_EVENT_UNICODE
        EventCodeUnicode EventCode = 4

        //EventCodeQoETimestamp FASTPATH_INPUT_EVENT_QOE_TIMESTAMP
        EventCodeQoETimestamp EventCode = 6
)

type InputEvent struct {
        EventFlags           uint8
        EventCode            EventCode
        keyboardEvent        *keyboardEvent
        unicodeKeyboardEvent *unicodeKeyboardEvent
        mouseEvent           *mouseEvent
        extendedMouseEvent   *extendedMouseEvent
        qualityOfExperience  *qualityOfExperience
}

func (e *InputEvent) Serialize() []byte <span class="cov10" title="18">{
        buf := new(bytes.Buffer)

        // event flags in higher 5 bits
        // event code in lower 3 bits
        header := (e.EventFlags&amp;0x1f)&lt;&lt;3 | uint8(e.EventCode)&amp;0x7

        var data []byte

        switch e.EventCode </span>{
        case EventCodeScanCode:<span class="cov5" title="4">
                data = e.keyboardEvent.Serialize()</span>
        case EventCodeUnicode:<span class="cov4" title="3">
                data = e.unicodeKeyboardEvent.Serialize()</span>
        case EventCodeMouse:<span class="cov4" title="3">
                data = e.mouseEvent.Serialize()</span>
        case EventCodeMouseX:<span class="cov3" title="2">
                data = e.extendedMouseEvent.Serialize()</span>
        case EventCodeSync:<span class="cov5" title="4"></span> // do nothing
        case EventCodeQoETimestamp:<span class="cov3" title="2">
                data = e.qualityOfExperience.Serialize()</span>
        }

        <span class="cov10" title="18">_ = binary.Write(buf, binary.LittleEndian, header)
        buf.Write(data)

        return buf.Bytes()</span>
}

type keyboardEvent struct {
        KeyCode uint8
}

const (
        // KBDFlagsRelease FASTPATH_INPUT_KBDFLAGS_RELEASE
        KBDFlagsRelease uint8 = 0x01

        // KBDFlagsExtended FASTPATH_INPUT_KBDFLAGS_EXTENDED
        KBDFlagsExtended uint8 = 0x02

        // KBDFlagsExtended1 FASTPATH_INPUT_KBDFLAGS_EXTENDED1
        KBDFlagsExtended1 uint8 = 0x04
)

func NewKeyboardEvent(flags uint8, keyCode uint8) *InputEvent <span class="cov7" title="9">{
        return &amp;InputEvent{
                EventFlags: flags,
                EventCode:  EventCodeScanCode,
                keyboardEvent: &amp;keyboardEvent{
                        KeyCode: keyCode,
                },
        }
}</span>

func (e *keyboardEvent) Serialize() []byte <span class="cov5" title="4">{
        return []byte{e.KeyCode}
}</span>

type unicodeKeyboardEvent struct {
        UnicodeCode uint16
}

func NewUnicodeKeyboardEvent(unicodeCode uint16) *InputEvent <span class="cov7" title="7">{
        return &amp;InputEvent{
                EventFlags: KBDFlagsRelease,
                EventCode:  EventCodeUnicode,
                unicodeKeyboardEvent: &amp;unicodeKeyboardEvent{
                        UnicodeCode: unicodeCode,
                },
        }
}</span>

func (e *unicodeKeyboardEvent) Serialize() []byte <span class="cov4" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, e.UnicodeCode)

        return buf.Bytes()
}</span>

const (
        PTRFlagsHWheel        uint16 = 0x0400
        PTRFlagsWheel         uint16 = 0x0200
        PTRFlagsWheelNegative uint16 = 0x0100
        PTRFlagsMove          uint16 = 0x0800
        PTRFlagsDown          uint16 = 0x8000
        PTRFlagsButton1       uint16 = 0x1000
        PTRFlagsButton2       uint16 = 0x2000
        PTRFlagsButton3       uint16 = 0x4000
)

type mouseEvent struct {
        pointerFlags uint16
        xPos         uint16
        yPos         uint16
}

func NewMouseEvent(pointerFlags, xPos, yPos uint16) *InputEvent <span class="cov8" title="10">{
        return &amp;InputEvent{
                EventCode: EventCodeMouse,
                mouseEvent: &amp;mouseEvent{
                        pointerFlags: pointerFlags,
                        xPos:         xPos,
                        yPos:         yPos,
                },
        }
}</span>

func (e *mouseEvent) Serialize() []byte <span class="cov4" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, e.pointerFlags)
        _ = binary.Write(buf, binary.LittleEndian, e.xPos)
        _ = binary.Write(buf, binary.LittleEndian, e.yPos)

        return buf.Bytes()
}</span>

const (
        PTRXFlagsDown    uint16 = 0x8000
        PTRXFlagsButton1 uint16 = 0x0001
        PTRXFlagsButton2 uint16 = 0x0002
)

type extendedMouseEvent struct {
        pointerFlags uint16
        xPos         uint16
        yPos         uint16
}

func NewExtendedMouseEvent(pointerFlags, xPos, yPos uint16) *InputEvent <span class="cov6" title="5">{
        return &amp;InputEvent{
                EventCode: EventCodeMouseX,
                extendedMouseEvent: &amp;extendedMouseEvent{
                        pointerFlags: pointerFlags,
                        xPos:         xPos,
                        yPos:         yPos,
                },
        }
}</span>

func (e *extendedMouseEvent) Serialize() []byte <span class="cov3" title="2">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, e.pointerFlags)
        _ = binary.Write(buf, binary.LittleEndian, e.xPos)
        _ = binary.Write(buf, binary.LittleEndian, e.yPos)

        return buf.Bytes()
}</span>

const (
        SyncScrollLock uint8 = 0x01
        SyncNumLock    uint8 = 0x02
        SyncCapsLock   uint8 = 0x04
        SyncKanaLock   uint8 = 0x08
)

func NewSynchronizeEvent(eventFlags uint8) *InputEvent <span class="cov8" title="10">{
        return &amp;InputEvent{
                EventFlags: eventFlags,
                EventCode:  EventCodeSync,
        }
}</span>

type qualityOfExperience struct {
        timestamp uint32
}

func NewQualityOfExperienceEvent(timestamp uint32) *InputEvent <span class="cov6" title="5">{
        return &amp;InputEvent{
                EventCode: EventCodeQoETimestamp,
                qualityOfExperience: &amp;qualityOfExperience{
                        timestamp: timestamp,
                },
        }
}</span>

func (e *qualityOfExperience) Serialize() []byte <span class="cov3" title="2">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, e.timestamp)

        return buf.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package pdu

import (
        "encoding/binary"
        "errors"
        "io"

        "github.com/rcarmo/rdp-html5/internal/codec"
)

type LicensingBinaryBlob struct {
        BlobType uint16
        BlobLen  uint16
        BlobData []byte
}

func (b *LicensingBinaryBlob) Deserialize(wire io.Reader) error <span class="cov10" title="4">{
        if err := binary.Read(wire, binary.LittleEndian, &amp;b.BlobType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="4">if err := binary.Read(wire, binary.LittleEndian, &amp;b.BlobLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="4">if b.BlobLen == 0 </span><span class="cov8" title="3">{
                return nil
        }</span>

        <span class="cov1" title="1">b.BlobData = make([]byte, b.BlobLen)

        if _, err := wire.Read(b.BlobData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type LicensingErrorMessage struct {
        ErrorCode       uint32
        StateTransition uint32
        ErrorInfo       LicensingBinaryBlob
}

func (m *LicensingErrorMessage) Deserialize(wire io.Reader) error <span class="cov5" title="2">{
        if err := binary.Read(wire, binary.LittleEndian, &amp;m.ErrorCode); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="2">if err := binary.Read(wire, binary.LittleEndian, &amp;m.StateTransition); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="2">return m.ErrorInfo.Deserialize(wire)</span>
}

type LicensingPreamble struct {
        MsgType uint8
        Flags   uint8
        MsgSize uint16
}

func (p *LicensingPreamble) Deserialize(wire io.Reader) error <span class="cov5" title="2">{
        if err := binary.Read(wire, binary.LittleEndian, &amp;p.MsgType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="2">if err := binary.Read(wire, binary.LittleEndian, &amp;p.Flags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="2">return binary.Read(wire, binary.LittleEndian, &amp;p.MsgSize)</span>
}

type ServerLicenseError struct {
        Preamble           LicensingPreamble
        ValidClientMessage LicensingErrorMessage
}

// Deserialize parses the server license response.
// Note: XRDP sends security header even with TLS, so we always expect it.
func (pdu *ServerLicenseError) Deserialize(wire io.Reader, useEnhancedSecurity bool) error <span class="cov5" title="2">{
        // Always expect security header for XRDP compatibility.
        // XRDP sends SEC_LICENSE_PKT | SEC_LICENSE_ENCRYPT_CS (0x0280) even with TLS.
        securityFlag, err := codec.UnwrapSecurityFlag(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // SEC_LICENSE_PKT = 0x0080, may be combined with SEC_LICENSE_ENCRYPT_CS = 0x0200
        <span class="cov5" title="2">if securityFlag&amp;0x0080 == 0 </span><span class="cov1" title="1">{ // SEC_LICENSE_PKT
                return errors.New("bad license header")
        }</span>

        <span class="cov1" title="1">err = pdu.Preamble.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = pdu.ValidClientMessage.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package pdu

import (
        "bytes"
        "encoding/binary"
        "strings"

        "github.com/rcarmo/rdp-html5/internal/codec"
)

type SystemTime struct {
        Year         uint16
        Month        uint16
        DayOfWeek    uint16
        Day          uint16
        Hour         uint16
        Minute       uint16
        Second       uint16
        Milliseconds uint16
}

func (t *SystemTime) Serialize() []byte <span class="cov10" title="3">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, t.Year)
        _ = binary.Write(buf, binary.LittleEndian, t.Month)
        _ = binary.Write(buf, binary.LittleEndian, t.DayOfWeek)
        _ = binary.Write(buf, binary.LittleEndian, t.Day)
        _ = binary.Write(buf, binary.LittleEndian, t.Hour)
        _ = binary.Write(buf, binary.LittleEndian, t.Minute)
        _ = binary.Write(buf, binary.LittleEndian, t.Second)
        _ = binary.Write(buf, binary.LittleEndian, t.Milliseconds)

        return buf.Bytes()
}</span>

type TimeZoneInformation struct {
        Bias         uint32
        StandardName [64]byte
        StandardDate SystemTime
        StandardBias uint32
        DaylightName [64]byte
        DaylightDate SystemTime
        DaylightBias uint32
}

func (i *TimeZoneInformation) Serialize() []byte <span class="cov1" title="1">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, i.Bias)
        _ = binary.Write(buf, binary.LittleEndian, i.StandardName)

        buf.Write(i.StandardDate.Serialize())

        _ = binary.Write(buf, binary.LittleEndian, i.StandardBias)
        _ = binary.Write(buf, binary.LittleEndian, i.DaylightName)

        buf.Write(i.DaylightDate.Serialize())

        _ = binary.Write(buf, binary.LittleEndian, i.DaylightBias)

        return buf.Bytes()
}</span>

type AddressFamily uint16

const (
        // AddressFamilyINET AF_INET IPv4
        AddressFamilyINET AddressFamily = 0x00002

        // AddressFamilyINET6 AF_INET6 IPv6
        AddressFamilyINET6 AddressFamily = 0x0017
)

type ExtendedInfoPacket struct {
        PerformanceFlags uint32
}

func (p *ExtendedInfoPacket) Serialize() []byte <span class="cov6" title="2">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(0x0002)) // ClientAddressFamily = AF_INET
        _ = binary.Write(buf, binary.LittleEndian, uint16(2))      // cbClientAddress
        buf.Write([]byte{0, 0})                                // ClientAddress
        _ = binary.Write(buf, binary.LittleEndian, uint16(2))      // cbClientDir
        buf.Write([]byte{0, 0})                                // ClientDir
        buf.Write(make([]byte, 172))                           // ClientTimeZone
        _ = binary.Write(buf, binary.LittleEndian, uint32(0))      // ClientSessionId
        _ = binary.Write(buf, binary.LittleEndian, p.PerformanceFlags)

        return buf.Bytes()
}</span>

type ClientInfoPacket struct {
        CodePage       uint32
        Flags          InfoFlag
        Domain         string
        Username       string
        Password       string
        AlternateShell string
        WorkingDir     string
        ExtraInfo      ExtendedInfoPacket
}

func (p *ClientInfoPacket) Serialize() []byte <span class="cov6" title="2">{
        cbDomain := uint16(0)
        cbUserName := uint16(0)
        cbPassword := uint16(0)
        cbAlternateShell := uint16(0)
        cbWorkingDir := uint16(0)

        domain := []byte{0x00, 0x00}
        username := []byte{0x00, 0x00}
        password := []byte{0x00, 0x00}
        alternateShell := []byte{0x00, 0x00}
        workingDir := []byte{0x00, 0x00}

        if len(p.Domain) &gt; 0 </span><span class="cov6" title="2">{
                domain = codec.Encode(strings.Trim(p.Domain, " ") + "\x00")
                cbDomain = uint16(len(domain) - 2)
        }</span>

        <span class="cov6" title="2">if len(p.Username) &gt; 0 </span><span class="cov6" title="2">{
                username = codec.Encode(strings.Trim(p.Username, " ") + "\x00")
                cbUserName = uint16(len(username) - 2)
        }</span>

        <span class="cov6" title="2">if len(p.Password) &gt; 0 </span><span class="cov6" title="2">{
                password = codec.Encode(strings.Trim(p.Password, " ") + "\x00")
                cbPassword = uint16(len(password) - 2)
        }</span>

        <span class="cov6" title="2">if len(p.AlternateShell) &gt; 0 </span><span class="cov0" title="0">{
                alternateShell = codec.Encode(strings.Trim(p.AlternateShell, " ") + "\x00")
                cbAlternateShell = uint16(len(alternateShell) - 2)
        }</span>

        <span class="cov6" title="2">if len(p.WorkingDir) &gt; 0 </span><span class="cov0" title="0">{
                workingDir = codec.Encode(strings.Trim(p.WorkingDir, " ") + "\x00")
                cbWorkingDir = uint16(len(workingDir) - 2)
        }</span>

        <span class="cov6" title="2">buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, p.CodePage)
        _ = binary.Write(buf, binary.LittleEndian, uint32(p.Flags))
        _ = binary.Write(buf, binary.LittleEndian, cbDomain)
        _ = binary.Write(buf, binary.LittleEndian, cbUserName)
        _ = binary.Write(buf, binary.LittleEndian, cbPassword)
        _ = binary.Write(buf, binary.LittleEndian, cbAlternateShell)
        _ = binary.Write(buf, binary.LittleEndian, cbWorkingDir)

        buf.Write(domain)
        buf.Write(username)
        buf.Write(password)
        buf.Write(alternateShell)
        buf.Write(workingDir)

        buf.Write(p.ExtraInfo.Serialize())

        return buf.Bytes()</span>
}

type ClientInfo struct {
        InfoPacket ClientInfoPacket
}

type InfoFlag uint32

const (
        // InfoFlagMouse INFO_MOUSE
        InfoFlagMouse InfoFlag = 0x00000001

        // InfoFlagDisableCtrlAltDel INFO_DISABLECTRLALTDEL
        InfoFlagDisableCtrlAltDel InfoFlag = 0x00000002

        // InfoFlagAutoLogon INFO_AUTOLOGON
        InfoFlagAutoLogon InfoFlag = 0x00000008

        // InfoFlagUnicode INFO_UNICODE
        InfoFlagUnicode InfoFlag = 0x00000010

        // InfoFlagMaximizeShell INFO_MAXIMIZESHELL
        InfoFlagMaximizeShell InfoFlag = 0x00000020

        // InfoFlagLogonNotify INFO_LOGONNOTIFY
        InfoFlagLogonNotify InfoFlag = 0x00000040

        // InfoFlagCompression INFO_COMPRESSION
        InfoFlagCompression InfoFlag = 0x00000080

        // InfoFlagEnableWindowsKey INFO_ENABLEWINDOWSKEY
        InfoFlagEnableWindowsKey InfoFlag = 0x00000100

        // InfoFlagRemoteConsoleAudio INFO_REMOTECONSOLEAUDIO
        InfoFlagRemoteConsoleAudio InfoFlag = 0x00002000

        // InfoFlagForceEncryptedCSPDU INFO_FORCE_ENCRYPTED_CS_PDU
        InfoFlagForceEncryptedCSPDU InfoFlag = 0x00004000

        // InfoFlagRail INFO_RAIL
        InfoFlagRail InfoFlag = 0x00008000

        // InfoFlagLogonErrors INFO_LOGONERRORS
        InfoFlagLogonErrors InfoFlag = 0x00010000

        // InfoFlagMouseHasWheel INFO_MOUSE_HAS_WHEEL
        InfoFlagMouseHasWheel InfoFlag = 0x00020000

        // InfoFlagPasswordIsSCPIN INFO_PASSWORD_IS_SC_PIN
        InfoFlagPasswordIsSCPIN InfoFlag = 0x00040000

        // InfoFlagNoAudioPlayback INFO_NOAUDIOPLAYBACK
        InfoFlagNoAudioPlayback InfoFlag = 0x00080000

        // InfoFlagUsingSavedCreds INFO_USING_SAVED_CREDS
        InfoFlagUsingSavedCreds InfoFlag = 0x00100000

        // InfoFlagAudioCapture INFO_AUDIOCAPTURE
        InfoFlagAudioCapture InfoFlag = 0x00200000

        // InfoFlagVideoDisable INFO_VIDEO_DISABLE
        InfoFlagVideoDisable InfoFlag = 0x00400000

        // InfoFlagHiDefRailSupported INFO_HIDEF_RAIL_SUPPORTED
        InfoFlagHiDefRailSupported InfoFlag = 0x02000000
)

const (
        CompressionTypeMask  uint32 = 0x00001E00
        CompressionType8K    uint32 = 0x0
        CompressionType64K   uint32 = 0x1
        CompressionTypeRDP6  uint32 = 0x2
        CompressionTypeRDP61 uint32 = 0x3
)

func NewClientInfo(domain, username, password string) *ClientInfo <span class="cov1" title="1">{
        return &amp;ClientInfo{
                InfoPacket: ClientInfoPacket{
                        // Match FreeRDP's default flags for maximum compatibility
                        // INFO_AUTOLOGON is REQUIRED for automatic login without showing the login dialog
                        Flags: InfoFlagMouse | InfoFlagUnicode | InfoFlagDisableCtrlAltDel | InfoFlagEnableWindowsKey |
                                InfoFlagLogonErrors | InfoFlagMaximizeShell | InfoFlagMouseHasWheel | InfoFlagAutoLogon,
                        Domain:    domain,
                        Username:  username,
                        Password:  password,
                        ExtraInfo: ExtendedInfoPacket{
                                //// PERF_DISABLE_WALLPAPER, PERF_DISABLE_FULLWINDOWDRAG, PERF_DISABLE_MENUANIMATIONS,
                                //// PERF_DISABLE_THEMING, PERF_DISABLE_CURSOR_SHADOW, PERF_DISABLE_CURSORSETTINGS
                                //PerformanceFlags: 0x00000001 | 0x00000002 | 0x00000004 | 0x00000008 | 0x00000020 | 0x00000040,
                        },
                },
        }
}</span>

// Serialize serializes the Client Info PDU.
// Per MS-RDPBCGR 2.2.1.11.1.1, with Enhanced RDP Security (TLS), no security header should be present.
// However, XRDP expects SEC_INFO_PKT security header even with TLS for compatibility.
// FreeRDP also always sends SEC_INFO_PKT.
func (pdu *ClientInfo) Serialize(useEnhancedSecurity bool) []byte <span class="cov6" title="2">{
        infoData := pdu.InfoPacket.Serialize()

        // Always include SEC_INFO_PKT security header for XRDP compatibility.
        // XRDP's xrdp_sec_recv expects a security header even with TLS,
        // and checks for SEC_INFO_PKT before processing logon info.
        return codec.WrapSecurityFlag(
                0x0040, // SEC_INFO_PKT
                infoData,
        )
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package tpkt

import (
        "io"
)

const (
        headerLen = 4
)

type Protocol struct {
        conn io.ReadWriteCloser
}

func New(conn io.ReadWriteCloser) *Protocol <span class="cov10" title="14">{
        return &amp;Protocol{
                conn: conn,
        }
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package tpkt

import (
        "bytes"
        "encoding/binary"
        "io"
)

func (p *Protocol) Receive() (io.Reader, error) <span class="cov10" title="7">{
        tpktPacket := make([]byte, headerLen)

        if _, err := p.conn.Read(tpktPacket); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="6">tpktPacket = tpktPacket[2:4]

        dataLen := binary.BigEndian.Uint16(tpktPacket)
        dataLen -= uint16(headerLen)

        data := make([]byte, dataLen)

        if _, err := p.conn.Read(data); err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>

        <span class="cov7" title="4">return bytes.NewBuffer(data), nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package tpkt

import (
        "bytes"
        "encoding/binary"
)

func (p *Protocol) Send(pduData []byte) error <span class="cov10" title="6">{
        buf := bytes.NewBuffer(make([]byte, 0, headerLen+len(pduData)))
        dataLen := uint16(headerLen + len(pduData))

        buf.Write([]byte{
                0x03, // TPKT version number
                0x00, // reserved for further study
        })

        // TPKT length
        _ = binary.Write(buf, binary.BigEndian, dataLen)

        buf.Write(pduData)

        if _, err := p.conn.Write(buf.Bytes()); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package x224

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
)

type ConnectionRequest struct {
        li           uint8
        CRCDT        uint8
        DSTREF       uint16
        SRCREF       uint16
        ClassOption  uint8
        VariablePart []byte // unsupported
        UserData     []byte
}

func (pdu *ConnectionRequest) Serialize() []byte <span class="cov7" title="10">{
        const x224FixedPartLen = 6 // without length indicator (LI)

        pdu.li = uint8(x224FixedPartLen + len(pdu.UserData))

        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.BigEndian, pdu.li)
        _ = binary.Write(buf, binary.BigEndian, pdu.CRCDT)
        _ = binary.Write(buf, binary.BigEndian, pdu.DSTREF)
        _ = binary.Write(buf, binary.BigEndian, pdu.SRCREF)
        _ = binary.Write(buf, binary.BigEndian, pdu.ClassOption)

        buf.Write(pdu.UserData)

        return buf.Bytes()
}</span>

type ConnectionConfirm struct {
        LI          uint8
        CCCDT       uint8
        DSTREF      uint16
        SRCREF      uint16
        ClassOption uint8
}

func (pdu *ConnectionConfirm) Deserialize(wire io.Reader) error <span class="cov10" title="23">{
        const (
                fixedPartLen    uint8 = 0x06
                variablePartLen uint8 = 0x08
                packetLen             = fixedPartLen + variablePartLen
        )

        err := binary.Read(wire, binary.BigEndian, &amp;pdu.LI)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="22">if pdu.LI != packetLen </span><span class="cov4" title="3">{
                return ErrSmallConnectionConfirmLength
        }</span>

        <span class="cov9" title="19">err = binary.Read(wire, binary.BigEndian, &amp;pdu.CCCDT)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="18">if pdu.CCCDT&amp;0xf0 != 0xd0 </span><span class="cov6" title="7">{ // connection confirm code
                return ErrWrongConnectionConfirmCode
        }</span>

        <span class="cov7" title="11">err = binary.Read(wire, binary.BigEndian, &amp;pdu.DSTREF)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="10">err = binary.Read(wire, binary.BigEndian, &amp;pdu.SRCREF)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="9">err = binary.Read(wire, binary.BigEndian, &amp;pdu.ClassOption)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="8">return nil</span>
}

func (p *Protocol) Connect(userData []byte) (io.Reader, error) <span class="cov5" title="5">{
        var (
                wire io.Reader
                err  error
        )

        req := ConnectionRequest{
                CRCDT:        0xE0, // TPDU_CONNECTION_REQUEST
                DSTREF:       0,
                SRCREF:       0,
                ClassOption:  0,
                VariablePart: nil,
                UserData:     userData,
        }

        if err = p.tpktConn.Send(req.Serialize()); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("client connection request: %w", err)
        }</span>

        <span class="cov4" title="4">wire, err = p.tpktConn.Receive()
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("recieve connection response: %w", err)
        }</span>

        <span class="cov4" title="3">var resp ConnectionConfirm
        if err = resp.Deserialize(wire); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("server connection confirm: %w", err)
        }</span>

        <span class="cov1" title="1">return wire, nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package x224

import (
        "io"

        "github.com/rcarmo/rdp-html5/internal/protocol/tpkt"
)

// tpktConnection is the interface that wraps tpkt protocol operations
type tpktConnection interface {
        Receive() (io.Reader, error)
        Send(pduData []byte) error
}

// Protocol handles X.224 protocol operations
type Protocol struct {
        tpktConn tpktConnection
}

// New creates a new X.224 protocol handler
func New(tpktConn *tpkt.Protocol) *Protocol <span class="cov1" title="1">{
        return &amp;Protocol{
                tpktConn: tpktConn,
        }
}</span>

// NewWithConn creates a new X.224 protocol handler with an interface (for testing)
func NewWithConn(conn tpktConnection) *Protocol <span class="cov10" title="14">{
        return &amp;Protocol{
                tpktConn: conn,
        }
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package x224

import (
        "io"
)

func (p *Protocol) Receive() (io.Reader, error) <span class="cov10" title="4">{
        wire, err := p.tpktConn.Receive()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="3">var resp Data

        if err = resp.Deserialize(wire); err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return wire, nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package x224

import (
        "bytes"
        "encoding/binary"
        "io"
)

type Data struct {
        LI       uint8
        DTROA    uint8
        NREOT    uint8
        UserData []byte
}

func (pdu *Data) Serialize() []byte <span class="cov9" title="9">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.BigEndian, pdu.LI)
        _ = binary.Write(buf, binary.BigEndian, pdu.DTROA)
        _ = binary.Write(buf, binary.BigEndian, pdu.NREOT)

        buf.Write(pdu.UserData)

        return buf.Bytes()
}</span>

func (pdu *Data) Deserialize(wire io.Reader) error <span class="cov10" title="11">{
        err := binary.Read(wire, binary.BigEndian, &amp;pdu.LI)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov9" title="9">if pdu.LI != dataFixedPartLen </span><span class="cov5" title="3">{
                return ErrWrongDataLength
        }</span>

        <span class="cov7" title="6">err = binary.Read(wire, binary.BigEndian, &amp;pdu.DTROA)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="5">err = binary.Read(wire, binary.BigEndian, &amp;pdu.NREOT)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="4">return nil</span>
}

const dataFixedPartLen uint8 = 0x02

func (p *Protocol) Send(userData []byte) error <span class="cov6" title="4">{

        req := Data{
                LI:       dataFixedPartLen,
                DTROA:    0xF0, // message type TPDU_DATA
                NREOT:    0x80, // EOT flag is up, which indicates that current TPDU is the last data unit of a complete TPDU sequence
                UserData: userData,
        }

        return p.tpktConn.Send(req.Serialize())
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package rdp

import (
        "bytes"

        "github.com/rcarmo/rdp-html5/internal/logging"
        "github.com/rcarmo/rdp-html5/internal/protocol/audio"
)

// AudioCallback is called when audio data is available to send to the client
type AudioCallback func(data []byte, format *audio.AudioFormat, timestamp uint16)

// AudioHandler manages RDPSND protocol for audio output
type AudioHandler struct {
        client           *Client
        callback         AudioCallback
        enabled          bool
        serverFormats    []audio.AudioFormat
        selectedFormat   int
        defragmenter     audio.ChannelDefragmenter
        pendingWaveInfo  *audio.WaveInfoPDU
}

// NewAudioHandler creates a new audio handler
func NewAudioHandler(client *Client) *AudioHandler <span class="cov10" title="13">{
        return &amp;AudioHandler{
                client:         client,
                selectedFormat: -1,
        }
}</span>

// SetCallback sets the function to call when audio data is available
func (h *AudioHandler) SetCallback(cb AudioCallback) <span class="cov3" title="2">{
        h.callback = cb
}</span>

// Enable enables audio redirection
func (h *AudioHandler) Enable() <span class="cov8" title="9">{
        h.enabled = true
}</span>

// Disable disables audio redirection
func (h *AudioHandler) Disable() <span class="cov1" title="1">{
        h.enabled = false
}</span>

// IsEnabled returns whether audio is enabled
func (h *AudioHandler) IsEnabled() bool <span class="cov5" title="4">{
        return h.enabled
}</span>

// GetSelectedFormat returns the currently negotiated audio format
func (h *AudioHandler) GetSelectedFormat() *audio.AudioFormat <span class="cov3" title="2">{
        if h.selectedFormat &gt;= 0 &amp;&amp; h.selectedFormat &lt; len(h.serverFormats) </span><span class="cov1" title="1">{
                return &amp;h.serverFormats[h.selectedFormat]
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// HandleChannelData processes RDPSND channel data
func (h *AudioHandler) HandleChannelData(data []byte) error <span class="cov7" title="7">{
        if !h.enabled </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Parse channel PDU
        <span class="cov7" title="6">chunk, err := audio.ParseChannelData(data)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Handle fragmentation
        <span class="cov6" title="5">completeData, complete := h.defragmenter.Process(chunk)
        if !complete </span><span class="cov0" title="0">{
                return nil // Wait for more fragments
        }</span>

        // Parse RDPSND PDU
        <span class="cov6" title="5">if len(completeData) &lt; 4 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="5">r := bytes.NewReader(completeData)
        var header audio.PDUHeader
        if err := header.Deserialize(r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="5">body := completeData[4:]

        switch header.MsgType </span>{
        case audio.SND_FORMATS:<span class="cov1" title="1">
                return h.handleServerFormats(body)</span>
        case audio.SND_TRAINING:<span class="cov1" title="1">
                return h.handleTraining(body)</span>
        case audio.SND_WAVE:<span class="cov0" title="0">
                return h.handleWave(body)</span>
        case audio.SND_WAVE2:<span class="cov1" title="1">
                return h.handleWave2(body)</span>
        case audio.SND_CLOSE:<span class="cov0" title="0">
                logging.Info("Audio: Server closed audio channel")
                return nil</span>
        default:<span class="cov3" title="2">
                logging.Debug("Audio: Unknown RDPSND message type: 0x%02X", header.MsgType)</span>
        }

        <span class="cov3" title="2">return nil</span>
}

// handleServerFormats processes SNDC_FORMATS from server
func (h *AudioHandler) handleServerFormats(body []byte) error <span class="cov1" title="1">{
        var serverFormats audio.ServerAudioFormats
        if err := serverFormats.Deserialize(body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">logging.Info("Audio: Server offers %d formats (version %d)", serverFormats.NumFormats, serverFormats.Version)

        h.serverFormats = serverFormats.Formats

        // Find a format we support - prefer PCM for simplicity with Web Audio
        selectedIndex := -1
        for i, format := range serverFormats.Formats </span><span class="cov0" title="0">{
                logging.Debug("Audio:   Format %d: %s", i, format.String())
                // We can handle PCM directly in Web Audio
                if format.FormatTag == audio.WAVE_FORMAT_PCM </span><span class="cov0" title="0">{
                        if selectedIndex == -1 </span><span class="cov0" title="0">{
                                selectedIndex = i
                        }</span>
                        // Prefer 16-bit stereo 44100 Hz
                        <span class="cov0" title="0">if format.BitsPerSample == 16 &amp;&amp; format.Channels == 2 &amp;&amp; format.SamplesPerSec == 44100 </span><span class="cov0" title="0">{
                                selectedIndex = i
                        }</span>
                }
        }

        <span class="cov1" title="1">if selectedIndex == -1 </span><span class="cov1" title="1">{
                logging.Debug("Audio: No compatible format found, using first available")
                selectedIndex = 0
        }</span>

        <span class="cov1" title="1">if len(h.serverFormats) == 0 </span><span class="cov1" title="1">{
                logging.Warn("Audio: No formats available from server")
                return nil
        }</span>

        <span class="cov0" title="0">h.selectedFormat = selectedIndex
        logging.Info("Audio: Selected format %d: %s", selectedIndex, h.serverFormats[selectedIndex].String())

        // Send client response with supported formats
        return h.sendClientFormats(serverFormats.Formats, serverFormats.Version)</span>
}

// sendClientFormats sends SNDC_FORMATS response to server
func (h *AudioHandler) sendClientFormats(formats []audio.AudioFormat, version uint16) error <span class="cov0" title="0">{
        // Echo back formats we support (just PCM for now)
        var supportedFormats []audio.AudioFormat
        for _, format := range formats </span><span class="cov0" title="0">{
                if format.FormatTag == audio.WAVE_FORMAT_PCM </span><span class="cov0" title="0">{
                        supportedFormats = append(supportedFormats, format)
                }</span>
        }

        // If no PCM formats, accept all (server will send what it can)
        <span class="cov0" title="0">if len(supportedFormats) == 0 </span><span class="cov0" title="0">{
                supportedFormats = formats
        }</span>

        <span class="cov0" title="0">clientFormats := audio.ClientAudioFormats{
                Version:        version,
                Padding:        0,
                VolumePDUFlags: 0,
                Padding2:       0,
                NumFormats:     uint16(len(supportedFormats)),
                CbMaxPDUSize:   0,
                Pad:            0,
                Formats:        supportedFormats,
        }

        body := clientFormats.Serialize()
        pdu := audio.BuildChannelPDU(audio.SND_FORMATS, body)

        // Send on rdpsnd channel
        channelID, ok := h.client.channelIDMap[audio.ChannelRDPSND]
        if !ok </span><span class="cov0" title="0">{
                logging.Warn("Audio: rdpsnd channel not found")
                return nil
        }</span>

        <span class="cov0" title="0">return h.client.mcsLayer.Send(h.client.userID, channelID, pdu)</span>
}

// handleTraining processes SNDC_TRAINING from server
func (h *AudioHandler) handleTraining(body []byte) error <span class="cov1" title="1">{
        var training audio.TrainingPDU
        if err := training.Deserialize(body); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">logging.Debug("Audio: Training packet timestamp=%d size=%d", training.Timestamp, training.PackSize)

        // Send confirmation
        confirm := audio.TrainingConfirmPDU{
                Timestamp: training.Timestamp,
                PackSize:  training.PackSize,
        }

        pdu := audio.BuildChannelPDU(audio.SND_TRAINING_CONFIRM, confirm.Serialize())

        channelID, ok := h.client.channelIDMap[audio.ChannelRDPSND]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return h.client.mcsLayer.Send(h.client.userID, channelID, pdu)</span>
}

// handleWave processes SNDC_WAVE from server (first part of audio)
func (h *AudioHandler) handleWave(body []byte) error <span class="cov0" title="0">{
        var waveInfo audio.WaveInfoPDU
        if err := waveInfo.Deserialize(body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">h.pendingWaveInfo = &amp;waveInfo

        // The rest of the data follows in the same PDU after the header
        audioData := body[12:] // Skip WaveInfo header

        // Combine initial data with rest
        fullData := append(waveInfo.InitialData, audioData...)

        if h.callback != nil &amp;&amp; len(fullData) &gt; 0 </span><span class="cov0" title="0">{
                var format *audio.AudioFormat
                if int(waveInfo.FormatNo) &lt; len(h.serverFormats) </span><span class="cov0" title="0">{
                        format = &amp;h.serverFormats[waveInfo.FormatNo]
                }</span>
                <span class="cov0" title="0">h.callback(fullData, format, waveInfo.Timestamp)</span>
        }

        // Send wave confirm
        <span class="cov0" title="0">return h.sendWaveConfirm(waveInfo.Timestamp, waveInfo.BlockNo)</span>
}

// handleWave2 processes SNDC_WAVE2 from server (simplified wave PDU)
func (h *AudioHandler) handleWave2(body []byte) error <span class="cov1" title="1">{
        var wave2 audio.Wave2PDU
        if err := wave2.Deserialize(body); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">if h.callback != nil &amp;&amp; len(wave2.Data) &gt; 0 </span><span class="cov0" title="0">{
                var format *audio.AudioFormat
                if int(wave2.FormatNo) &lt; len(h.serverFormats) </span><span class="cov0" title="0">{
                        format = &amp;h.serverFormats[wave2.FormatNo]
                }</span>
                <span class="cov0" title="0">h.callback(wave2.Data, format, wave2.Timestamp)</span>
        }

        // Send wave confirm
        <span class="cov0" title="0">return h.sendWaveConfirm(wave2.Timestamp, wave2.BlockNo)</span>
}

// sendWaveConfirm sends SNDC_WAVECONFIRM to server
func (h *AudioHandler) sendWaveConfirm(timestamp uint16, blockNo uint8) error <span class="cov0" title="0">{
        confirm := audio.WaveConfirmPDU{
                Timestamp:      timestamp,
                ConfirmedBlock: blockNo,
                Padding:        0,
        }

        pdu := audio.BuildChannelPDU(audio.SND_WAVE_CONFIRM, confirm.Serialize())

        channelID, ok := h.client.channelIDMap[audio.ChannelRDPSND]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return h.client.mcsLayer.Send(h.client.userID, channelID, pdu)</span>
}

// EnableAudio registers the rdpsnd channel for audio redirection
func (c *Client) EnableAudio() <span class="cov4" title="3">{
        if c.channels == nil </span><span class="cov0" title="0">{
                c.channels = []string{}
        }</span>
        // Check if already added
        <span class="cov4" title="3">for _, ch := range c.channels </span><span class="cov1" title="1">{
                if ch == audio.ChannelRDPSND </span><span class="cov1" title="1">{
                        return
                }</span>
        }
        <span class="cov3" title="2">c.channels = append(c.channels, audio.ChannelRDPSND)
        // Create audio handler
        c.audioHandler = NewAudioHandler(c)
        c.audioHandler.Enable()</span>
}

// GetAudioHandler returns the audio handler
func (c *Client) GetAudioHandler() *AudioHandler <span class="cov3" title="2">{
        return c.audioHandler
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package rdp

import (
        "github.com/rcarmo/rdp-html5/internal/protocol/pdu"
)

func (c *Client) capabilitiesExchange() error <span class="cov10" title="2">{
        _, wire, err := c.mcsLayer.Receive()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">var resp pdu.ServerDemandActive
        if err = resp.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">c.shareID = resp.ShareID
        c.serverCapabilitySets = resp.CapabilitySets

        req := pdu.NewClientConfirmActive(resp.ShareID, c.userID, c.desktopWidth, c.desktopHeight, c.remoteApp != nil)

        return c.mcsLayer.Send(c.userID, c.channelIDMap["global"], req.Serialize())</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package rdp

import (
        "bufio"
        "fmt"
        "net"
        "strings"
        "time"

        "github.com/rcarmo/rdp-html5/internal/protocol/fastpath"
        "github.com/rcarmo/rdp-html5/internal/protocol/mcs"
        "github.com/rcarmo/rdp-html5/internal/protocol/pdu"
        "github.com/rcarmo/rdp-html5/internal/protocol/tpkt"
        "github.com/rcarmo/rdp-html5/internal/protocol/x224"
)

type RemoteApp struct {
        App        string
        WorkingDir string
        Args       string
}

type Client struct {
        conn       net.Conn
        buffReader *bufio.Reader
        tpktLayer  *tpkt.Protocol
        x224Layer  *x224.Protocol
        mcsLayer   mcs.MCSLayer
        fastPath   *fastpath.Protocol

        domain   string
        username string
        password string

        desktopWidth, desktopHeight uint16
        colorDepth                  int

        serverCapabilitySets []pdu.CapabilitySet
        remoteApp            *RemoteApp
        railState            RailState

        selectedProtocol       pdu.NegotiationProtocol
        serverNegotiationFlags pdu.NegotiationResponseFlag
        channels               []string
        channelIDMap           map[string]uint16
        skipChannelJoin        bool
        shareID                uint32
        userID                 uint16

        // TLS configuration
        skipTLSValidation bool
        tlsServerName     string

        // NLA configuration
        useNLA bool

        // Audio handler
        audioHandler *AudioHandler
}

const (
        tcpConnectionTimeout = 5 * time.Second
        readBufferSize       = 64 * 1024
)

func NewClient(
        hostname, username, password string,
        desktopWidth, desktopHeight int,
        colorDepth int,
) (*Client, error) <span class="cov6" title="8">{
        // Add default RDP port if not specified
        if !strings.Contains(hostname, ":") </span><span class="cov2" title="2">{
                hostname = hostname + ":3389"
        }</span>

        <span class="cov6" title="8">c := Client{
                domain:   "",
                username: username,
                password: password,

                desktopWidth:  uint16(desktopWidth),
                desktopHeight: uint16(desktopHeight),
                colorDepth:    colorDepth,

                selectedProtocol: pdu.NegotiationProtocolSSL,
                // Default TLS configuration - can be overridden with SetTLSConfig
                skipTLSValidation: false,
                tlsServerName:     "",
        }

        var err error

        c.conn, err = net.DialTimeout("tcp", hostname, tcpConnectionTimeout)
        if err != nil </span><span class="cov6" title="8">{
                return nil, fmt.Errorf("tcp connect: %w", err)
        }</span>

        <span class="cov0" title="0">c.buffReader = bufio.NewReaderSize(c.conn, readBufferSize)

        c.tpktLayer = tpkt.New(&amp;c)
        c.x224Layer = x224.New(c.tpktLayer)
        c.mcsLayer = mcs.New(c.x224Layer)
        c.fastPath = fastpath.New(&amp;c)

        return &amp;c, nil</span>
}

// SetTLSConfig allows setting TLS configuration for the RDP client
func (c *Client) SetTLSConfig(skipValidation bool, serverName string) <span class="cov6" title="7">{
        c.skipTLSValidation = skipValidation
        c.tlsServerName = serverName
}</span>

// SetUseNLA enables or disables Network Level Authentication
func (c *Client) SetUseNLA(useNLA bool) <span class="cov4" title="4">{
        c.useNLA = useNLA
        if useNLA </span><span class="cov4" title="3">{
                c.selectedProtocol = pdu.NegotiationProtocolHybrid
        }</span> else<span class="cov1" title="1"> {
                c.selectedProtocol = pdu.NegotiationProtocolSSL
        }</span>
}

// Known codec GUIDs
var (
        guidNSCodec    = [16]byte{0xB9, 0x1B, 0x8D, 0xCA, 0x0F, 0x00, 0x4F, 0x15, 0x58, 0x9F, 0xAE, 0x2D, 0x1A, 0x87, 0xE2, 0xD6}
        guidRemoteFX   = [16]byte{0x76, 0x77, 0x2F, 0x12, 0xBD, 0x72, 0x44, 0x63, 0xAF, 0xB3, 0xB7, 0x3C, 0x9C, 0x6F, 0x78, 0x86}
        guidImageRemoteFX = [16]byte{0x2C, 0x31, 0xF9, 0x2C, 0x95, 0x78, 0x47, 0x45, 0x80, 0x97, 0x43, 0x60, 0xDF, 0x10, 0x3F, 0x59}
        guidClearCodec = [16]byte{0xE3, 0x1C, 0x97, 0xA6, 0x58, 0x8D, 0x5B, 0x42, 0xAC, 0x18, 0xE0, 0x9B, 0x7D, 0x42, 0xC7, 0xD5}
)

func codecGUIDToName(guid [16]byte) string <span class="cov8" title="14">{
        switch guid </span>{
        case guidNSCodec:<span class="cov4" title="3">
                return "NSCodec"</span>
        case guidRemoteFX:<span class="cov4" title="3">
                return "RemoteFX"</span>
        case guidImageRemoteFX:<span class="cov2" title="2">
                return "RemoteFX-Image"</span>
        case guidClearCodec:<span class="cov4" title="3">
                return "ClearCodec"</span>
        default:<span class="cov4" title="3">
                return fmt.Sprintf("Unknown(%x)", guid[:4])</span>
        }
}

// ServerCapabilityInfo contains a summary of server capabilities for logging
type ServerCapabilityInfo struct {
        BitmapCodecs      []string
        SurfaceCommands   bool
        ColorDepth        int
        DesktopSize       string
        GeneralFlags      uint16
        OrderFlags        uint32
        MultifragmentSize uint32
        LargePointer      bool
        FrameAcknowledge  bool
}

// Update represents an RDP screen update that can be sent to a client.
// This provides a public interface without exposing internal protocol details.
type Update struct {
        Data []byte
}

// GetServerCapabilities returns a summary of the server's capabilities
func (c *Client) GetServerCapabilities() *ServerCapabilityInfo <span class="cov7" title="12">{
        info := &amp;ServerCapabilityInfo{
                BitmapCodecs: []string{},
        }

        for _, capSet := range c.serverCapabilitySets </span><span class="cov10" title="25">{
                switch capSet.CapabilitySetType </span>{
                case pdu.CapabilitySetTypeBitmap:<span class="cov4" title="4">
                        if capSet.BitmapCapabilitySet != nil </span><span class="cov4" title="3">{
                                info.ColorDepth = int(capSet.BitmapCapabilitySet.PreferredBitsPerPixel)
                                info.DesktopSize = fmt.Sprintf("%dx%d", 
                                        capSet.BitmapCapabilitySet.DesktopWidth, 
                                        capSet.BitmapCapabilitySet.DesktopHeight)
                        }</span>
                case pdu.CapabilitySetTypeGeneral:<span class="cov4" title="3">
                        if capSet.GeneralCapabilitySet != nil </span><span class="cov4" title="3">{
                                info.GeneralFlags = capSet.GeneralCapabilitySet.ExtraFlags
                        }</span>
                case pdu.CapabilitySetTypeOrder:<span class="cov4" title="3">
                        if capSet.OrderCapabilitySet != nil </span><span class="cov4" title="3">{
                                info.OrderFlags = uint32(capSet.OrderCapabilitySet.OrderFlags)
                        }</span>
                case pdu.CapabilitySetTypeSurfaceCommands:<span class="cov4" title="3">
                        info.SurfaceCommands = true</span>
                case pdu.CapabilitySetTypeBitmapCodecs:<span class="cov4" title="3">
                        if capSet.BitmapCodecsCapabilitySet != nil </span><span class="cov4" title="3">{
                                for _, codec := range capSet.BitmapCodecsCapabilitySet.BitmapCodecArray </span><span class="cov6" title="7">{
                                        info.BitmapCodecs = append(info.BitmapCodecs, codecGUIDToName(codec.CodecGUID))
                                }</span>
                        }
                case pdu.CapabilitySetTypeMultifragmentUpdate:<span class="cov4" title="3">
                        if capSet.MultifragmentUpdateCapabilitySet != nil </span><span class="cov4" title="3">{
                                info.MultifragmentSize = capSet.MultifragmentUpdateCapabilitySet.MaxRequestSize
                        }</span>
                case pdu.CapabilitySetTypeLargePointer:<span class="cov4" title="3">
                        info.LargePointer = true</span>
                case pdu.CapabilitySetTypeFrameAcknowledge:<span class="cov4" title="3">
                        info.FrameAcknowledge = true</span>
                }
        }

        <span class="cov7" title="12">return info</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package rdp

func (c *Client) Close() error <span class="cov10" title="2">{
        if c.remoteApp != nil </span><span class="cov1" title="1">{
                c.railState = RailStateUninitialized
        }</span>

        <span class="cov10" title="2">return c.conn.Close()</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package rdp

import (
        "fmt"
        "io"
        "time"

        "github.com/rcarmo/rdp-html5/internal/logging"
        "github.com/rcarmo/rdp-html5/internal/protocol/pdu"
)

func (c *Client) Connect() error <span class="cov0" title="0">{
        var err error

        if err = c.connectionInitiation(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connection initiation: %w", err)
        }</span>

        <span class="cov0" title="0">if err = c.basicSettingsExchange(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("basic settings exchange: %w", err)
        }</span>

        <span class="cov0" title="0">if err = c.channelConnection(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("channel connection: %w", err)
        }</span>

        <span class="cov0" title="0">if err = c.secureSettingsExchange(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("secure settings exchange: %w", err)
        }</span>

        <span class="cov0" title="0">if err = c.licensing(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("licensing: %w", err)
        }</span>

        <span class="cov0" title="0">if err = c.capabilitiesExchange(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("capabilities exchange: %w", err)
        }</span>

        <span class="cov0" title="0">if err = c.connectionFinalization(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connection finalizatioin: %w", err)
        }</span>

        // Request a full screen refresh from the server
        <span class="cov0" title="0">if err = c.sendRefreshRect(); err != nil </span><span class="cov0" title="0">{
                logging.Warn("RDP: Failed to send refresh rect: %v", err)
                // Don't fail the connection if refresh rect fails
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) connectionInitiation() error <span class="cov0" title="0">{
        var err error

        // Request both SSL and Hybrid (NLA) protocols - server will pick what it supports
        // If useNLA is set, we prefer NLA but will fall back to SSL
        requestedProtocol := c.selectedProtocol
        if c.useNLA </span><span class="cov0" title="0">{
                // Request both SSL and Hybrid so server can choose
                requestedProtocol = pdu.NegotiationProtocolSSL | pdu.NegotiationProtocolHybrid
        }</span>

        <span class="cov0" title="0">req := pdu.ClientConnectionRequest{
                NegotiationRequest: pdu.NegotiationRequest{
                        RequestedProtocols: requestedProtocol,
                },
        }

        var (
                resp pdu.ServerConnectionConfirm
                wire io.Reader
        )

        if wire, err = c.x224Layer.Connect(req.Serialize()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = resp.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if resp.Type.IsFailure() </span><span class="cov0" title="0">{
                failureCode := resp.FailureCode()

                // Provide helpful error messages
                switch failureCode </span>{
                case pdu.NegotiationFailureCodeHybridRequired:<span class="cov0" title="0">
                        return fmt.Errorf("server requires Network Level Authentication (NLA/CredSSP). Enable NLA in config or set USE_NLA=true environment variable")</span>
                case pdu.NegotiationFailureCodeSSLRequired:<span class="cov0" title="0">
                        return fmt.Errorf("server requires SSL/TLS but negotiation failed")</span>
                case pdu.NegotiationFailureCodeSSLWithUserAuthRequired:<span class="cov0" title="0">
                        return fmt.Errorf("server requires SSL with user authentication")</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("negotiation failure: %s (code=%d)", failureCode.String(), uint32(failureCode))</span>
                }
        }

        <span class="cov0" title="0">c.serverNegotiationFlags = resp.Flags

        selectedProto := resp.SelectedProtocol()

        // Update selectedProtocol to what the server actually chose
        c.selectedProtocol = selectedProto

        // Handle Hybrid (NLA) protocol - preferred when available
        if selectedProto.IsHybrid() </span><span class="cov0" title="0">{
                return c.StartNLA()
        }</span>

        // Handle SSL protocol
        <span class="cov0" title="0">if selectedProto.IsSSL() </span><span class="cov0" title="0">{
                return c.StartTLS()
        }</span>

        // Handle standard RDP (no encryption/basic security)
        <span class="cov0" title="0">if selectedProto.IsRDP() </span><span class="cov0" title="0">{
                // Server selected standard RDP - NLA not supported by server
                return nil
        }</span>
        <span class="cov0" title="0">return ErrUnsupportedRequestedProtocol</span>
}

func (c *Client) basicSettingsExchange() error <span class="cov0" title="0">{
        clientUserDataSet := pdu.NewClientUserDataSet(uint32(c.selectedProtocol), c.desktopWidth, c.desktopHeight, c.colorDepth, c.channels)

        wire, err := c.mcsLayer.Connect(clientUserDataSet.Serialize())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var serverUserData pdu.ServerUserData
        err = serverUserData.Deserialize(wire)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.initChannels(serverUserData.ServerNetworkData)

        // RNS_UD_SC_SKIP_CHANNELJOIN_SUPPORTED = 0x00000008
        // This flag means the server SUPPORTS skipping, but we should only skip if we also requested it
        // For now, always do channel join for maximum compatibility (especially with XRDP)
        // c.skipChannelJoin = serverUserData.ServerCoreData.EarlyCapabilityFlags&amp;0x8 == 0x8
        c.skipChannelJoin = false // Always do channel join for compatibility

        return nil</span>
}

func (c *Client) initChannels(serverNetworkData *pdu.ServerNetworkData) <span class="cov7" title="7">{
        if c.channelIDMap == nil </span><span class="cov1" title="1">{
                c.channelIDMap = make(map[string]uint16)
        }</span>

        <span class="cov7" title="7">for i, channelName := range c.channels </span><span class="cov9" title="10">{
                if i &lt; len(serverNetworkData.ChannelIdArray) </span><span class="cov9" title="10">{
                        c.channelIDMap[channelName] = serverNetworkData.ChannelIdArray[i]
                }</span>
        }

        <span class="cov7" title="7">c.channelIDMap["global"] = serverNetworkData.MCSChannelId</span>
}

func (c *Client) channelConnection() error <span class="cov6" title="5">{
        err := c.mcsLayer.ErectDomain()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov5" title="4">c.userID, err = c.mcsLayer.AttachUser()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="3">c.channelIDMap["user"] = c.userID

        if c.skipChannelJoin </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="2">err = c.mcsLayer.JoinChannels(c.userID, c.channelIDMap)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (c *Client) secureSettingsExchange() error <span class="cov4" title="3">{
        clientInfoPDU := pdu.NewClientInfo(c.domain, c.username, c.password)

        if c.remoteApp != nil </span><span class="cov1" title="1">{
                clientInfoPDU.InfoPacket.Flags |= pdu.InfoFlagRail
        }</span>

        // Per MS-RDPBCGR 2.2.1.11.1.1: security header MUST NOT be present when Enhanced RDP Security (TLS) is in effect
        <span class="cov4" title="3">useEnhancedSecurity := c.selectedProtocol.IsSSL() || c.selectedProtocol.IsHybrid()
        data := clientInfoPDU.Serialize(useEnhancedSecurity)

        if err := c.mcsLayer.Send(c.userID, c.channelIDMap["global"], data); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("client info: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

func min(a, b int) int <span class="cov10" title="13">{
        if a &lt; b </span><span class="cov7" title="7">{
                return a
        }</span>
        <span class="cov7" title="6">return b</span>
}

func (c *Client) licensing() error <span class="cov3" title="2">{
        // Per MS-RDPBCGR, when Enhanced RDP Security (TLS) is in effect, the security header is not present
        useEnhancedSecurity := c.selectedProtocol.IsSSL() || c.selectedProtocol.IsHybrid()

        // Set a read deadline so we don't hang forever
        if c.conn != nil </span><span class="cov0" title="0">{
                _ = c.conn.SetReadDeadline(time.Now().Add(10 * time.Second))
                defer func() </span><span class="cov0" title="0">{ _ = c.conn.SetReadDeadline(time.Time{}) }</span>() // Clear deadline
        }

        <span class="cov3" title="2">_, wire, err := c.mcsLayer.Receive()
        if err != nil </span><span class="cov0" title="0">{
                errStr := err.Error()
                // Check for disconnect ultimatum which often means authentication failed
                if errStr == "disconnect ultimatum" </span><span class="cov0" title="0">{
                        return fmt.Errorf("server disconnected during licensing - possible causes: 1) Invalid credentials, 2) Account locked, 3) NLA required but not negotiated, 4) XRDP session limit reached")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("licensing receive: %w", err)</span>
        }

        <span class="cov3" title="2">var resp pdu.ServerLicenseError
        if err = resp.Deserialize(wire, useEnhancedSecurity); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server license error: %w", err)
        }</span>

        <span class="cov3" title="2">if resp.Preamble.MsgType == 0x03 </span><span class="cov1" title="1">{ // NEW_LICENSE
                return nil
        }</span>

        <span class="cov1" title="1">if resp.Preamble.MsgType != 0xFF </span><span class="cov0" title="0">{ // ERROR_ALERT
                return fmt.Errorf("unknown license msg type: 0x%02X", resp.Preamble.MsgType)
        }</span>

        <span class="cov1" title="1">if resp.ValidClientMessage.ErrorCode != 0x00000007 </span><span class="cov0" title="0">{ // STATUS_VALID_CLIENT
                return fmt.Errorf("license error code: 0x%08X (expected STATUS_VALID_CLIENT 0x00000007)", resp.ValidClientMessage.ErrorCode)
        }</span>

        <span class="cov1" title="1">if resp.ValidClientMessage.StateTransition != 0x00000002 </span><span class="cov0" title="0">{ // ST_NO_TRANSITION
                return fmt.Errorf("license state transition: 0x%08X (expected ST_NO_TRANSITION 0x00000002)", resp.ValidClientMessage.StateTransition)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package rdp

import (
        "fmt"
        "io"

        "github.com/rcarmo/rdp-html5/internal/protocol/pdu"
)

func (c *Client) connectionFinalization() error <span class="cov4" title="2">{
        var err error

        synchronize := pdu.NewSynchronize(c.shareID, c.userID)
        if err = c.mcsLayer.Send(c.userID, c.channelIDMap["global"], synchronize.Serialize()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">controlCooperate := pdu.NewControl(c.shareID, c.userID, pdu.ControlActionCooperate)
        if err = c.mcsLayer.Send(c.userID, c.channelIDMap["global"], controlCooperate.Serialize()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">controlRequestControl := pdu.NewControl(c.shareID, c.userID, pdu.ControlActionRequestControl)
        if err = c.mcsLayer.Send(c.userID, c.channelIDMap["global"], controlRequestControl.Serialize()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">fontList := pdu.NewFontList(c.shareID, c.userID)

        err = c.mcsLayer.Send(c.userID, c.channelIDMap["global"], fontList.Serialize())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">var (
                serverSynchronizeReceived bool
                controlCooperateReceived  bool
                grantedControlReceived    bool
                fontMapReceived           bool

                dataPDU *pdu.Data
                wire    io.Reader
        )

        for !serverSynchronizeReceived || !controlCooperateReceived || !grantedControlReceived || !fontMapReceived </span><span class="cov10" title="5">{
                _, wire, err = c.mcsLayer.Receive()
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov8" title="4">dataPDU = &amp;pdu.Data{}
                if err = dataPDU.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="4">pduType2 := dataPDU.ShareDataHeader.PDUType2

                switch </span>{
                case pduType2.IsSynchronize():<span class="cov1" title="1">
                        serverSynchronizeReceived = true</span>
                case pduType2.IsControl():<span class="cov4" title="2">
                        if dataPDU.ControlPDUData.Action == pdu.ControlActionCooperate </span><span class="cov1" title="1">{
                                controlCooperateReceived = true
                        }</span>

                        <span class="cov4" title="2">if dataPDU.ControlPDUData.Action == pdu.ControlActionGrantedControl </span><span class="cov1" title="1">{
                                grantedControlReceived = true
                        }</span>
                case pduType2.IsFontmap():<span class="cov1" title="1">
                        fontMapReceived = true</span>
                case pduType2.IsErrorInfo():<span class="cov0" title="0">
                        return fmt.Errorf("server error info: %d", dataPDU.ErrorInfoPDUData.ErrorInfo)</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unknown server message with pduType2 = %d", pduType2)</span>
                }
        }

        <span class="cov1" title="1">if c.remoteApp != nil </span><span class="cov0" title="0">{
                c.railState = RailStateInitializing
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package rdp

import "github.com/rcarmo/rdp-html5/internal/protocol/pdu"

// SendFrameAcknowledge sends a Frame Acknowledge PDU to the server
// This is required when using Surface Commands - the server expects
// acknowledgement of received frames
func (c *Client) SendFrameAcknowledge(frameID uint32) error <span class="cov0" title="0">{
        ack := pdu.NewFrameAcknowledgePDU(c.shareID, c.userID, frameID)
        return c.mcsLayer.Send(c.userID, c.channelIDMap["global"], ack.Serialize())
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package rdp

import (
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "io"

        "github.com/rcarmo/rdp-html5/internal/logging"
        "github.com/rcarmo/rdp-html5/internal/protocol/audio"
        "github.com/rcarmo/rdp-html5/internal/protocol/pdu"
)

var updateCounter int

// pendingSlowPathUpdate stores a slow-path update converted to fastpath format
var pendingSlowPathUpdate *Update

func (c *Client) GetUpdate() (*Update, error) <span class="cov0" title="0">{
        // If we have a pending slow-path update, return it first
        if pendingSlowPathUpdate != nil </span><span class="cov0" title="0">{
                update := pendingSlowPathUpdate
                pendingSlowPathUpdate = nil
                return update, nil
        }</span>

        <span class="cov0" title="0">protocol, err := receiveProtocol(c.buffReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updateCounter++

        if protocol.IsX224() </span><span class="cov0" title="0">{
                update, err := c.getX224Update()
                switch </span>{
                case err == nil:<span class="cov0" title="0">
                        if update != nil </span><span class="cov0" title="0">{
                                // Got a converted slow-path bitmap update
                                return update, nil
                        }</span>
                        // Non-bitmap X224 update, try again
                        <span class="cov0" title="0">return c.GetUpdate()</span>
                case errors.Is(err, pdu.ErrDeactiateAll):<span class="cov0" title="0">
                        return nil, err</span>

                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("get X.224 update: %w", err)</span>
                }
        }

        <span class="cov0" title="0">fpUpdate, err := c.fastPath.Receive()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // For native FastPath bitmap updates, inject updateType for JS compatibility
        // FastPath data format: [updateHeader (1 byte)] [size (2 bytes)] [data...]
        // JS expects bitmap data to have: [updateType (2 bytes)] [numberRectangles (2 bytes)] [bitmap data...]
        <span class="cov0" title="0">if len(fpUpdate.Data) &gt;= 3 </span><span class="cov0" title="0">{
                updateCode := fpUpdate.Data[0] &amp; 0x0f
                if updateCode == FastPathUpdateCodeBitmap </span><span class="cov0" title="0">{
                        // Inject updateType (0x0001 for bitmap) after header+size
                        oldData := fpUpdate.Data
                        newData := make([]byte, len(oldData)+2)
                        copy(newData[0:3], oldData[0:3]) // copy header + size
                        // Update size field to include the extra 2 bytes
                        origSize := binary.LittleEndian.Uint16(oldData[1:3])
                        binary.LittleEndian.PutUint16(newData[1:3], origSize+2)
                        // Insert updateType
                        binary.LittleEndian.PutUint16(newData[3:5], SlowPathUpdateTypeBitmap)
                        // Copy rest of data
                        copy(newData[5:], oldData[3:])
                        fpUpdate.Data = newData
                }</span>
        }

        <span class="cov0" title="0">return &amp;Update{Data: fpUpdate.Data}, nil</span>
}

// Slow-path update types
const (
        SlowPathUpdateTypeOrders      uint16 = 0x0000
        SlowPathUpdateTypeBitmap      uint16 = 0x0001
        SlowPathUpdateTypePalette     uint16 = 0x0002
        SlowPathUpdateTypeSynchronize uint16 = 0x0003
)

// Fastpath update codes (for conversion)
const (
        FastPathUpdateCodeBitmap      uint8 = 0x01
        FastPathUpdateCodePalette     uint8 = 0x02
        FastPathUpdateCodeSynchronize uint8 = 0x03
)

func (c *Client) getX224Update() (*Update, error) <span class="cov0" title="0">{
        channelID, wire, err := c.mcsLayer.Receive()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if channelID == c.channelIDMap["rail"] </span><span class="cov0" title="0">{
                err = c.handleRail(wire)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return nil, nil</span>
        }

        // Handle rdpsnd audio channel
        <span class="cov0" title="0">if channelID == c.channelIDMap[audio.ChannelRDPSND] </span><span class="cov0" title="0">{
                if c.audioHandler != nil </span><span class="cov0" title="0">{
                        // Read all data from wire
                        var buf bytes.Buffer
                        if _, err := io.Copy(&amp;buf, wire); err != nil </span><span class="cov0" title="0">{
                                logging.Debug("Audio: Error reading channel data: %v", err)
                                return nil, nil
                        }</span>
                        <span class="cov0" title="0">if err := c.audioHandler.HandleChannelData(buf.Bytes()); err != nil </span><span class="cov0" title="0">{
                                logging.Debug("Audio: Error handling channel data: %v", err)
                        }</span>
                }
                <span class="cov0" title="0">return nil, nil</span>
        }

        // Read ShareControlHeader first to check PDU type
        <span class="cov0" title="0">var shareControlHeader pdu.ShareControlHeader
        if err = shareControlHeader.Deserialize(wire); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if shareControlHeader.PDUType.IsDeactivateAll() </span><span class="cov0" title="0">{
                return nil, pdu.ErrDeactiateAll
        }</span>

        // Read ShareDataHeader fields
        <span class="cov0" title="0">var shareID uint32
        var padding uint8
        var streamID uint8
        var uncompressedLength uint16
        var pduType2 pdu.Type2
        var compressedType uint8
        var compressedLength uint16

        _ = binary.Read(wire, binary.LittleEndian, &amp;shareID)
        _ = binary.Read(wire, binary.LittleEndian, &amp;padding)
        _ = binary.Read(wire, binary.LittleEndian, &amp;streamID)
        _ = binary.Read(wire, binary.LittleEndian, &amp;uncompressedLength)
        _ = binary.Read(wire, binary.LittleEndian, &amp;pduType2)
        _ = binary.Read(wire, binary.LittleEndian, &amp;compressedType)
        _ = binary.Read(wire, binary.LittleEndian, &amp;compressedLength)

        // Handle bitmap updates (PDUTYPE2_UPDATE = 0x02)
        if pduType2.IsUpdate() </span><span class="cov0" title="0">{
                return c.handleSlowPathGraphicsUpdate(wire)
        }</span>

        // Handle error info
        <span class="cov0" title="0">if pduType2.IsErrorInfo() </span><span class="cov0" title="0">{
                var errorInfo pdu.ErrorInfoPDUData
                if err := errorInfo.Deserialize(wire); err == nil </span><span class="cov0" title="0">{
                        logging.Warn("Received error info: %s", errorInfo.String())
                }</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}

func (c *Client) handleSlowPathGraphicsUpdate(wire io.Reader) (*Update, error) <span class="cov10" title="15">{
        // Read updateType (2 bytes) - [MS-RDPBCGR] 2.2.9.1.1.3 Slow-Path Graphics Update
        var updateType uint16
        if err := binary.Read(wire, binary.LittleEndian, &amp;updateType); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read the rest of the data (bitmap data including numberRectangles)
        <span class="cov10" title="15">var buf bytes.Buffer
        if _, err := io.Copy(&amp;buf, wire); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="15">updateData := buf.Bytes()

        // Convert to fastpath format for the browser
        // The JavaScript parseBitmapUpdate expects: [updateType (2 bytes)] [numberRectangles (2 bytes)] [bitmap data...]
        // So we need to include the updateType in the data we send

        var fastpathCode uint8
        switch updateType </span>{
        case SlowPathUpdateTypeBitmap:<span class="cov6" title="6">
                fastpathCode = FastPathUpdateCodeBitmap</span>
        case SlowPathUpdateTypePalette:<span class="cov4" title="3">
                fastpathCode = FastPathUpdateCodePalette</span>
        case SlowPathUpdateTypeSynchronize:<span class="cov4" title="3">
                fastpathCode = FastPathUpdateCodeSynchronize</span>
        default:<span class="cov4" title="3">
                // Unknown update type, skip
                return nil, nil</span>
        }

        // Build fastpath-style data for the browser
        // Format: [updateHeader (1 byte)] [size (2 bytes LE)] [updateType (2 bytes LE)] [bitmap data...]
        // The size field should be the size of everything after the updateHeader+size, i.e. updateType + bitmapData
        <span class="cov9" title="12">updateHeader := fastpathCode                 // fragmentation=0 (single), compression=0 (none)
        totalDataSize := uint16(2 + len(updateData)) // updateType (2 bytes) + rest of data

        fpData := make([]byte, 3+2+len(updateData))
        fpData[0] = updateHeader
        binary.LittleEndian.PutUint16(fpData[1:3], totalDataSize)
        binary.LittleEndian.PutUint16(fpData[3:5], updateType)
        copy(fpData[5:], updateData)

        return &amp;Update{Data: fpData}, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package rdp

import (
        "bufio"
        "crypto/rand"
        "crypto/tls"
        "fmt"
        "net"
        "strings"
        "time"

        "github.com/rcarmo/rdp-html5/internal/auth"
        "github.com/rcarmo/rdp-html5/internal/config"
        "github.com/rcarmo/rdp-html5/internal/logging"
)

// StartNLA performs Network Level Authentication using CredSSP/NTLMv2
func (c *Client) StartNLA() error <span class="cov0" title="0">{
        // First, establish TLS connection
        if err := c.startTLSForNLA(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA TLS setup failed: %w", err)
        }</span>

        // Parse domain from username if present (DOMAIN\user or user@domain)
        <span class="cov0" title="0">domain, user := c.parseDomainUser()
        logging.Info("NLA: Authenticating as domain=%q user=%q", domain, user)

        // Create NTLMv2 context
        ntlmCtx := auth.NewNTLMv2(domain, user, c.password)

        // Generate client nonce (32 bytes) - required for version 5+
        clientNonce := make([]byte, 32)
        if _, err := rand.Read(clientNonce); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to generate nonce: %w", err)
        }</span>

        // Step 1: Send NTLM Negotiate message with client nonce
        <span class="cov0" title="0">negoMsg := ntlmCtx.GetNegotiateMessage()
        tsReq := auth.EncodeTSRequestWithNonce([][]byte{negoMsg}, nil, nil, clientNonce)

        if _, err := c.conn.Write(tsReq); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to send negotiate message: %w", err)
        }</span>
        <span class="cov0" title="0">logging.Debug("NLA: Sent negotiate message (%d bytes)", len(tsReq))

        // Step 2: Receive server challenge
        resp := make([]byte, 4096)
        n, err := c.conn.Read(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to read challenge: %w", err)
        }</span>
        <span class="cov0" title="0">logging.Debug("NLA: Received challenge (%d bytes)", n)

        tsResp, err := auth.DecodeTSRequest(resp[:n])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to decode challenge: %w", err)
        }</span>
        <span class="cov0" title="0">logging.Debug("NLA: Server version=%d, errorCode=%d", tsResp.Version, tsResp.ErrorCode)

        if len(tsResp.NegoTokens) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: no challenge token received from server")
        }</span>

        // Step 3: Process challenge and get authenticate message
        <span class="cov0" title="0">authMsg, ntlmSec := ntlmCtx.GetAuthenticateMessage(tsResp.NegoTokens[0].Data)
        if authMsg == nil || ntlmSec == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to generate authenticate message")
        }</span>

        // Get the server's public key from the TLS connection
        <span class="cov0" title="0">pubKey, err := c.getTLSPublicKey()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to get TLS public key: %w", err)
        }</span>
        <span class="cov0" title="0">logging.Debug("NLA: Got TLS SubjectPublicKey (%d bytes)", len(pubKey))

        // For version 5+, compute hash-based pubKeyAuth
        // SHA256(ClientServerHashMagic || clientNonce || publicKey)
        var pubKeyData []byte
        if tsResp.Version &gt;= 5 </span><span class="cov0" title="0">{
                pubKeyData = auth.ComputeClientPubKeyAuth(tsResp.Version, pubKey, clientNonce)
                logging.Debug("NLA: Using version %d hash-based pubKeyAuth", tsResp.Version)
        }</span> else<span class="cov0" title="0"> {
                pubKeyData = pubKey
                logging.Debug("NLA: Using version %d raw pubKey", tsResp.Version)
        }</span>

        <span class="cov0" title="0">encryptedPubKey := ntlmSec.GssEncrypt(pubKeyData)
        logging.Debug("NLA: Encrypted pubKeyAuth len=%d", len(encryptedPubKey))

        // Send authenticate message with encrypted public key and client nonce
        tsReq = auth.EncodeTSRequestWithNonce([][]byte{authMsg}, nil, encryptedPubKey, clientNonce)
        if _, err := c.conn.Write(tsReq); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to send authenticate message: %w", err)
        }</span>
        <span class="cov0" title="0">logging.Debug("NLA: Sent authenticate message (%d bytes)", len(tsReq))

        // Step 4: Receive public key verification from server
        resp = make([]byte, 4096)
        n, err = c.conn.Read(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to read public key response: %w", err)
        }</span>
        <span class="cov0" title="0">logging.Debug("NLA: Received public key response (%d bytes)", n)

        tsResp, err = auth.DecodeTSRequest(resp[:n])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to decode public key response: %w", err)
        }</span>

        // Verify server's pubKeyAuth (for version 5+, this is a hash; for earlier versions, pubKey+1)
        <span class="cov0" title="0">if len(tsResp.PubKeyAuth) &gt; 0 </span><span class="cov0" title="0">{
                decryptedPubKeyAuth := ntlmSec.GssDecrypt(tsResp.PubKeyAuth)
                if decryptedPubKeyAuth == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("NLA: failed to decrypt server pubKeyAuth")
                }</span>
                <span class="cov0" title="0">logging.Debug("NLA: Decrypted server pubKeyAuth (%d bytes)", len(decryptedPubKeyAuth))

                // Verify the server's response
                if !auth.VerifyServerPubKeyAuth(tsResp.Version, decryptedPubKeyAuth, pubKey, clientNonce) </span><span class="cov0" title="0">{
                        return fmt.Errorf("NLA: server pubKeyAuth verification failed")
                }</span>
                <span class="cov0" title="0">logging.Debug("NLA: Server pubKeyAuth verified successfully")</span>
        }

        // Step 5: Send credentials
        // Per MS-CSSP, TSPasswordCreds MUST be UTF-16LE encoded
        <span class="cov0" title="0">domainBytes, userBytes, passBytes := ntlmCtx.GetCredSSPCredentials()
        credentials := auth.EncodeCredentials(domainBytes, userBytes, passBytes)
        encryptedCreds := ntlmSec.GssEncrypt(credentials)
        logging.Debug("NLA: Sending encrypted credentials")

        tsReq = auth.EncodeTSRequest(nil, encryptedCreds, nil)
        if _, err := c.conn.Write(tsReq); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NLA: failed to send credentials: %w", err)
        }</span>
        <span class="cov0" title="0">logging.Info("NLA: Authentication completed successfully")

        // Step 6: Wait for final server response (optional - some servers send a final TSRequest)
        // Set a short timeout for this read - if no data comes, credentials were accepted
        if tcpConn, ok := c.conn.(*tls.Conn); ok </span><span class="cov0" title="0">{
                _ = tcpConn.SetReadDeadline(time.Now().Add(2 * time.Second))
        }</span>

        <span class="cov0" title="0">finalResp := make([]byte, 4096)
        n, err = c.conn.Read(finalResp)
        if err != nil </span><span class="cov0" title="0">{
                // Timeout is expected and OK - means server accepted credentials silently
                if ne, ok := err.(net.Error); ok &amp;&amp; ne.Timeout() </span><span class="cov0" title="0">{
                        logging.Debug("NLA: No final response from server (timeout - expected)")
                        // Clear the deadline
                        if tcpConn, ok := c.conn.(*tls.Conn); ok </span><span class="cov0" title="0">{
                                _ = tcpConn.SetReadDeadline(time.Time{})
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                // Other errors might indicate authentication failure
                <span class="cov0" title="0">logging.Debug("NLA: Error reading final response: %v", err)
                // Try to continue anyway - some servers don't send a final response
                if tcpConn, ok := c.conn.(*tls.Conn); ok </span><span class="cov0" title="0">{
                        _ = tcpConn.SetReadDeadline(time.Time{})
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Clear the deadline
        <span class="cov0" title="0">if tcpConn, ok := c.conn.(*tls.Conn); ok </span><span class="cov0" title="0">{
                _ = tcpConn.SetReadDeadline(time.Time{})
        }</span>

        // If we got data, check if it's an error response
        <span class="cov0" title="0">if n &gt; 0 </span><span class="cov0" title="0">{
                logging.Debug("NLA: Received final response (%d bytes)", n)
                finalTsResp, err := auth.DecodeTSRequest(finalResp[:n])
                if err == nil </span><span class="cov0" title="0">{
                        if finalTsResp.ErrorCode != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("NLA: server returned error code: 0x%08X", finalTsResp.ErrorCode)
                        }</span>
                        <span class="cov0" title="0">logging.Debug("NLA: Final response indicates success (version=%d)", finalTsResp.Version)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// startTLSForNLA establishes TLS connection for NLA
func (c *Client) startTLSForNLA() error <span class="cov0" title="0">{
        insecureSkipVerify := c.skipTLSValidation
        serverName := c.tlsServerName

        cfg := config.GetGlobalConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                var err error
                cfg, err = config.Load()
                if err != nil </span><span class="cov0" title="0">{
                        cfg = &amp;config.Config{}
                }</span>
        }

        <span class="cov0" title="0">if cfg != nil </span><span class="cov0" title="0">{
                if !insecureSkipVerify </span><span class="cov0" title="0">{
                        insecureSkipVerify = cfg.Security.SkipTLSValidation
                }</span>
                <span class="cov0" title="0">if serverName == "" </span><span class="cov0" title="0">{
                        serverName = cfg.Security.TLSServerName
                }</span>
        }

        <span class="cov0" title="0">if serverName == "" </span><span class="cov0" title="0">{
                serverName = c.getServerName()
        }</span>

        // Windows RDP servers typically only support TLS 1.0-1.2, not TLS 1.3
        // Use TLS 1.2 max for better compatibility
        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{
                InsecureSkipVerify: insecureSkipVerify, // RDP servers use self-signed certs
                MinVersion:         tls.VersionTLS10,
                MaxVersion:         tls.VersionTLS12, // Windows RDP doesn't support TLS 1.3
                ServerName:         serverName,
        }

        if tlsConfig.ServerName == "" </span><span class="cov0" title="0">{
                if c.conn != nil </span><span class="cov0" title="0">{
                        remoteAddr := c.conn.RemoteAddr().String()
                        host, _, err := net.SplitHostPort(remoteAddr)
                        if err == nil &amp;&amp; host != "" </span><span class="cov0" title="0">{
                                tlsConfig.ServerName = host
                        }</span>
                }
                <span class="cov0" title="0">if tlsConfig.ServerName == "" </span><span class="cov0" title="0">{
                        tlsConfig.ServerName = "rdp-server"
                }</span>
        }

        <span class="cov0" title="0">tlsConn := tls.Client(c.conn, tlsConfig)

        if tcpConn, ok := c.conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                _ = tcpConn.SetReadDeadline(time.Now().Add(30 * time.Second))
                _ = tcpConn.SetWriteDeadline(time.Now().Add(30 * time.Second))
        }</span>

        <span class="cov0" title="0">if err := tlsConn.Handshake(); err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "certificate") || strings.Contains(err.Error(), "x509") </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS certificate verification failed: %w", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("TLS handshake failed: %w", err)</span>
        }

        <span class="cov0" title="0">if tcpConn, ok := c.conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                _ = tcpConn.SetReadDeadline(time.Time{})
                _ = tcpConn.SetWriteDeadline(time.Time{})
        }</span>

        <span class="cov0" title="0">c.conn = tlsConn
        c.buffReader = bufio.NewReaderSize(c.conn, readBufferSize)

        return nil</span>
}

// getTLSPublicKey extracts the server's public key from the TLS connection
// Per MS-CSSP, this must be the SubjectPublicKey (NOT SubjectPublicKeyInfo)
// SubjectPublicKeyInfo = SEQUENCE { algorithm, subjectPublicKey }
// We need just the subjectPublicKey BIT STRING content
func (c *Client) getTLSPublicKey() ([]byte, error) <span class="cov0" title="0">{
        tlsConn, ok := c.conn.(*tls.Conn)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connection is not TLS")
        }</span>

        <span class="cov0" title="0">state := tlsConn.ConnectionState()
        if len(state.PeerCertificates) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no peer certificates")
        }</span>

        <span class="cov0" title="0">cert := state.PeerCertificates[0]

        // Parse SubjectPublicKeyInfo to extract just SubjectPublicKey
        // SubjectPublicKeyInfo ::= SEQUENCE {
        //   algorithm AlgorithmIdentifier,
        //   subjectPublicKey BIT STRING
        // }
        // We need the raw bytes of the BIT STRING (including its unused bits prefix)
        spki := cert.RawSubjectPublicKeyInfo
        if len(spki) &lt; 4 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SubjectPublicKeyInfo too short")
        }</span>

        // Parse outer SEQUENCE
        <span class="cov0" title="0">if spki[0] != 0x30 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected SEQUENCE tag for SubjectPublicKeyInfo")
        }</span>

        // Parse length
        <span class="cov0" title="0">offset := 1
        seqLen, lenBytes := parseASN1Length(spki[offset:])
        offset += lenBytes
        if seqLen == 0 || offset+seqLen &gt; len(spki) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid SubjectPublicKeyInfo length")
        }</span>

        // Skip AlgorithmIdentifier SEQUENCE
        <span class="cov0" title="0">if spki[offset] != 0x30 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected SEQUENCE tag for AlgorithmIdentifier")
        }</span>
        <span class="cov0" title="0">algIdLen, algIdLenBytes := parseASN1Length(spki[offset+1:])
        offset += 1 + algIdLenBytes + algIdLen

        // Now at SubjectPublicKey BIT STRING
        if offset &gt;= len(spki) || spki[offset] != 0x03 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected BIT STRING tag for SubjectPublicKey")
        }</span>
        <span class="cov0" title="0">offset++ // skip tag

        bitStrLen, bitStrLenBytes := parseASN1Length(spki[offset:])
        offset += bitStrLenBytes

        if offset+bitStrLen &gt; len(spki) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SubjectPublicKey extends past end of SubjectPublicKeyInfo")
        }</span>

        // Skip the "unused bits" byte (first byte of BIT STRING content)
        // FreeRDP's i2d_PublicKey returns just the raw key structure without this byte
        <span class="cov0" title="0">if bitStrLen &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SubjectPublicKey BIT STRING too short")
        }</span>
        <span class="cov0" title="0">offset++ // skip unused bits byte
        bitStrLen--

        // Return just the raw public key DER (SEQUENCE { modulus, exponent } for RSA)
        return spki[offset : offset+bitStrLen], nil</span>
}

// parseASN1Length parses ASN.1 DER length encoding
// Returns the length value and the number of bytes consumed
func parseASN1Length(data []byte) (int, int) <span class="cov9" title="11">{
        if len(data) == 0 </span><span class="cov1" title="1">{
                return 0, 0
        }</span>
        <span class="cov9" title="10">if data[0] &lt; 128 </span><span class="cov3" title="2">{
                return int(data[0]), 1
        }</span>
        <span class="cov8" title="8">numBytes := int(data[0] &amp; 0x7F)
        if numBytes == 0 || numBytes &gt; 4 || numBytes &gt;= len(data) </span><span class="cov4" title="3">{
                return 0, 1
        }</span>
        <span class="cov6" title="5">length := 0
        for i := 0; i &lt; numBytes; i++ </span><span class="cov10" title="12">{
                length = (length &lt;&lt; 8) | int(data[1+i])
        }</span>
        <span class="cov6" title="5">return length, 1 + numBytes</span>
}

// parseDomainUser parses DOMAIN\user or user@domain format
func (c *Client) parseDomainUser() (domain, user string) <span class="cov9" title="10">{
        username := c.username

        // Check for DOMAIN\user format
        if idx := strings.Index(username, "\\"); idx != -1 </span><span class="cov6" title="4">{
                return username[:idx], username[idx+1:]
        }</span>

        // Check for user@domain format
        <span class="cov7" title="6">if idx := strings.Index(username, "@"); idx != -1 </span><span class="cov6" title="4">{
                return username[idx+1:], username[:idx]
        }</span>

        // No domain specified
        <span class="cov3" title="2">return c.domain, username</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package rdp

import (
        "bytes"
        "encoding/binary"
        "io"

        "github.com/rcarmo/rdp-html5/internal/codec"
)

type RailState uint8

// State machine described in [MS-RDPERP] 3.1.1.1.

const (
        RailStateUninitialized RailState = iota
        RailStateInitializing
        RailStateSyncDesktop
        RailStateWaitForData
        RailStateExecuteApp
)

func (c *Client) handleRail(wire io.Reader) error <span class="cov6" title="8">{
        if c.remoteApp == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov5" title="7">var (
                input RailPDU
                err   error
        )

        if err = input.Deserialize(wire); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov5" title="6">if input.header.OrderType == RailOrderSysParam </span><span class="cov4" title="4">{
                return nil
        }</span>

        <span class="cov2" title="2">switch c.railState </span>{
        case RailStateInitializing:<span class="cov0" title="0">
                return c.railHandshake(&amp;input)</span>
        case RailStateExecuteApp:<span class="cov1" title="1">
                return c.railReceiveRemoteAppStatus(&amp;input)</span>
        }

        <span class="cov1" title="1">return nil</span>
}

type RailOrder uint16

const (
        // RailOrderExec TS_RAIL_ORDER_EXEC
        RailOrderExec RailOrder = 0x0001

        // RailOrderActivate TS_RAIL_ORDER_ACTIVATE
        RailOrderActivate RailOrder = 0x0002

        // RailOrderSysParam TS_RAIL_ORDER_SYSPARAM
        RailOrderSysParam RailOrder = 0x0003

        // RailOrderSysCommand TS_RAIL_ORDER_SYSCOMMAND
        RailOrderSysCommand RailOrder = 0x0004

        // RailOrderHandshake TS_RAIL_ORDER_HANDSHAKE
        RailOrderHandshake RailOrder = 0x0005

        // RailOrderNotifyEvent TS_RAIL_ORDER_NOTIFY_EVENT
        RailOrderNotifyEvent RailOrder = 0x0006

        // RailOrderWindowMove TS_RAIL_ORDER_WINDOWMOVE
        RailOrderWindowMove RailOrder = 0x0008

        // RailOrderLocalMoveSize TS_RAIL_ORDER_LOCALMOVESIZE
        RailOrderLocalMoveSize RailOrder = 0x0009

        // RailOrderMinMaxInfo TS_RAIL_ORDER_MINMAXINFO
        RailOrderMinMaxInfo RailOrder = 0x000a

        // RailOrderClientStatus TS_RAIL_ORDER_CLIENTSTATUS
        RailOrderClientStatus RailOrder = 0x000b

        // RailOrderSysMenu TS_RAIL_ORDER_SYSMENU
        RailOrderSysMenu RailOrder = 0x000c

        // RailOrderLangBarInfo TS_RAIL_ORDER_LANGBARINFO
        RailOrderLangBarInfo RailOrder = 0x000d

        // RailOrderExecResult TS_RAIL_ORDER_EXEC_RESULT
        RailOrderExecResult RailOrder = 0x0080

        // RailOrderGetAppIDReq TS_RAIL_ORDER_GET_APPID_REQ
        RailOrderGetAppIDReq RailOrder = 0x000E

        // RailOrderAppIDResp TS_RAIL_ORDER_GET_APPID_RESP
        RailOrderAppIDResp RailOrder = 0x000F

        // RailOrderTaskBarInfo TS_RAIL_ORDER_TASKBARINFO
        RailOrderTaskBarInfo RailOrder = 0x0010

        // RailOrderLanguageIMEInfo TS_RAIL_ORDER_LANGUAGEIMEINFO
        RailOrderLanguageIMEInfo RailOrder = 0x0011

        // RailOrderCompartmentInfo TS_RAIL_ORDER_COMPARTMENTINFO
        RailOrderCompartmentInfo RailOrder = 0x0012

        // RailOrderHandshakeEx TS_RAIL_ORDER_HANDSHAKE_EX
        RailOrderHandshakeEx RailOrder = 0x0013

        // RailOrderZOrderSync TS_RAIL_ORDER_ZORDER_SYNC
        RailOrderZOrderSync RailOrder = 0x0014

        // RailOrderCloak TS_RAIL_ORDER_CLOAK
        RailOrderCloak RailOrder = 0x0015

        // RailOrderPowerDisplayRequest TS_RAIL_ORDER_POWER_DISPLAY_REQUEST
        RailOrderPowerDisplayRequest RailOrder = 0x0016

        // RailOrderSnapArrange TS_RAIL_ORDER_SNAP_ARRANGE
        RailOrderSnapArrange RailOrder = 0x0017

        // RailOrderGetAppIDRespEx TS_RAIL_ORDER_GET_APPID_RESP_EX
        RailOrderGetAppIDRespEx RailOrder = 0x0018

        // RailOrderTextScaleInfo TS_RAIL_ORDER_TEXTSCALEINFO
        RailOrderTextScaleInfo RailOrder = 0x0019

        // RailOrderCaretBlinkInfo TS_RAIL_ORDER_CARETBLINKINFO
        RailOrderCaretBlinkInfo RailOrder = 0x001A
)

type RailPDU struct {
        channelHeader                  ChannelPDUHeader
        header                         RailPDUHeader
        RailPDUHandshake               *RailPDUHandshake
        RailPDUClientInfo              *RailPDUClientInfo
        RailPDUClientExecute           *RailPDUClientExecute
        RailPDUSystemParameters        *RailPDUSystemParameters
        RailPDUExecResult              *RailPDUExecResult
        RailPDUClientSystemParamUpdate *RailPDUClientSystemParamUpdate
}

func (pdu *RailPDU) Serialize() []byte <span class="cov8" title="16">{
        var data []byte

        switch pdu.header.OrderType </span>{
        case RailOrderHandshake:<span class="cov5" title="6">
                data = pdu.RailPDUHandshake.Serialize()</span>
        case RailOrderExec:<span class="cov4" title="4">
                data = pdu.RailPDUClientExecute.Serialize()</span>
        case RailOrderSysParam:<span class="cov5" title="5">
                data = pdu.RailPDUClientSystemParamUpdate.Serialize()</span>
        }

        <span class="cov8" title="16">pdu.header.OrderLength = uint16(8 + 4 + len(data))

        buf := new(bytes.Buffer)

        buf.Write(pdu.channelHeader.Serialize())
        buf.Write(pdu.header.Serialize())
        buf.Write(data)

        return buf.Bytes()</span>
}

func (pdu *RailPDU) Deserialize(wire io.Reader) error <span class="cov8" title="19">{
        var err error

        err = pdu.channelHeader.Deserialize(wire)
        if err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov8" title="17">err = pdu.header.Deserialize(wire)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov8" title="16">switch pdu.header.OrderType </span>{
        case RailOrderHandshake:<span class="cov4" title="4">
                pdu.RailPDUHandshake = &amp;RailPDUHandshake{}

                return pdu.RailPDUHandshake.Deserialize(wire)</span>
        case RailOrderSysParam:<span class="cov5" title="7">
                pdu.RailPDUSystemParameters = &amp;RailPDUSystemParameters{}

                return pdu.RailPDUSystemParameters.Deserialize(wire)</span>
        case RailOrderExecResult:<span class="cov3" title="3">
                pdu.RailPDUExecResult = &amp;RailPDUExecResult{}

                return pdu.RailPDUExecResult.Deserialize(wire)</span>
        }

        <span class="cov2" title="2">return nil</span>
}

type RailPDUHeader struct {
        OrderType   RailOrder
        OrderLength uint16
}

func (h *RailPDUHeader) Serialize() []byte <span class="cov9" title="26">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint16(h.OrderType))
        _ = binary.Write(buf, binary.LittleEndian, h.OrderLength)

        return buf.Bytes()
}</span>

func (h *RailPDUHeader) Deserialize(wire io.Reader) error <span class="cov10" title="34">{
        var err error

        var orderType uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;orderType)
        if err != nil </span><span class="cov4" title="4">{
                return err
        }</span>
        <span class="cov9" title="30">h.OrderType = RailOrder(orderType)

        err = binary.Read(wire, binary.LittleEndian, &amp;h.OrderLength)
        if err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov9" title="28">return nil</span>
}

type RailPDUHandshake struct {
        buildNumber uint32
}

func NewRailHandshakePDU() *RailPDU <span class="cov5" title="7">{
        return &amp;RailPDU{
                channelHeader: ChannelPDUHeader{
                        Flags: ChannelFlagFirst | ChannelFlagLast,
                },
                header: RailPDUHeader{
                        OrderType: RailOrderHandshake,
                },
                RailPDUHandshake: &amp;RailPDUHandshake{
                        buildNumber: 0x00001DB0,
                },
        }
}</span>

func (pdu *RailPDUHandshake) Serialize() []byte <span class="cov7" title="12">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, pdu.buildNumber)

        return buf.Bytes()
}</span>

func (pdu *RailPDUHandshake) Deserialize(wire io.Reader) error <span class="cov7" title="15">{
        err := binary.Read(wire, binary.LittleEndian, &amp;pdu.buildNumber)
        if err != nil </span><span class="cov5" title="5">{
                return err
        }</span>

        <span class="cov6" title="10">return nil</span>
}

type RailPDUClientInfo struct {
        Flags uint32
}

func NewRailClientInfoPDU() *RailPDU <span class="cov2" title="2">{
        return &amp;RailPDU{
                channelHeader: ChannelPDUHeader{
                        Flags: ChannelFlagFirst | ChannelFlagLast,
                },
                header: RailPDUHeader{
                        OrderType: RailOrderClientStatus,
                },
                RailPDUClientInfo: &amp;RailPDUClientInfo{
                        Flags: 0, // none of the features are supported
                },
        }
}</span>

func (pdu *RailPDUClientInfo) Serialize() []byte <span class="cov1" title="1">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, pdu.Flags)

        return buf.Bytes()
}</span>

type RailPDUClientSystemParamUpdate struct {
        SystemParam uint32
        Body        uint8
}

func NewRailPDUClientSystemParamUpdate(systemParam uint32, body uint8) *RailPDU <span class="cov5" title="6">{
        return &amp;RailPDU{
                channelHeader: ChannelPDUHeader{
                        Flags: ChannelFlagFirst | ChannelFlagLast,
                },
                header: RailPDUHeader{
                        OrderType: RailOrderSysParam,
                },
                RailPDUClientSystemParamUpdate: &amp;RailPDUClientSystemParamUpdate{
                        SystemParam: systemParam,
                        Body:        body,
                },
        }
}</span>

func (pdu *RailPDUClientSystemParamUpdate) Serialize() []byte <span class="cov5" title="6">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, pdu.SystemParam)
        _ = binary.Write(buf, binary.LittleEndian, pdu.Body)

        return buf.Bytes()
}</span>

func (c *Client) railHandshake(*RailPDU) error <span class="cov0" title="0">{
        var (
                err error
        )

        clientHandshake := NewRailHandshakePDU()
        err = c.mcsLayer.Send(c.userID, c.channelIDMap["rail"], clientHandshake.Serialize())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">clientInfo := NewRailClientInfoPDU()
        err = c.mcsLayer.Send(c.userID, c.channelIDMap["rail"], clientInfo.Serialize())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.railState = RailStateWaitForData

        return c.railStartRemoteApp()</span>
}

type RailPDUSystemParameters struct {
        SystemParameter uint32
        Body            uint8
}

func (pdu *RailPDUSystemParameters) Deserialize(wire io.Reader) error <span class="cov7" title="14">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;pdu.SystemParameter)
        if err != nil </span><span class="cov5" title="5">{
                return err
        }</span>

        <span class="cov6" title="9">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.Body)
        if err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov5" title="7">return nil</span>
}

type RailPDUClientExecute struct {
        Flags      uint16
        ExeOrFile  string
        WorkingDir string
        Arguments  string
}

func NewRailClientExecutePDU(app, workDir, args string) *RailPDU <span class="cov5" title="5">{
        return &amp;RailPDU{
                channelHeader: ChannelPDUHeader{
                        Flags: ChannelFlagFirst | ChannelFlagLast,
                },
                header: RailPDUHeader{
                        OrderType: RailOrderExec,
                },
                RailPDUClientExecute: &amp;RailPDUClientExecute{
                        ExeOrFile:  app,
                        WorkingDir: workDir,
                        Arguments:  args,
                },
        }
}</span>

func (pdu *RailPDUClientExecute) Serialize() []byte <span class="cov7" title="15">{
        exeOrFile := codec.Encode(pdu.ExeOrFile)
        exeOrFileLength := uint16(len(exeOrFile))

        workingDir := codec.Encode(pdu.WorkingDir)
        workingDirLength := uint16(len(workingDir))

        arguments := codec.Encode(pdu.Arguments)
        argumentsLen := uint16(len(arguments))

        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, pdu.Flags)
        _ = binary.Write(buf, binary.LittleEndian, exeOrFileLength)
        _ = binary.Write(buf, binary.LittleEndian, workingDirLength)
        _ = binary.Write(buf, binary.LittleEndian, argumentsLen)
        _ = binary.Write(buf, binary.LittleEndian, exeOrFile)
        _ = binary.Write(buf, binary.LittleEndian, workingDir)
        _ = binary.Write(buf, binary.LittleEndian, arguments)

        return buf.Bytes()
}</span>

func (c *Client) railStartRemoteApp() error <span class="cov0" title="0">{
        c.railState = RailStateExecuteApp

        clientExecute := NewRailClientExecutePDU(c.remoteApp.App, c.remoteApp.WorkingDir, c.remoteApp.Args)

        return c.mcsLayer.Send(c.userID, c.channelIDMap["rail"], clientExecute.Serialize())
}</span>

type RailPDUExecResult struct {
        Flags      uint16
        ExecResult uint16
        RawResult  uint32
        ExeOrFile  string
}

func (pdu *RailPDUExecResult) Deserialize(wire io.Reader) error <span class="cov6" title="8">{
        var err error

        err = binary.Read(wire, binary.LittleEndian, &amp;pdu.Flags)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov5" title="7">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.ExecResult)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov5" title="6">err = binary.Read(wire, binary.LittleEndian, &amp;pdu.RawResult)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="6">var padding uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;padding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="6">var exeOrFileLength uint16
        err = binary.Read(wire, binary.LittleEndian, &amp;exeOrFileLength)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="6">exeOrFile := make([]byte, exeOrFileLength)
        _, err = wire.Read(exeOrFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="6">pdu.ExeOrFile = string(exeOrFile)

        return nil</span>
}

func (c *Client) railReceiveRemoteAppStatus(*RailPDU) error <span class="cov2" title="2">{
        c.railState = RailStateWaitForData

        // TODO: implement

        return nil
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package rdp

func (c *Client) Read(b []byte) (int, error) <span class="cov10" title="4">{
        return c.buffReader.Read(b)
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package rdp

import (
        "bytes"
        "encoding/binary"
)

// sendRefreshRect sends a Refresh Rect PDU to request a full screen update
// [MS-RDPBCGR] 2.2.11.2 Client Refresh Rect PDU
func (c *Client) sendRefreshRect() error <span class="cov3" title="2">{
        // Build the Refresh Rect PDU data
        // numberOfAreas (1 byte) + pad3Octets (3 bytes) + areasToRefresh (variable)
        refreshData := new(bytes.Buffer)

        // numberOfAreas - requesting 1 rectangle (full screen)
        _ = binary.Write(refreshData, binary.LittleEndian, uint8(1))
        // pad3Octets
        _ = binary.Write(refreshData, binary.LittleEndian, uint8(0))
        _ = binary.Write(refreshData, binary.LittleEndian, uint8(0))
        _ = binary.Write(refreshData, binary.LittleEndian, uint8(0))

        // Inclusive Rectangle - full screen
        // left (2 bytes)
        _ = binary.Write(refreshData, binary.LittleEndian, uint16(0))
        // top (2 bytes)
        _ = binary.Write(refreshData, binary.LittleEndian, uint16(0))
        // right (2 bytes) - inclusive, so width-1
        _ = binary.Write(refreshData, binary.LittleEndian, uint16(c.desktopWidth-1))
        // bottom (2 bytes) - inclusive, so height-1
        _ = binary.Write(refreshData, binary.LittleEndian, uint16(c.desktopHeight-1))

        // Build the Share Data Header
        // PDUTYPE_DATAPDU (0x0007)
        // pduType2 = 0x21 (PDUTYPE2_REFRESH_RECT)
        shareDataHeaderData := buildShareDataHeader(c.shareID, c.userID, 0x21, refreshData.Bytes())

        // Build Share Control Header
        // PDUTYPE_DATAPDU = 0x0007
        shareControlData := buildShareControlHeader(0x0007, c.userID, shareDataHeaderData)

        return c.mcsLayer.Send(c.userID, c.channelIDMap["global"], shareControlData)
}</span>

// buildShareDataHeader creates a Share Data Header for a PDU
func buildShareDataHeader(shareID uint32, _ uint16, pduType2 uint8, data []byte) []byte <span class="cov10" title="19">{
        buf := new(bytes.Buffer)

        // shareID (4 bytes)
        _ = binary.Write(buf, binary.LittleEndian, shareID)
        // pad1 (1 byte)
        _ = binary.Write(buf, binary.LittleEndian, uint8(0))
        // streamId (1 byte) - STREAM_LOW = 1
        _ = binary.Write(buf, binary.LittleEndian, uint8(1))
        // uncompressedLength (2 bytes) - includes pduType2, compressedType, compressedLength
        uncompressedLen := uint16(4 + len(data)) // pduType2 + compressedType + compressedLength + data
        _ = binary.Write(buf, binary.LittleEndian, uncompressedLen)
        // pduType2 (1 byte)
        _ = binary.Write(buf, binary.LittleEndian, pduType2)
        // compressedType (1 byte)
        _ = binary.Write(buf, binary.LittleEndian, uint8(0))
        // compressedLength (2 bytes)
        _ = binary.Write(buf, binary.LittleEndian, uint16(0))
        // data
        buf.Write(data)

        return buf.Bytes()
}</span>

// buildShareControlHeader creates a Share Control Header wrapping a Share Data Header
func buildShareControlHeader(pduType uint16, pduSource uint16, data []byte) []byte <span class="cov9" title="18">{
        buf := new(bytes.Buffer)

        // totalLength (2 bytes) - includes this header
        totalLen := uint16(6 + len(data)) // 2 + 2 + 2 + data
        _ = binary.Write(buf, binary.LittleEndian, totalLen)
        // pduType (2 bytes) - low 4 bits = pduType, high 12 bits = version (1)
        pduTypeWithVersion := pduType | (1 &lt;&lt; 4) // version 1
        _ = binary.Write(buf, binary.LittleEndian, pduTypeWithVersion)
        // pduSource (2 bytes)
        _ = binary.Write(buf, binary.LittleEndian, pduSource)
        // data
        buf.Write(data)

        return buf.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package rdp

func (c *Client) SetRemoteApp(app, args, workingDir string) <span class="cov10" title="5">{
        c.remoteApp = &amp;RemoteApp{
                App:        app,
                WorkingDir: workingDir,
                Args:       args,
        }
        c.channels = append(c.channels, "rail")
        c.railState = RailStateUninitialized
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package rdp

import "github.com/rcarmo/rdp-html5/internal/protocol/fastpath"

func (c *Client) SendInputEvent(data []byte) error <span class="cov8" title="1">{
        return c.fastPath.Send(fastpath.NewInputEventPDU(data))
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">package rdp

import (
        "bufio"
        "crypto/tls"
        "fmt"
        "net"
        "strings"
        "time"

        "github.com/rcarmo/rdp-html5/internal/config"
)

func (c *Client) StartTLS() error <span class="cov0" title="0">{
        // Use client-specific TLS configuration if set, otherwise fall back to global config
        insecureSkipVerify := c.skipTLSValidation
        serverName := c.tlsServerName
        minTLSVersion := "1.2" // default

        // Pull server-wide config when available so flag/env overrides are honored
        cfg := config.GetGlobalConfig()
        if cfg == nil </span><span class="cov0" title="0">{
                var err error
                cfg, err = config.Load()
                if err != nil </span><span class="cov0" title="0">{
                        cfg = &amp;config.Config{}
                }</span>
        }

        <span class="cov0" title="0">if cfg != nil </span><span class="cov0" title="0">{
                if !insecureSkipVerify </span><span class="cov0" title="0">{
                        insecureSkipVerify = cfg.Security.SkipTLSValidation
                }</span>
                <span class="cov0" title="0">if serverName == "" </span><span class="cov0" title="0">{
                        serverName = cfg.Security.TLSServerName
                }</span>
                <span class="cov0" title="0">if cfg.Security.MinTLSVersion != "" </span><span class="cov0" title="0">{
                        minTLSVersion = cfg.Security.MinTLSVersion
                }</span>
        }

        <span class="cov0" title="0">if serverName == "" </span><span class="cov0" title="0">{
                serverName = c.getServerName()
        }</span>

        // When explicitly skipping verification, allow legacy TLS for compatibility with older servers
        <span class="cov0" title="0">if insecureSkipVerify </span><span class="cov0" title="0">{
                minTLSVersion = "1.0"
        }</span>

        // Create TLS configuration with improved error handling
        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{
                InsecureSkipVerify: insecureSkipVerify,
                MinVersion:         c.getMinTLSVersion(minTLSVersion),
                MaxVersion:         tls.VersionTLS13,
                ServerName:         serverName,
        }

        // When skipping TLS validation, ensure we have a ServerName
        // If no ServerName is provided and we're skipping validation, use a fallback
        if tlsConfig.InsecureSkipVerify &amp;&amp; tlsConfig.ServerName == "" </span><span class="cov0" title="0">{
                // Try to extract hostname from the connection address
                if c.conn != nil </span><span class="cov0" title="0">{
                        remoteAddr := c.conn.RemoteAddr().String()
                        host, _, err := net.SplitHostPort(remoteAddr)
                        if err == nil &amp;&amp; host != "" </span><span class="cov0" title="0">{
                                tlsConfig.ServerName = host
                        }</span>
                }
                // If still no ServerName, use a generic one to satisfy TLS requirements
                <span class="cov0" title="0">if tlsConfig.ServerName == "" </span><span class="cov0" title="0">{
                        tlsConfig.ServerName = "rdp-server"
                }</span>
        }

        // When skipping validation, still try to verify if possible
        <span class="cov0" title="0">if insecureSkipVerify </span><span class="cov0" title="0">{
                // Set up fallback verification for basic connectivity
                tlsConfig.InsecureSkipVerify = true
                // Allow any cipher suite when skipping verification for maximum compatibility
                tlsConfig.CipherSuites = nil
        }</span> else<span class="cov0" title="0"> {
                // Enforce secure cipher suites when verification is enabled
                tlsConfig.CipherSuites = []uint16{
                        tls.TLS_AES_128_GCM_SHA256,
                        tls.TLS_AES_256_GCM_SHA384,
                        tls.TLS_CHACHA20_POLY1305_SHA256,
                        tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
                        tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
                        tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
                        tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                }
        }</span>

        <span class="cov0" title="0">tlsConn := tls.Client(c.conn, tlsConfig)

        // Set handshake timeout to prevent hanging
        if tcpConn, ok := c.conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                _ = tcpConn.SetReadDeadline(time.Now().Add(30 * time.Second))
                _ = tcpConn.SetWriteDeadline(time.Now().Add(30 * time.Second))
        }</span>

        <span class="cov0" title="0">if err := tlsConn.Handshake(); err != nil </span><span class="cov0" title="0">{
                // Provide more specific error messages
                if insecureSkipVerify </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS handshake failed even with validation skipped: %w", err)
                }</span>

                // Suggest skipping validation for common certificate issues
                <span class="cov0" title="0">if strings.Contains(err.Error(), "certificate") || strings.Contains(err.Error(), "x509") </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS certificate verification failed: %w. Consider using --skip-tls-validation for development environments", err)
                }</span>

                // Handle the specific case where ServerName is missing
                <span class="cov0" title="0">if strings.Contains(err.Error(), "either ServerName or InsecureSkipVerify") </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS configuration error: %w. When using IP addresses, either specify --tls-server-name or use --skip-tls-validation", err)
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("TLS handshake failed: %w", err)</span>
        }

        // Clear any deadlines set for the handshake
        <span class="cov0" title="0">if tcpConn, ok := c.conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                _ = tcpConn.SetReadDeadline(time.Time{})
                _ = tcpConn.SetWriteDeadline(time.Time{})
        }</span>

        <span class="cov0" title="0">c.conn = tlsConn
        c.buffReader = bufio.NewReaderSize(c.conn, readBufferSize)

        return nil</span>
}

func (c *Client) getServerName() string <span class="cov10" title="20">{
        if c.conn == nil </span><span class="cov5" title="4">{
                return ""
        }</span>

        <span class="cov9" title="16">remoteAddr := c.conn.RemoteAddr().String()
        if remoteAddr == "" </span><span class="cov3" title="2">{
                return ""
        }</span>

        <span class="cov8" title="14">host, _, err := net.SplitHostPort(remoteAddr)
        if err != nil </span><span class="cov4" title="3">{
                // Fallback to extracting from hostname if available
                parts := strings.Split(remoteAddr, ":")
                if len(parts) &gt; 0 </span><span class="cov4" title="3">{
                        host = parts[0]
                }</span> else<span class="cov0" title="0"> {
                        return ""
                }</span>
        }

        // Clean up the hostname
        <span class="cov8" title="14">host = strings.TrimSpace(host)
        if host == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // For IP addresses, we might not want to verify the hostname anyway
        // Return empty to let Go use the IP directly
        <span class="cov8" title="14">if net.ParseIP(host) != nil </span><span class="cov5" title="5">{
                return ""
        }</span>

        // Validate hostname format
        <span class="cov7" title="9">if len(host) &gt; 253 </span><span class="cov1" title="1">{ // Maximum hostname length
                return ""
        }</span>

        <span class="cov7" title="8">return host</span>
}

func (c *Client) getMinTLSVersion(version string) uint16 <span class="cov9" title="17">{
        switch version </span>{
        case "1.0":<span class="cov3" title="2">
                return tls.VersionTLS10</span>
        case "1.1":<span class="cov3" title="2">
                return tls.VersionTLS11</span>
        case "1.2":<span class="cov3" title="2">
                return tls.VersionTLS12</span>
        case "1.3":<span class="cov3" title="2">
                return tls.VersionTLS13</span>
        default:<span class="cov7" title="9">
                return tls.VersionTLS12</span> // Safe default
        }
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package rdp

import (
        "bufio"
)

type ProtocolCode uint8

func (a ProtocolCode) IsFastpath() bool <span class="cov10" title="24">{
        return a&amp;0x3 == 0
}</span>

func (a ProtocolCode) IsX224() bool <span class="cov9" title="21">{
        return a == 3
}</span>

func receiveProtocol(bufReader *bufio.Reader) (ProtocolCode, error) <span class="cov8" title="13">{
        action, err := bufReader.ReadByte()
        if err != nil </span><span class="cov2" title="2">{
                return 0, err
        }</span>

        <span class="cov7" title="11">err = bufReader.UnreadByte()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov7" title="11">return ProtocolCode(action), nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package rdp

import (
        "bytes"
        "encoding/binary"
        "io"
)

type ChannelFlag uint32

const (
        // ChannelFlagFirst CHANNEL_FLAG_FIRST
        ChannelFlagFirst ChannelFlag = 0x00000001

        // ChannelFlagLast CHANNEL_FLAG_LAST
        ChannelFlagLast ChannelFlag = 0x00000002

        // ChannelFlagShowProtocol CHANNEL_FLAG_SHOW_PROTOCOL
        ChannelFlagShowProtocol ChannelFlag = 0x00000010

        // ChannelFlagSuspend CHANNEL_FLAG_SUSPEND
        ChannelFlagSuspend ChannelFlag = 0x00000020

        // ChannelFlagResume CHANNEL_FLAG_RESUME
        ChannelFlagResume ChannelFlag = 0x00000040

        // ChannelFlagShadowPersistent CHANNEL_FLAG_SHADOW_PERSISTENT
        ChannelFlagShadowPersistent ChannelFlag = 0x00000080

        // ChannelFlagCompressed CHANNEL_PACKET_COMPRESSED
        ChannelFlagCompressed ChannelFlag = 0x00200000

        // ChannelFlagAtFront CHANNEL_PACKET_AT_FRONT
        ChannelFlagAtFront ChannelFlag = 0x00400000

        // ChannelFlagFlushed CHANNEL_PACKET_FLUSHED
        ChannelFlagFlushed ChannelFlag = 0x00800000
)

// ChannelPDUHeader CHANNEL_PDU_HEADER
type ChannelPDUHeader struct {
        Flags ChannelFlag
}

func (h *ChannelPDUHeader) Serialize() []byte <span class="cov9" title="40">{
        buf := new(bytes.Buffer)

        _ = binary.Write(buf, binary.LittleEndian, uint32(8))
        _ = binary.Write(buf, binary.LittleEndian, uint32(h.Flags))

        return buf.Bytes()
}</span>

func (h *ChannelPDUHeader) Deserialize(wire io.Reader) error <span class="cov10" title="58">{
        var (
                err    error
                length uint32
        )

        err = binary.Read(wire, binary.LittleEndian, &amp;length)
        if err != nil </span><span class="cov6" title="10">{
                return err
        }</span>

        <span class="cov9" title="48">err = binary.Read(wire, binary.LittleEndian, &amp;h.Flags)
        if err != nil </span><span class="cov4" title="6">{
                return err
        }</span>

        <span class="cov9" title="42">return nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package rdp

func (c *Client) Write(b []byte) (int, error) <span class="cov10" title="4">{
        return c.conn.Write(b)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
