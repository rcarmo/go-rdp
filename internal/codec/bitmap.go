package codec

import "sync"

// FlipVertical flips bitmap data vertically (in-place).
// RDP sends bitmaps bottom-up, this flips them to top-down.
func FlipVertical(data []byte, width, height, bytesPerPixel int) {
	if height <= 1 {
		return
	}

	rowDelta := width * bytesPerPixel
	if rowDelta <= 0 || len(data) < height*rowDelta {
		return
	}

	tmp := make([]byte, rowDelta)
	half := height / 2

	for i := 0; i < half; i++ {
		topLine := i * rowDelta
		bottomLine := (height - 1 - i) * rowDelta

		copy(tmp, data[topLine:topLine+rowDelta])
		copy(data[topLine:topLine+rowDelta], data[bottomLine:bottomLine+rowDelta])
		copy(data[bottomLine:bottomLine+rowDelta], tmp)
	}
}

// paletteMu protects currentPalette from concurrent access
var paletteMu sync.RWMutex

// currentPalette holds the active 256-color palette (set by server via palette update)
var currentPalette [256][4]byte // RGBA format

// SetPalette updates the current palette from server data
// RDP palette format: array of RGB entries (R, G, B - 3 bytes each)
// Thread-safe: uses mutex for concurrent access.
func SetPalette(data []byte, numColors int) {
	paletteMu.Lock()
	defer paletteMu.Unlock()

	if numColors > 256 {
		numColors = 256
	}
	for i := 0; i < numColors && i*3+2 < len(data); i++ {
		// RDP sends RGB format (3 bytes per entry)
		currentPalette[i][0] = data[i*3+0] // R
		currentPalette[i][1] = data[i*3+1] // G
		currentPalette[i][2] = data[i*3+2] // B
		currentPalette[i][3] = 255         // A
	}
}

// Palette8ToRGBA converts 8-bit paletted data to 32-bit RGBA using current palette
// Thread-safe: uses mutex for concurrent access.
func Palette8ToRGBA(src []byte, dst []byte) {
	paletteMu.RLock()
	defer paletteMu.RUnlock()

	for i := 0; i < len(src) && i*4+3 < len(dst); i++ {
		idx := src[i]
		dst[i*4] = currentPalette[idx][0]
		dst[i*4+1] = currentPalette[idx][1]
		dst[i*4+2] = currentPalette[idx][2]
		dst[i*4+3] = currentPalette[idx][3]
	}
}

// init initializes the palette with default Windows system colors
func init() {
	// Initialize with default Windows system palette
	for i := 0; i < 256; i++ {
		currentPalette[i][0] = defaultPalette[i][0]
		currentPalette[i][1] = defaultPalette[i][1]
		currentPalette[i][2] = defaultPalette[i][2]
		currentPalette[i][3] = 255
	}
}

// defaultPalette is the Windows default 256-color system palette
var defaultPalette = [256][3]byte{
	// First 10: Windows system colors
	{0x00, 0x00, 0x00}, // 0: Black
	{0x80, 0x00, 0x00}, // 1: Dark Red
	{0x00, 0x80, 0x00}, // 2: Dark Green
	{0x80, 0x80, 0x00}, // 3: Dark Yellow
	{0x00, 0x00, 0x80}, // 4: Dark Blue
	{0x80, 0x00, 0x80}, // 5: Dark Magenta
	{0x00, 0x80, 0x80}, // 6: Dark Cyan
	{0xC0, 0xC0, 0xC0}, // 7: Light Gray
	{0xC0, 0xDC, 0xC0}, // 8: Money Green
	{0xA6, 0xCA, 0xF0}, // 9: Sky Blue
	// 10-245: Color cube (6x6x6 = 216 colors)
	{0x00, 0x00, 0x00}, {0x00, 0x00, 0x33}, {0x00, 0x00, 0x66}, {0x00, 0x00, 0x99}, {0x00, 0x00, 0xCC}, {0x00, 0x00, 0xFF},
	{0x00, 0x33, 0x00}, {0x00, 0x33, 0x33}, {0x00, 0x33, 0x66}, {0x00, 0x33, 0x99}, {0x00, 0x33, 0xCC}, {0x00, 0x33, 0xFF},
	{0x00, 0x66, 0x00}, {0x00, 0x66, 0x33}, {0x00, 0x66, 0x66}, {0x00, 0x66, 0x99}, {0x00, 0x66, 0xCC}, {0x00, 0x66, 0xFF},
	{0x00, 0x99, 0x00}, {0x00, 0x99, 0x33}, {0x00, 0x99, 0x66}, {0x00, 0x99, 0x99}, {0x00, 0x99, 0xCC}, {0x00, 0x99, 0xFF},
	{0x00, 0xCC, 0x00}, {0x00, 0xCC, 0x33}, {0x00, 0xCC, 0x66}, {0x00, 0xCC, 0x99}, {0x00, 0xCC, 0xCC}, {0x00, 0xCC, 0xFF},
	{0x00, 0xFF, 0x00}, {0x00, 0xFF, 0x33}, {0x00, 0xFF, 0x66}, {0x00, 0xFF, 0x99}, {0x00, 0xFF, 0xCC}, {0x00, 0xFF, 0xFF},
	{0x33, 0x00, 0x00}, {0x33, 0x00, 0x33}, {0x33, 0x00, 0x66}, {0x33, 0x00, 0x99}, {0x33, 0x00, 0xCC}, {0x33, 0x00, 0xFF},
	{0x33, 0x33, 0x00}, {0x33, 0x33, 0x33}, {0x33, 0x33, 0x66}, {0x33, 0x33, 0x99}, {0x33, 0x33, 0xCC}, {0x33, 0x33, 0xFF},
	{0x33, 0x66, 0x00}, {0x33, 0x66, 0x33}, {0x33, 0x66, 0x66}, {0x33, 0x66, 0x99}, {0x33, 0x66, 0xCC}, {0x33, 0x66, 0xFF},
	{0x33, 0x99, 0x00}, {0x33, 0x99, 0x33}, {0x33, 0x99, 0x66}, {0x33, 0x99, 0x99}, {0x33, 0x99, 0xCC}, {0x33, 0x99, 0xFF},
	{0x33, 0xCC, 0x00}, {0x33, 0xCC, 0x33}, {0x33, 0xCC, 0x66}, {0x33, 0xCC, 0x99}, {0x33, 0xCC, 0xCC}, {0x33, 0xCC, 0xFF},
	{0x33, 0xFF, 0x00}, {0x33, 0xFF, 0x33}, {0x33, 0xFF, 0x66}, {0x33, 0xFF, 0x99}, {0x33, 0xFF, 0xCC}, {0x33, 0xFF, 0xFF},
	{0x66, 0x00, 0x00}, {0x66, 0x00, 0x33}, {0x66, 0x00, 0x66}, {0x66, 0x00, 0x99}, {0x66, 0x00, 0xCC}, {0x66, 0x00, 0xFF},
	{0x66, 0x33, 0x00}, {0x66, 0x33, 0x33}, {0x66, 0x33, 0x66}, {0x66, 0x33, 0x99}, {0x66, 0x33, 0xCC}, {0x66, 0x33, 0xFF},
	{0x66, 0x66, 0x00}, {0x66, 0x66, 0x33}, {0x66, 0x66, 0x66}, {0x66, 0x66, 0x99}, {0x66, 0x66, 0xCC}, {0x66, 0x66, 0xFF},
	{0x66, 0x99, 0x00}, {0x66, 0x99, 0x33}, {0x66, 0x99, 0x66}, {0x66, 0x99, 0x99}, {0x66, 0x99, 0xCC}, {0x66, 0x99, 0xFF},
	{0x66, 0xCC, 0x00}, {0x66, 0xCC, 0x33}, {0x66, 0xCC, 0x66}, {0x66, 0xCC, 0x99}, {0x66, 0xCC, 0xCC}, {0x66, 0xCC, 0xFF},
	{0x66, 0xFF, 0x00}, {0x66, 0xFF, 0x33}, {0x66, 0xFF, 0x66}, {0x66, 0xFF, 0x99}, {0x66, 0xFF, 0xCC}, {0x66, 0xFF, 0xFF},
	{0x99, 0x00, 0x00}, {0x99, 0x00, 0x33}, {0x99, 0x00, 0x66}, {0x99, 0x00, 0x99}, {0x99, 0x00, 0xCC}, {0x99, 0x00, 0xFF},
	{0x99, 0x33, 0x00}, {0x99, 0x33, 0x33}, {0x99, 0x33, 0x66}, {0x99, 0x33, 0x99}, {0x99, 0x33, 0xCC}, {0x99, 0x33, 0xFF},
	{0x99, 0x66, 0x00}, {0x99, 0x66, 0x33}, {0x99, 0x66, 0x66}, {0x99, 0x66, 0x99}, {0x99, 0x66, 0xCC}, {0x99, 0x66, 0xFF},
	{0x99, 0x99, 0x00}, {0x99, 0x99, 0x33}, {0x99, 0x99, 0x66}, {0x99, 0x99, 0x99}, {0x99, 0x99, 0xCC}, {0x99, 0x99, 0xFF},
	{0x99, 0xCC, 0x00}, {0x99, 0xCC, 0x33}, {0x99, 0xCC, 0x66}, {0x99, 0xCC, 0x99}, {0x99, 0xCC, 0xCC}, {0x99, 0xCC, 0xFF},
	{0x99, 0xFF, 0x00}, {0x99, 0xFF, 0x33}, {0x99, 0xFF, 0x66}, {0x99, 0xFF, 0x99}, {0x99, 0xFF, 0xCC}, {0x99, 0xFF, 0xFF},
	{0xCC, 0x00, 0x00}, {0xCC, 0x00, 0x33}, {0xCC, 0x00, 0x66}, {0xCC, 0x00, 0x99}, {0xCC, 0x00, 0xCC}, {0xCC, 0x00, 0xFF},
	{0xCC, 0x33, 0x00}, {0xCC, 0x33, 0x33}, {0xCC, 0x33, 0x66}, {0xCC, 0x33, 0x99}, {0xCC, 0x33, 0xCC}, {0xCC, 0x33, 0xFF},
	{0xCC, 0x66, 0x00}, {0xCC, 0x66, 0x33}, {0xCC, 0x66, 0x66}, {0xCC, 0x66, 0x99}, {0xCC, 0x66, 0xCC}, {0xCC, 0x66, 0xFF},
	{0xCC, 0x99, 0x00}, {0xCC, 0x99, 0x33}, {0xCC, 0x99, 0x66}, {0xCC, 0x99, 0x99}, {0xCC, 0x99, 0xCC}, {0xCC, 0x99, 0xFF},
	{0xCC, 0xCC, 0x00}, {0xCC, 0xCC, 0x33}, {0xCC, 0xCC, 0x66}, {0xCC, 0xCC, 0x99}, {0xCC, 0xCC, 0xCC}, {0xCC, 0xCC, 0xFF},
	{0xCC, 0xFF, 0x00}, {0xCC, 0xFF, 0x33}, {0xCC, 0xFF, 0x66}, {0xCC, 0xFF, 0x99}, {0xCC, 0xFF, 0xCC}, {0xCC, 0xFF, 0xFF},
	{0xFF, 0x00, 0x00}, {0xFF, 0x00, 0x33}, {0xFF, 0x00, 0x66}, {0xFF, 0x00, 0x99}, {0xFF, 0x00, 0xCC}, {0xFF, 0x00, 0xFF},
	{0xFF, 0x33, 0x00}, {0xFF, 0x33, 0x33}, {0xFF, 0x33, 0x66}, {0xFF, 0x33, 0x99}, {0xFF, 0x33, 0xCC}, {0xFF, 0x33, 0xFF},
	{0xFF, 0x66, 0x00}, {0xFF, 0x66, 0x33}, {0xFF, 0x66, 0x66}, {0xFF, 0x66, 0x99}, {0xFF, 0x66, 0xCC}, {0xFF, 0x66, 0xFF},
	{0xFF, 0x99, 0x00}, {0xFF, 0x99, 0x33}, {0xFF, 0x99, 0x66}, {0xFF, 0x99, 0x99}, {0xFF, 0x99, 0xCC}, {0xFF, 0x99, 0xFF},
	{0xFF, 0xCC, 0x00}, {0xFF, 0xCC, 0x33}, {0xFF, 0xCC, 0x66}, {0xFF, 0xCC, 0x99}, {0xFF, 0xCC, 0xCC}, {0xFF, 0xCC, 0xFF},
	{0xFF, 0xFF, 0x00}, {0xFF, 0xFF, 0x33}, {0xFF, 0xFF, 0x66}, {0xFF, 0xFF, 0x99}, {0xFF, 0xFF, 0xCC}, {0xFF, 0xFF, 0xFF},
	// 226-245: Grayscale ramp
	{0x08, 0x08, 0x08}, {0x12, 0x12, 0x12}, {0x1C, 0x1C, 0x1C}, {0x26, 0x26, 0x26},
	{0x30, 0x30, 0x30}, {0x3A, 0x3A, 0x3A}, {0x44, 0x44, 0x44}, {0x4E, 0x4E, 0x4E},
	{0x58, 0x58, 0x58}, {0x62, 0x62, 0x62}, {0x6C, 0x6C, 0x6C}, {0x76, 0x76, 0x76},
	{0x80, 0x80, 0x80}, {0x8A, 0x8A, 0x8A}, {0x94, 0x94, 0x94}, {0x9E, 0x9E, 0x9E},
	{0xA8, 0xA8, 0xA8}, {0xB2, 0xB2, 0xB2}, {0xBC, 0xBC, 0xBC}, {0xE6, 0xE6, 0xE6},
	// 246-255: Windows system colors (end)
	{0xFF, 0xFB, 0xF0}, // 246: Cream
	{0xA0, 0xA0, 0xA4}, // 247: Medium Gray
	{0x80, 0x80, 0x80}, // 248: Dark Gray
	{0xFF, 0x00, 0x00}, // 249: Red
	{0x00, 0xFF, 0x00}, // 250: Green
	{0xFF, 0xFF, 0x00}, // 251: Yellow
	{0x00, 0x00, 0xFF}, // 252: Blue
	{0xFF, 0x00, 0xFF}, // 253: Magenta
	{0x00, 0xFF, 0xFF}, // 254: Cyan
	{0xFF, 0xFF, 0xFF}, // 255: White
}

// RGB555ToRGBA converts 15-bit RGB555 to 32-bit RGBA
func RGB555ToRGBA(src []byte, dst []byte) {
	srcIdx := 0
	dstIdx := 0

	for srcIdx+1 < len(src) && dstIdx+3 < len(dst) {
		pel := uint16(src[srcIdx]) | (uint16(src[srcIdx+1]) << 8)

		r := (pel & 0x7C00) >> 10
		g := (pel & 0x03E0) >> 5
		b := pel & 0x001F

		// Expand 5/5/5 to 8/8/8
		r = (r << 3) | (r >> 2)
		g = (g << 3) | (g >> 2)
		b = (b << 3) | (b >> 2)

		dst[dstIdx] = byte(r)
		dst[dstIdx+1] = byte(g)
		dst[dstIdx+2] = byte(b)
		dst[dstIdx+3] = 255

		srcIdx += 2
		dstIdx += 4
	}
}

// RGB565ToRGBA converts 16-bit RGB565 to 32-bit RGBA
func RGB565ToRGBA(src []byte, dst []byte) {
	srcIdx := 0
	dstIdx := 0

	for srcIdx+1 < len(src) && dstIdx+3 < len(dst) {
		pel := uint16(src[srcIdx]) | (uint16(src[srcIdx+1]) << 8)

		r := (pel & 0xF800) >> 11
		g := (pel & 0x07E0) >> 5
		b := pel & 0x001F

		// Expand 5/6/5 to 8/8/8
		r = (r << 3) | (r >> 2)
		g = (g << 2) | (g >> 4)
		b = (b << 3) | (b >> 2)

		dst[dstIdx] = byte(r)
		dst[dstIdx+1] = byte(g)
		dst[dstIdx+2] = byte(b)
		dst[dstIdx+3] = 255

		srcIdx += 2
		dstIdx += 4
	}
}

// BGR24ToRGBA converts 24-bit BGR to 32-bit RGBA
func BGR24ToRGBA(src []byte, dst []byte) {
	srcIdx := 0
	dstIdx := 0

	for srcIdx+2 < len(src) && dstIdx+3 < len(dst) {
		dst[dstIdx] = src[srcIdx+2]   // R
		dst[dstIdx+1] = src[srcIdx+1] // G
		dst[dstIdx+2] = src[srcIdx]   // B
		dst[dstIdx+3] = 255

		srcIdx += 3
		dstIdx += 4
	}
}

// BGRA32ToRGBA converts 32-bit BGRA to 32-bit RGBA
func BGRA32ToRGBA(src []byte, dst []byte) {
	for i := 0; i+3 < len(src) && i+3 < len(dst); i += 4 {
		dst[i] = src[i+2]   // R
		dst[i+1] = src[i+1] // G
		dst[i+2] = src[i]   // B
		dst[i+3] = 255
	}
}

// ProcessBitmap handles decompression, flip, and color conversion in one call.
// Returns the RGBA output buffer on success, nil on failure.
// Note: MS-RDPBCGR RLE only supports up to 24-bit. For 32-bit color depth,
// xrdp uses RDP6 Planar codec (separate color planes with RLE).
func ProcessBitmap(src []byte, width, height, bpp int, isCompressed bool, rowDelta int) []byte {
	pixelCount := width * height

	// For 32-bit compressed, check if it's planar codec (first byte has format header)
	if isCompressed && bpp == 32 && len(src) > 0 {
		// Check for planar codec format header
		formatHeader := src[0]
		if formatHeader&0xC0 == 0 { // Reserved bits should be 0 for planar
			rgba := DecompressPlanar(src, width, height)
			if rgba != nil {
				return rgba
			}
		}
	}

	var raw []byte
	var rawBytesPerPixel int

	if isCompressed {
		switch bpp {
		case 8:
			rawBytesPerPixel = 1
			rawSize := width * height * rawBytesPerPixel
			raw = make([]byte, rawSize)
			if !RLEDecompress8(src, raw, width*rawBytesPerPixel) {
				return nil
			}
		case 15:
			rawBytesPerPixel = 2
			rawSize := width * height * rawBytesPerPixel
			raw = make([]byte, rawSize)
			if !RLEDecompress15(src, raw, width*rawBytesPerPixel) {
				return nil
			}
		case 16:
			rawBytesPerPixel = 2
			rawSize := width * height * rawBytesPerPixel
			raw = make([]byte, rawSize)
			if !RLEDecompress16(src, raw, width*rawBytesPerPixel) {
				return nil
			}
		case 24, 32:
			// MS-RDPBCGR: RLE only supports up to 24-bit (3 bytes per pixel)
			// 32-bit color depth uses 24-bit encoding in compressed stream
			rawBytesPerPixel = 3
			rawSize := width * height * rawBytesPerPixel
			raw = make([]byte, rawSize)
			if !RLEDecompress24(src, raw, width*rawBytesPerPixel) {
				return nil
			}
		default:
			return nil
		}
	} else {
		// Uncompressed data
		switch bpp {
		case 8:
			rawBytesPerPixel = 1
		case 15, 16:
			rawBytesPerPixel = 2
		case 24:
			rawBytesPerPixel = 3
		case 32:
			rawBytesPerPixel = 4
		default:
			rawBytesPerPixel = bpp / 8
		}
		rawSize := width * height * rawBytesPerPixel
		raw = make([]byte, rawSize)
		copyLen := len(src)
		if copyLen > rawSize {
			copyLen = rawSize
		}
		copy(raw, src[:copyLen])
	}

	// Flip vertically (RDP sends bottom-up)
	FlipVertical(raw, width, height, rawBytesPerPixel)

	// Convert to RGBA
	rgba := make([]byte, pixelCount*4)
	switch bpp {
	case 8:
		Palette8ToRGBA(raw, rgba)
	case 15:
		RGB555ToRGBA(raw, rgba)
	case 16:
		RGB565ToRGBA(raw, rgba)
	case 24:
		BGR24ToRGBA(raw, rgba)
	case 32:
		BGRA32ToRGBA(raw, rgba)
	default:
		return nil
	}

	return rgba
}
